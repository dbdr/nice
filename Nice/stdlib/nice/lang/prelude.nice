/****************************************************************************
 *                                 N I C E                                  *
 *              A high-level object-oriented research language              *
 *                         (c) Daniel Bonniot 2003                          *
 *                                                                          *
 *  This package is free software; you can redistribute it and/or modify    *
 *  it under the terms of the GNU General Public License as published by    *
 *  Free Software Foundation; either version 2 of the License, or (at your  *
 *  option) any later version.                                              *
 *                                                                          *
 *  As a special exception, the copyright holders of this library give you  *
 *  permission to link this library with independent modules to produce an  *
 *  executable, regardless of the license terms of these independent        *
 *  modules, and to copy and distribute the resulting executable under      *
 *  terms of your choice.                                                   *
 ****************************************************************************/

/**
   This file is part of the nice.lang package, which is imported
   automatically by any Nice package.
   In addition, this prelude file is read before any other file
   in the nice.lang package. Definitions that need to be read
   early, like native types, should therefore be in this file.
   It is best to reserve this file for such uses.
   
   @version $Date$
   @author Daniel Bonniot
 */

package nice.lang;

/****************************************************************
 * Nullness markers
 ****************************************************************/

abstract class Maybe<+T> = native;
final class Sure<+T> extends Maybe<T> = native;
final class Null<+T> extends Maybe<T> = native;

/** 
    Throws java.lang.NullPointerException if the argument is <code>null</code>.

    This call presently does no check, assuming that a dereferencing
    is coming next and will detect nullness.
    This should probably be fixed so that the semantics is well defined.
*/
<Any T> !T notNull(?T value)
{
  assert(value != null);
  return cast(value);
}

/****************************************************************
 * Primitive types
 ****************************************************************/

final class void = native;

final class boolean implements BooleanAlgebra, Comparable = native;

class Number implements Comparable = native java.lang.Number;
class double extends Number = native;
class float  extends double = native;

class long   extends float  = native;
class int    extends long   = native;
class short  extends int    = native;
class byte   extends short  = native;

final class char = native;

double doubleValue(Number) = native double Number.doubleValue();

class Throwable = native java.lang.Throwable;
class Type = native;

/* 
   Allows to consider any nice object as an instance of java.lang.Object
*/
<Any T> Object object(T) = native Object Native.object(Object);

/** Unsafe cast operator. UNSAFE! */
<Any T, Any U> U cast(T) = inline nice.lang.inline.Nop();

/****************************************************************
 * Basic functions
 ****************************************************************/

<Any T> boolean `==`(T,T) = inline nice.lang.inline.ReferenceOp("==");
<Any T> boolean `!=`(T,T) = inline nice.lang.inline.ReferenceOp("!=");

boolean `==`(char, char) = inline nice.lang.inline.CompOp("iEq");
boolean `!=`(char, char) = inline nice.lang.inline.CompOp("iNe");


<Any T> boolean equals(!T,!T) = native boolean Object.equals(Object);
<Any T> boolean equals(?T a, ?T b)
{
  if (a != null && b != null)
    return a.equals(b);
  else
    return a==b;  // true iff both null
}

<T> int hashCode(!T) = native int Object.hashCode();

<Any T> String toString(!T) = native String Object.toString();
<Any T> String valueOf(T) = native String String.valueOf(Object);
<Any T> Class getClass(!T) = native Class Object.getClass();

<Any T> void wait(!T) = native void Object.wait();
<Any T> void wait(!T, long) = native void Object.wait(long);
<Any T> void wait(!T, long, int) = native void Object.wait(long, int);
<Any T> void notify(!T) = native void Object.notify();
<Any T> void notifyAll(!T) = native void Object.notifyAll();

/** 
    This function will throw CloneNotSupportedException if the argument
    does not implement java.lang.Cloneable.

    We will give a stricter type later when we can uniformly describe
    cloneable classes of arbitrary variances.
*/
<T> T clone(T) = native Object java.lang.Object.clone();

/****************************************************************
 * Ref
 ****************************************************************/

class Ref<T> { T value; }
