/**************************************************************************/
/*                           B O S S A                                    */
/*        A simple imperative object-oriented research language           */
/*                   (c)  Daniel Bonniot 1999                             */
/*                                                                        */
/*  This program is free software; you can redistribute it and/or modify  */
/*  it under the terms of the GNU General Public License as published by  */
/*  the Free Software Foundation; either version 2 of the License, or     */
/*  (at your option) any later version.                                   */
/*                                                                        */
/**************************************************************************/

// File    : parser.jj
// Created : Thu Jul 01 10:27:05 1999 by bonniot
//$Modified: Wed Aug 18 13:29:19 1999 by bonniot $
// Description : Parseur JavaCC pour Bossa
//   Tokens based on the Jazz parser

options {
  JAVA_UNICODE_ESCAPE = true;
  //DEBUG_LOOKAHEAD = true;
}

PARSER_BEGIN(Parser)

package bossa.parser;

import java.io.*;
import java.util.*;

import bossa.util.*;
import bossa.syntax.*;

class Parser
{
    // it is better to get a Collection than an AST:
    // it is thus easier to get some definitions from a prolog first
    public static Collection parse(Reader r) throws ParseException
    {
	Parser p=new Parser(r);
	return p.definitions();
    }
}

PARSER_END(Parser)

/***********************************************************************
 * Comments
 ***********************************************************************/

// picked from JavaCC-1.1.jj grammar out of JavaCC examples

/* WHITE SPACE */

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| "\f"
}

/* COMMENTS */

MORE :
{
  "//" : IN_SINGLE_LINE_COMMENT
|
  <"/**" ~["/"]> { input_stream.backup(1); } : IN_FORMAL_COMMENT
|
  "/*" : IN_MULTI_LINE_COMMENT
}

<IN_SINGLE_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <SINGLE_LINE_COMMENT: "\n" | "\r" | "\r\n" > : DEFAULT
}

<IN_FORMAL_COMMENT>
SPECIAL_TOKEN :
{
  <FORMAL_COMMENT: "*/" > : DEFAULT
}

<IN_MULTI_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <MULTI_LINE_COMMENT: "*/" > : DEFAULT
}

<IN_SINGLE_LINE_COMMENT,IN_FORMAL_COMMENT,IN_MULTI_LINE_COMMENT>
MORE :
{
  < ~[] >
}

/***********************************************************************
 * Reserved tokens
 ***********************************************************************/

TOKEN: /* Separators, Delimiters */
{
  < LPAR:       "("   >
| < RPAR:       ")"   >
| < LBRK:       "["   >
| < RBRK:       "]"   >
| < LBRACE:     "{"   >
| < RBRACE:     "}"   >
| < LPRAGMA:    "<*"  >
| < RPRAGMA:    "*>"  >
| < DOT:        "."   >
| < COLON:      ":"   >
| < COMMA:      ","   >
| < SEMI:       ";"   >
| < DOTDOT:     ".."  >
| < MAPSTO:     "->"  >
| < COND:       "?"   >
| < ANY:        "_"   >
| < BACKSLASH:  "\\"  >      
}

TOKEN: /* Operators */
{
  < EQ:      "="   >
| < PLUS:    "+"   >
| < MINUS:   "-"   >
| < POWER:   "**"  >
| < MULT:    "*"   >
| < SLASH:   "/"   >
| < NEQ:     "!="  >
| < DIV:     "div" >
| < MOD:     "%"   >
| < LNOT:    "!"   >
| < BAND:    "&"   >
| < BOR:     "|"   >
| < BXOR:    "^"   >
| < BNOT:    "~"   >
| < LEQ:     "<="  >
| < GEQ:     ">="  >
| < EQEQ:    "=="  >
| < SUB:     "<:"  >
| < LT:      "<"   >
| < GT:      ">"   >
| < LAND:    "&&"  >
| < LOR:     "||"  >
| < LSHIFT:  "<<"  >
// RSHIFT is not a token: operator >> is made of two consecutive tokens ">"
}

TOKEN: /* Keywords */
{
  < CLASS:      "class"      >
| < INTERFACE:  "interface"  >
| < IMPLEMENTS: "implements" >
| < ABSTRACTS:  "abstracts"  >
| < DOMAIN:     "domain"     >
| < AT:         "@"          >
| < ASSERT:     "assert"     >
| < INPUT:      "input"      >
| < OUTPUT:     "output"     >
| < FOR:        "for"        >
| < IF:         "if"         >
| < ELSE:       "else"       >
| < TRUE:       "true"       >
| < FALSE:      "false"      >
| < PRINT:      "print"      >
| < FORMAT:     "format"     >
| < ERROR:      "error"      >
| < FUN:        "fun"        >
| < ALIKE:      "alike"      >
//| < THIS:       "this"       >
| < EXTENDS:    "extends"    >
| < RESET:      "reset"      >
| < ENABLE:     "enable"     >
| < NATIVE:     "native"     >
| < FINAL:      "final"      >
| < PRAGMA:     "pragma"     >
| < INSTANCEOF: "instanceof" >
| < DYNAMIC:    "dynamic"    >
| < NEW:        "new"        >
| < CLONE:      "clone"      >
| < PUBLIC:     "public"     >
| < STATIC:     "static"     >
| < IMPORT:     "import"     >
| < PACKAGE:    "package"    >
| < REQUIRE:    "require"    >
| < EXPORT:     "export"     >
| < EXTERN:     "extern"     >
| < AS:         "as"         >
| < VAR:        "var"        >

| < ANY_:	"Any"        >
// Statements
| < RETURN:     "return"     >

// reserved for future use
| < PRIVATE:    "private"    >
| < PROTECTED:  "protected"  >      
}


/***********************************************************************
 * Literals
 ***********************************************************************/
TOKEN: /* Different kinds of digits */
{
  < #DIGIT:  ["0"-"9"] >                     // decimal
| < #XDIGIT: ["0"-"9", "a"-"f", "A"-"F"] >   // hexadecimal
| < #ODIGIT: ["0"-"7"] >		     // octal
| < #BDIGIT: ["0", "1"] >		     // binary
}


TOKEN: /* Integer literals */
{
  < LINT: (  (<DIGIT>)+				// decimal
           | "0" ["x", "X"] (<XDIGIT>)+		// hexadecimal
	   | "0" ["o", "O"] (<ODIGIT>)+		// octal
          )
  >
}

TOKEN: /* 2adic literals */
{
  < LPER: "#" (  (<BDIGIT>)+			    // binary finite 2adic
	       |  (<BDIGIT>)* "(" (<BDIGIT>)* ")"   // periodic 2adic
              )
  >
}

TOKEN: /* Floating point literals */
{
  < FLOATING_POINT_LITERAL:
        (["0"-"9"])* "." (["0"-"9"])+ (<EXPONENT>)?
      | (["0"-"9"])+ <EXPONENT> 
  >
|
  < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
      }


TOKEN: /* String literals */
{
  < LSTRING:
      "\""
      (   (~["\"","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )*
      "\""
  >
}

/***********************************************************************
 * Identifiers
 ***********************************************************************/
// identifiers are the same as in Java, except that:
// 1. the character $ is not allowed
// 2. the character ' is allowed
// XXX: conform to Java
TOKEN:
{
  < IDENT: <IDENT_START> (<IDENT_PART>)* >
| < #IDENT_PART: (<IDENT_START> | <IDENT_DIGIT> | "'") >
| < #IDENT_START:
     [
      "\u0041"-"\u005a",
      "\u005f",
      "\u0061"-"\u007a",
      "\u00c0"-"\u00d6",
      "\u00d8"-"\u00f6",
      "\u00f8"-"\u00ff",
      "\u0100"-"\u1fff",
      "\u3040"-"\u318f",
      "\u3300"-"\u337f",
      "\u3400"-"\u3d2d",
      "\u4e00"-"\u9fff",
      "\uf900"-"\ufaff"
     ]
  >
| < #IDENT_DIGIT:
    [
     "\u0030"-"\u0039",
     "\u0660"-"\u0669",
     "\u06f0"-"\u06f9",
     "\u0966"-"\u096f",
     "\u09e6"-"\u09ef",
     "\u0a66"-"\u0a6f",
     "\u0ae6"-"\u0aef",
     "\u0b66"-"\u0b6f",
     "\u0be7"-"\u0bef",
     "\u0c66"-"\u0c6f",
     "\u0ce6"-"\u0cef",
     "\u0d66"-"\u0d6f",
     "\u0e50"-"\u0e59",
     "\u0ed0"-"\u0ed9",
     "\u1040"-"\u1049"
    ]
  >
}
 
/*
 * Illegal tokens
 */
TOKEN:
{
  < ILLEGAL_TOKEN: (~[]) >
}

/***********************************************************************/
/*                          Grammar                                    */
/***********************************************************************/

LocatedString string():
{
    Token t;
}
{
    t=<IDENT> 
    { return new LocatedString(t.image,new Location(t)); }
}

Collection strings():
{
  Collection res=new ArrayList();
  LocatedString s;
}
{
  s=string() { res.add(s); }
  ( "," s=string() { res.add(s); } )*
  { return res; }
}

int integer():
{
  Token t;
}
{
  t = <LINT> { return Integer.parseInt(t.image); }
}

double floating():
{
  Token t;
}
{
  t = <FLOATING_POINT_LITERAL> { return Double.parseDouble(t.image); }
}

/***********************************************************************/
/*                          Type Symbols                               */
/***********************************************************************/

TypeConstructor typeConstructor():
{
  LocatedString name;
}
{
  name=string()
  { return new TypeConstructor(name); }
}

Interface itf():
{
  LocatedString name;
}
{
  name=string()
  {
    return new Interface(name);
  }
}

List typeConstructors():
{
  List res=new ArrayList();
  TypeConstructor t;
}
{
  [
   "<" 
      t=typeConstructor() { res.add(t); }
      ( "," t=typeConstructor() { res.add(t); } )*   
   ">"
  ]
  { return res; }
}

TypeIdent typeIdent():
{
  LocatedString name;
}
{
  name=string()
  { return new TypeIdent(name);
  }
}

MonoSymbol monoSymbol():
{
  LocatedString name;
  Monotype type;
}
{
  type=monotype()
  name=string()
  { return new MonoSymbol(name,type,null); }
}

List monoSymbols():
{
  List res=new ArrayList();
  MonoSymbol name;
}
{
  (
    name=monoSymbol() { res.add(name); }
    ( "," name=monoSymbol() { res.add(name); } )*
  )?
  { return res; }
}

/***********************************************************************/
/*                          Constraints                                */
/***********************************************************************/

TypeSymbol binder(Collection atomics):
{
  TypeConstructor first,second=null;
  MonotypeVar id;
}
{
  "Any" id=monotypeVar(false)
  { return id;
  }
|
  first=typeConstructor() 
  second=typeConstructor()
  { 
    if(second==null)
      return first;
    atomics.add(new TypeConstructorLeqCst(second,first)); 
    return second; 
   }
}

List binders(Collection atomics):
{
    List res=new ArrayList();
    TypeSymbol t;
}
{
    t=binder(atomics) { res.add(t); }
    ( "," t=binder(atomics) { res.add(t); } )*
    { return res; }
}

AtomicConstraint atomicConstraint():
{
  Monotype m1,m2;  
  TypeIdent t1,t2;
  AtomicConstraint res;
}
{
  (
   m1=monotype()
   "<:"
   m2=monotype()
   {
     res=new MonotypeLeqCst(m1,m2);
   }
  )
    /*
|
  (
   t1=typeIdent()
   "<:"
   t2=typeIdent()
  { res=new LeqCst(t1,t2); }
  )
    */
  { return res; }
}

List atomics(List init):
{
  List res=init;
  AtomicConstraint k;
}
{
  k=atomicConstraint() { res.add(k); }
  ( "," k=atomicConstraint() { res.add(k); } ) *
  { return res; }
}

Constraint constraint():
{
  Constraint res;
  List b=null;
  List atoms=new ArrayList();
}
{
  (
    ( "{" 
      ( 
	LOOKAHEAD(2) atoms=atomics(atoms) 
      | 
        b=binders(atoms) [ "|" atoms=atomics(atoms) ] 
      )
      "}" 
      
      { res=new Constraint(b,atoms); }
    )
    | { res=Constraint.True(); }
  )
  { return res; }
}

/***********************************************************************/
/*                          Types                                      */
/***********************************************************************/

//Monotypes

MonotypeVar monotypeVar(boolean imperative):
{
  LocatedString name;
}
{
  name=string()
  { return new MonotypeVar(name,imperative); }
}

List monotypeVars(boolean imperative):
{
    List res=new ArrayList(0);
    MonotypeVar var;
}
{
    ( "<" 
      var=monotypeVar(imperative) { res.add(var); }
      ( "," var=monotypeVar(imperative) { res.add(var); } )*
    ">" )?
    { return res; }
}

Monotype monotypeConstructor():
{
    TypeConstructor t;
    Collection p=null;
    Token first,last;
}
{
  { first=getToken(1); }
  // monotypeConstructors with no type parameters (and no "<" ">")
  // are parsed as MonotypeVars, not here.
  // This is fixed during scoping.
    t=typeConstructor() 
    "<" [  p=monotypes() ] ">"
    { if(p==null) p=new ArrayList(0);
      last=getToken(0);
      Location loc=new Location(first).englobe(new Location(last));
      return new MonotypeConstructor(t,new TypeParameters(p),loc); 
    }
}

FunType funmonotype():
{
    Monotype codom;
    Collection dom;
    Constraint cst;
}
{
    "fun" "(" dom=monotypes() ")" "(" codom=monotype() ")"
    { return new FunType(dom,codom); }
}

Monotype monotype():
{
  Monotype res;
}
{
  (
  res=funmonotype()
|
  LOOKAHEAD(2)
  res=monotypeConstructor()
| 
  // we don't know yet if it is imperative or not
  // it depends on the definition of this symbol
  res=monotypeVar(false) 
  )
  { return res; }
}

Collection monotypes():
{
  Collection res=new ArrayList();
  Monotype t;
}
{
  t=monotype() { res.add(t); }
  ( "," t=monotype() { res.add(t); } )*
  { return res; }
}

TypeParameters typeParameters():
{
  Collection res=new ArrayList();
  Monotype t;
}
{
  ( "<" 
    t=monotype() { res.add(t); }
    ( "," t=monotype() { res.add(t); } )*
  ">" )
  { return new TypeParameters(res); }
}

//Polytypes

Polytype funpolytype():
{
    Monotype codom;
    Collection dom;
    Constraint cst;
}
{
    "fun" cst=constraint() "(" dom=monotypes() ")" "(" codom=monotype() ")"
    { return new Polytype(cst,new FunType(dom,codom)); }
}

Polytype polytype():
{
  Polytype res;
  Constraint cst;
  Monotype m;
}
{
  cst=constraint()
  m=monotype() 
  { res=new Polytype(cst,m); }
  { return res; }
}

Type type():
{
  Polytype p;
  Collection tp;
}
{
  tp=monotypeVars(true)
  p=polytype()
  { return Type.newType(tp,p); }
}

/***********************************************************************/
/*                          Classes                                    */
/***********************************************************************/

void field(ClassDefinition c):
{
  Monotype t;
  LocatedString name;
}
{
  t=monotype()
  name=string()
  ";"
  { c.addField(name,t); }
}

void methodDecl(ClassDefinition c):
{
  LocatedString name;
  Collection parameters,tp;
  Constraint cst;
  Monotype returnType;
  MethodDefinition def;
}
{
  returnType=monotype()
  name=string()
  tp=monotypeVars(true)
  cst=constraint()
  "("
  parameters=monotypes()
  ")"
  ";"
  { c.addMethod(new MethodDefinition(c,name,tp,cst,returnType,parameters)); }
}

void extensions(ClassDefinition c):
{
    TypeConstructor name;
}
{
    "extends"
    name=typeConstructor() { c.addExtension(name); }
    ( "," name=typeConstructor() { c.addExtension(name); } )*
}

void implementations(ClassDefinition c):
{
    Interface name;
}
{
    "implements"
    name=itf() { c.addImplementation(name); }
    ( "," name=itf() { c.addImplementation(name); } )*
}

void abstractions(ClassDefinition c):
{
    Interface name;
}
{
    "abstracts"
    name=itf() { c.addAbstraction(name); }
    ( "," name=itf() { c.addAbstraction(name); } )*
}

ClassDefinition classDefinition():
{
    ClassDefinition res;
    LocatedString name;
    List parameters;
}
{
  "class"
    name=string() 
    parameters=monotypeVars(true) 
    { res=new ClassDefinition(name,parameters); }
    ( implementations(res) | abstractions(res) | extensions(res) )*
    "{"
    ( 
      (
       //LOOKAHEAD(field(res)) 
        field(res)
	//| 
        //methodDecl(res)
      )
    )*
    "}"
    { return res; }
}

InterfaceDefinition interfaceDefinition():
{
  LocatedString name;
  Collection parameters;
}
{
  "interface"
  name=string()
  parameters=monotypeVars(true)
  ";"
  { return new InterfaceDefinition(name,parameters); }
}

Pattern pattern(LocatedString name):
{
    TypeConstructor tc;
}
{
    "@" tc=typeConstructor() 
    { return new Pattern(name,tc); }
  | { return new Pattern(name); }
}

MethodBodyDefinition methodBodyDefinition():
{
    LocatedString name,i;
    Pattern p;
    Collection binders=null;
    List parameters=new ArrayList();
    Collection tp;
    List code;
}
{
    name=string()
    tp=typeConstructors()
    [ "{" binders=strings() "}" ]
    p=pattern(new LocatedString("this",new Location(0,0,0,0))) 
      { parameters.add(p); }
    "("
    ( 
	i=string() p=pattern(i) { parameters.add(p); }
	( "," i=string() p=pattern(i) { parameters.add(p); } )*
    )?
    ")"
    "{"
    code=statements()
    "}"
    { return new MethodBodyDefinition(name,tp,binders,parameters,code); }
}

MethodDefinition methodDefinition():
{
    LocatedString name;
    Monotype returnType;
    Collection parameters,tp;
    Constraint cst;
    MethodDefinition res;
}
{
    returnType=monotype()
    name=string()
    tp=monotypeVars(true)
    cst=constraint()
    "("
    ( parameters=monotypes() | { parameters=new ArrayList(); } )
    ")"
    ";"
    { return new MethodDefinition(name,tp,cst,returnType,parameters); }
}

Definition definition():
{
    Definition res;
}
{
  (
    res=classDefinition()
  | 
    res=interfaceDefinition()
  | 
    LOOKAHEAD( monotype() string() )
    res=methodDefinition()
  | 
    res=methodBodyDefinition()
  )
  { return res; }
}

List definitions():
{
    List defs=new ArrayList();
    Definition d;
}
{
    (d = definition() { defs.add(d); })*
    <EOF> { return defs; }
}

/***********************************************************************/
/*                          Expressions                                */
/***********************************************************************/

IntConstantExp intConstantExp():
{
  int i;
}
{
  i=integer()
  { return new IntConstantExp(i); }
}

FloatConstantExp floatConstantExp():
{
  double d;
}
{
  d=floating()
  { return new FloatConstantExp(d); }
}

ConstantExp constantExp():
{
  ConstantExp res;
}
{
  (
  res=intConstantExp() 
| res=floatConstantExp()
  )
{ return res; }
}

IdentExp identExp():
{
  LocatedString i;
}
{
  i=string()
  { return new IdentExp(i); }
}

NewExp newExp():
{
  Monotype t;
}
{
  "new" 
  t=monotype()
  "(" ")" 
  { return new NewExp(t); }
}

CallExp callExp(Expression prefix):
{
  List parameters;
}
{
  "("
  parameters=expressions()
  ")"
  { return new CallExp(prefix,parameters); }
}

Expression computedExp(Expression prefix):
{
  Expression res=prefix;
  TypeParameters tp=null;
  LocatedString name;
}
{
  (
    "." name=string()
    { res=new FieldExp(res,name); }
  | 
    tp=typeParameters()
    { res=new InstantiateExp(res,tp); }
  |
    res=callExp(res)
  )*
  { return res; }
}

FunExp funExp():
{
  List formals;
  List tp;
  Constraint cst;
  List body;
}
{
  "fun" 
  tp=typeConstructors()
  cst=constraint()
  "(" formals=monoSymbols() ")"
  "=>"
  "{" body=statements() "}"
  { return new FunExp(tp,cst,formals,body); }
}

Expression expression():
{
  Expression res;
  IdentExp e;
  Token first,last;
}
{
  { first=getToken(1); }
  (
  res=constantExp()
| 
  res=newExp()
|
  res=funExp()
| 
  e=identExp() res=computedExp(e)
  )
  { 
    last=getToken(0); 
    res.setLocation(new Location(first).englobe(new Location(last)));
    return res; 
  }
}

List expressions():
{
  List res=new ArrayList();
  Expression e;
}
{
  ( e=expression() { res.add(e); }
    ( "," e=expression() { res.add(e); } )*
  )?
  { return res; }
}

/***********************************************************************/
/*                          Statements                                 */
/***********************************************************************/

AffectationStmt affectation(Expression left):
{
  Expression right;
}
{
  "="
  right=expression()
  { return new AffectationStmt(left,right); }
}

LocalDeclarationStmt localDeclaration():
{
  Type t;
  LocatedString id;
  Expression e=null;
}
{
  t=type()
  id=string()
  [ "=" e=expression() ]
  { return new LocalDeclarationStmt(id,t,e); }
}

Statement statement():
{
  Statement res;
  Expression e;
  Token first,last;
}
{
  { first=getToken(1); }
(
  "return" e=expression() ";" { res=new ReturnStmt(e); }
|
  LOOKAHEAD(type() string())
  res=localDeclaration() ";" 
| 
  (
   // Common prefix
   e=expression()
   (
    ";" { res=new ExpressionStmt(e); }
   |
    res=affectation(e) ";" 
   )
  )
)
  { last=getToken(0);
    res.setLocation(new Location(first).englobe(new Location(last)));
    return res; }
}

List statements():
{
  List res=new ArrayList();
  Statement s;
}
{
  ( s=statement() { res.add(s); } )*
  { return res; }
}
