/**************************************************************************/
/*                                N I C E                                 */
/*             A high-level object-oriented research language             */
/*                        (c) Daniel Bonniot 2001                         */
/*                                                                        */
/*  This program is free software; you can redistribute it and/or modify  */
/*  it under the terms of the GNU General Public License as published by  */
/*  the Free Software Foundation; either version 2 of the License, or     */
/*  (at your option) any later version.                                   */
/*                                                                        */
/**************************************************************************/

package bossa.modules;

import mlsub.compilation;

/**
   Stores information about a Nice compilation.

   @version $Date$
   @author Daniel Bonniot (Daniel.Bonniot@inria.fr)
**/

class Compilation extends CompilationInterface
{
  boolean recompileAll = false;
  boolean recompileCommandLine = false;

  /** Set if at least one package is not up-to-date. */
  boolean recompilationNeeded = false;

  String sourcePath = ".";
  ?String packagePath = null;
  ?String destinationDir = null;

  /** Archive file in which to write the program. */
  ?String output = null;

  /** Prevent the runtime to be written in the archive.
      Usefull for the compiler itself, if for nothing else.
  */
  boolean excludeRuntime = false;

  /** Give stricter type to java methods.
   */
  boolean strictJavaTypes = false;

  boolean storeDocStrings = false;

  /** Location of the nice.jar file. */
  ?String runtimeFile = null;

  ?Locator locator = null;

  CompilationListener listener;

  Map<String,Package> packages = new HashMap();
  Map<String,mlsub.typing.TypeConstructor> javaTypeConstructors = new HashMap();

  void setMainPackage(String packageName)
  {
    // Normalizes the compilation options.
    this.recompileCommandLine = this.recompileCommandLine || this.recompileAll;

    // Use the defaults if necessary
    // The default for destinationDir is <null>
    // which means place generated files in the source directory
    if (this.destinationDir == null && this.packagePath == null)
      this.packagePath = ".";

    String classpath =
      (this.packagePath || "") + 
      java.io.File.pathSeparator + 
      (this.destinationDir || "") + 
      java.io.File.pathSeparator + 
      this.runtimeFile;

    nice.tools.code.TypeImport.setClasspath(classpath);

    Package.startNewCompilation();

    // Create the locator that uses these two pathes to locate packages.
    this.locator = new Locator(this, classpath);

    // forces reading nice.lang first
    if(!(packageName.equals("nice.lang")) && !bossa.util.Debug.ignorePrelude())
      Package.make("nice.lang", this, false);

    this.root = Package.make
      (new bossa.syntax.LocatedString(packageName, 
				      bossa.util.Location.option), 
       this, true);
  }

  /****************************************************************
   * Error handling
   ****************************************************************/
  
  private boolean wasError = false;

  error(ex)
  {
    wasError = true;
    listener.error(notNull(ex).location, notNull(notNull(ex).message));
  }

  exitIfErrors()
  {
    if (wasError)
      throw new Exit();
  }

  warning(location, message)
  {
    listener.warning(location, notNull(message));
  }

  progress(pkg, phase)
  {
    listener.progress(notNull(pkg).getName(), notNull(phase));
  }

  /****************************************************************
   * Approximation of how far the compilation has gone.
   ****************************************************************/

  /** We wight each package by its number of declarations divided by 
      the total number. 
  */
  int totalNumberOfDeclarations = 0;

  getNumberOfDeclarations() = totalNumberOfDeclarations;

  addNumberOfDeclarations(n)
  {
    totalNumberOfDeclarations += n;
  }

  /** We accumulate the progress, because we want to report the total so far.
   */
  float totalProgress = 0;

  addProgress(weight)
  {
    totalProgress += weight / totalNumberOfDeclarations;
    listener.progress(totalProgress);
  }
}

Compilation createCompilation(CompilationListener listener) = 
  new Compilation(listener: listener);

class Exit extends RuntimeException {}
