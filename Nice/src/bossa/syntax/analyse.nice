/**************************************************************************/
/*                                N I C E                                 */
/*             A high-level object-oriented research language             */
/*                        (c) Daniel Bonniot 2000                         */
/*                                                                        */
/*  This program is free software; you can redistribute it and/or modify  */
/*  it under the terms of the GNU General Public License as published by  */
/*  the Free Software Foundation; either version 2 of the License, or     */
/*  (at your option) any later version.                                   */
/*                                                                        */
/**************************************************************************/

/*
   Scoping resolution, variable initialization test
*/

package bossa.syntax;

import nice.tools.ast;
import mlsub.typing.*;

// Interface

Statement analyse(Statement, VarScope, TypeScope, boolean mustReturnAValue);
Expression analyse(Expression, VarScope, TypeScope);

TypeMaper typeMaper(SymbolTable<TypeSymbol>,TypeScope) = 
  native new TypeMaper(SymbolTable, TypeScope);

// Implementation

Info buildInfo(VarScope, TypeScope);
buildInfo(varScope, typeScope)
{
  Info info = new Info();
  info.vars = symbolTable();
  info.typeVars = symbolTable();
  info.globalVarScope = varScope;
  info.globalTypeScope = typeScope;
  info.typeMap = typeMaper(info.typeVars, typeScope);
  info.flags = 0;
  info.flagsStack = new Vector();

  return info;
}

analyse(s@Statement, varScope, typeScope, mustReturnAValue)
{
  Info info = buildInfo(varScope, typeScope);

  try{
    analyse(s, info);
  
    if (mustReturnAValue && !info.getUnreachable())
      bossa.util.User.error(s, "Missing return statement");
  }
  catch(UnknownIdentException e){
    bossa.util.User.error(e.ident, "" + e.ident + " is not declared");
  }
  catch(bossa.util.UserError e){
    nice.tools.compiler.OutputMessages.error(e.getMessage());
  }
  return s;
}

analyse(e@Expression, varScope, typeScope) = 
    analyse(e, buildInfo(varScope, typeScope));

class Info
{
  SymbolTable<VarSymbol> vars;
  SymbolTable<TypeSymbol> typeVars;

  VarScope globalVarScope;
  TypeScope globalTypeScope;

  /* bit 0: point not reachable 
  */
  int flags; 
  boolean getUnreachable(); getUnreachable() = (this.flags & 1) != 0;
  void setUnreachable(); setUnreachable() { this.flags |= 1; }

  Stack<int> flagsStack;

  void beginInner(boolean reset);
  beginInner(reset)
  {
    this.flagsStack.push(this.flags);
    if (reset)
      this.flags = 0;
  }

  void endInner();
  endInner()
  {
    this.flags = this.flagsStack.pop();
  }

  void beginCases();
  beginCases()
  {
    this.flagsStack.push(this.flags);
    this.flagsStack.push(-1);
  }
  
  void otherCase();
  otherCase()
  {
    int prevResult = this.flagsStack.pop();
    int outer = this.flagsStack.top();
    this.flagsStack.push(this.flags & prevResult);
    this.flags = outer;
  }

  void endCases();
  endCases()
  {
    this.flags &= this.flagsStack.pop();
    this.flagsStack.pop();
  }

  // Abstract type for uniform lookup in both scopes
  // Shall probably go away sometime (at least the TypeMaper)
  TypeMap typeMap;

  void begin();
  begin()
  {
    this.vars.begin();
    this.typeVars.begin();
  }

  void end();
  end()
  {
    this.vars.end();
    this.typeVars.end();
  }

  VarSymbol lookup(String);
  lookup(name) = this.vars[name];

  JavaList<VarSymbol> globalLookup(LocatedString);
  globalLookup(name) = javaList(this.globalVarScope.lookup(name));

  TypeSymbol lookupType(LocatedString);
  lookupType(name)
  {
    TypeSymbol res = this.typeVars[name.toString()];
    if (res != null)
      return res;
    else
      return this.globalTypeScope.lookup(name);
  }

  void addVar(MonoSymbol);
  addVar(symbol)
  {
    symbol.type = symbol.syntacticType.resolve(this.typeMap);
    this.vars[symbol.name.toString()] = symbol;
  }

  void addVars(Sequence<MonoSymbol>);
  addVars(symbols) = symbols.iter(fun(MonoSymbol s)=>this.addVar(s));
  
  void addTypeVars(Sequence<TypeSymbol>);
  addTypeVars(symbols) = symbols.iter(fun(TypeSymbol s)=>this.typeVars[s.toString()]=s);
}

void setInitialized(Expression, Info);
setInitialized(e, i) {}
setInitialized(e@SymbolExp, i) {}

Expression analyse(Expression, Info);
void analyse(Statement, Info);

/****************************************************************
 * Expressions
 ****************************************************************/

analyse(e@Expression, i) = e;
analyse(@null(Expression), info) = null;

analyse(e@AssignExp, i)
{
  e.value = analyse(e.value, i);
  e.to = analyse(e.to, i);
  setInitialized(e.to, i);
  return e;
}

void analyseExps(Expression[], Info);
analyseExps(exps, info)
{
  for (int i = 0; i < exps.length; i++)
    exps[i] = analyse(exps[i], info);
}

void analyse(Arguments, Info);
analyse(args@Arguments, info)
{
  for (int i = 0; i < args.arguments.length; i++)
    args.setExp(i, analyse(args.getExp(i), info));
}

void markAsCallFun(Expression, boolean);
markAsCallFun(e, infix) {}
markAsCallFun(e@IdentExp, infix)
{
  e.infix = infix;
  e.alwaysOverloadedSymbol = true;
}

void markAsCallFirstArg(Expression);
markAsCallFirstArg(e) {}
markAsCallFirstArg(e@IdentExp)
{
  e.enableClassExp = true;
}

LocatedString identString(Expression);
identString(e) = null;
identString(e@IdentExp) = e.ident;

analyse(e@CallExp, info)
{
  if (e.infix)
    markAsCallFirstArg(e.arguments.getExp(0));

  e.arguments.analyse(info);

  if (e.infix)
    {
      e.declaringClass = e.arguments.staticClass();
      
      if (e.declaringClass != null)
	{
	  LocatedString funName = identString(e.function);
	  if (funName == null)
	    bossa.util.Internal.error(e.function, "This is not a valid class member");
	  
	  java.util.List possibilities = JavaMethod.findJavaMethods
	    (e.declaringClass, funName.toString(), e.arguments.size());

	  if (possibilities.size() == 0)
	    bossa.util.User.error(e, "class " + e.declaringClass.getName() +
				  " has no method or field " + funName);
	  
	  e.function = new OverloadedSymbolExp(possibilities, funName);

	  return e;
	}
      
      PackageExp pkg = e.arguments.packageExp();
      if (pkg != null)
	{
	  LocatedString nextComponent = identString(e.function);

	  if (nextComponent == null)
	    throw unknownIdent(pkg.locatedName());

	  return ClassExp.create(pkg, nextComponent);
	}
    }

  markAsCallFun(e.function, e.infix);
  e.function = analyse(e.function, info);

  return e;
}

analyse(e@FunExp, info)
{
  info.beginInner(true);
  info.begin();

  if (e.constraint != Constraint.True)
    {
      e.cst = e.constraint.resolveToLowlevel();
      addTypeVars(info, e.cst.binders());
    }
  e.constraint = null;

  addVars(info, e.formals);

  analyse(e.body, info);
  if (!info.getUnreachable() 
      && !e.inferredReturnType().toString().equals("nice.lang.void"))
    bossa.util.User.error(e, "Missing return statement");

  info.end();
  info.endInner();
  return e;
}

analyse(e@IdentExp, info)
{
  if (!e.infix) // infix symbols can only come from the global scope
    {
      VarSymbol s = info.lookup(e.ident.toString());
      if (s != null)
	if (!e.alwaysOverloadedSymbol)
	  return new SymbolExp(s);
	else
	  return new OverloadedSymbolExp(s, e.ident);
    }

  JavaList<VarSymbol> symbols;
  if (e.infix)
    symbols = javaList(Node.getGlobalScope().lookup(e.ident));
  else
    symbols = info.globalLookup(e.ident);

  if (symbols != null && symbols.size() > 0)
    if (!e.alwaysOverloadedSymbol() && symbols.size() == 1)
      return new SymbolExp(symbols[0]);
    else
      return new OverloadedSymbolExp(symbols.impl, e.ident);

  if (e.enableClassExp)
    return ClassExp.create(e.ident);

  //if (e.infix)
    //return e;

  if (true) throw unknownIdent(e.ident);
  return null; // work-around pb with non-reachable code
}

analyse(e@IfExp, info)
{
  e.condition = analyse(e.condition, info);

  info.beginCases();
  e.thenExp = analyse(e.thenExp, info);

  info.otherCase();
  e.elseExp = analyse(e.elseExp, info);

  info.endCases();
  return e;
}

analyse(e@IncrementExp, info)
{
  e.variable = analyse(e.variable, info);
  return e;
}

analyse(e@LiteralArrayExp, info)
{
  analyseExps(e.elements, info);
  return e;
}

analyse(e@NewArrayExp, info)
{
  e.resolveTC(info.typeMap);
  analyseExps(e.knownDimensions, info);
  return e;
}

analyse(e@NewExp, info)
{
  e.arguments.analyse(info);
  e.resolve(info.typeMap);
  return e;
}

analyse(e@StatementExp, info)
{
  analyse(e.statement, info);
  return e;
}

analyse(c@ConstantExp, info)
{
  if (c.type != null)
    return c;
    
  TypeSymbol s = info.lookupType(c.className);
    
  if (s == null)
    bossa.util.Internal.error
      ("Base type " + c.className + " was not found in the standard library");

  TypeConstructor tc = TypeConstructor.fromTypeSymbol(s);
  if (s == null)
    bossa.util.Internal.error("Base type " + c.className + " is not valid");
  
  c.type = new mlsub.typing.Polytype
    (new mlsub.typing.MonotypeConstructor(tc, null));

  return c;
}

analyse(e@TupleExp, info)
{
  analyseExps(e.expressions, info);
  return e;
}

/****************************************************************
 * Statements
 ****************************************************************/

analyse(s@Statement, info) {}
analyse(s@null(Statement), info) {}

analyse(b@Block, info)
{
  info.begin();
  javaList(b.locals).iter(fun(Block$LocalDeclaration l)=>{
    if (l.value != null)
      l.value = analyse(l.value, info);
    info.addVar(l.left);
  });
  b.statements.iter(fun(Statement s)=>{
    if (info.getUnreachable())
      bossa.util.User.error(s, "Statement is never executed");
    analyse(s, info);
  });
  info.end();
}

analyse(s@ExpressionStmt, info)
{
  s.exp = analyse(s.exp, info);
}

analyse(l@LoopStmt, info)
{
  info.beginInner(false);
  l.whileExp = analyse(l.whileExp, info);
  analyse(l.loopBody, info);
  analyse(l.iterationStatements, info);
  info.endInner();
}

analyse(r@ReturnStmt, info)
{
  r.value = analyse(r.value, info);
  info.setUnreachable();
}

analyse(t@ThrowStmt, info)
{
  t.exn = analyse(t.exn, info);
  info.setUnreachable();
}

analyse(t@TryStmt, info)
{
  info.beginCases();
  analyse(t.body, info);

  javaList(t.catches).iter(fun(TryStmt$Catch c)=>{
    info.otherCase();
    info.begin();
    info.addVar(c.exnVar);
    c.t = c.tc.resolveToTC(info.typeMap);
    c.tc = null;
    analyse(c.body, info);
    info.end();
  });
  info.endCases();
  analyse(t.finallyBody, info);
}

// Local Variables:
// nice-xprogram: "NICEJAR=$HOME/Nice/stdlib nicec --classpath=\"$HOME/Nice/stdlib:$HOME/Nice/classes:/$HOME/Nice/src\""
// End:
