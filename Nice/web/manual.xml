<?xml version="1.0" standalone="no"?>
<!DOCTYPE book PUBLIC '-//OASIS//DTD DocBook XML V4.1.2//EN' 		     
'http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd' [ 
<!ENTITY nice "Nice">
<!ENTITY java "Java">
]>

<book>
  <bookinfo>
    <title>The Nice user's manual</title>
    <author><firstname>Daniel</firstname><surname>Bonniot</surname></author>
    <copyright><year>2002</year><holder>Daniel Bonniot</holder></copyright>
  </bookinfo>
  <preface><title>Foreword</title>
    <para>
      This manual describes the Nice programming language.
      It is currently under redaction, which means that many aspects of 
      the language are absent from it, or that some sections are mostly empty.
      During this time, it is recommended to read also the 
      <ulink url="http://nice.sf.net/language.html">Nice tutorial</ulink>, 
      which contains lots of additional information.
      Both documents currently assume some knowledge of Java, or at least
      of an object oriented language.
    </para>
  </preface>

  <chapter><title>Philosophy</title>
    <para>
      <blockquote>
	<attribution>Alan J. Perlis</attribution>
	<para>
	  A language that doesn't affect the way you think about programming, 
	  is not worth knowing.
	</para>
      </blockquote>

      The Nice programming language is a new object-oriented programming 
      language based on Java. 
      It incorporates features from functional programming, 
      and puts into practice state-of-the-art results from academic research. 
      This results in more expressivity, modularity and safety.
    </para>

    <variablelist>
      <varlistentry><term>Safety</term>
	<listitem>
	  <para>
	    Nice detects more errors during compilation than existing 
	    object-oriented languages (null pointer accesses, 
	    casts exceptions).
	    This means that programs written in Nice never throw the infamous
	    <literal>NullPointerException</literal> nor 
	    <literal>ClassCastException</literal>.
	    This aspect is developed in more details in 
	    <ulink url="http://nice.sf.net/safety.html">this article</ulink>.
	  </para>
	</listitem>
      </varlistentry>

      <varlistentry><term>Modularity</term><listitem><para>
	    In object-oriented languages, it is possible to add a new class 
	    to an existing class hierarchy. 
	    In Nice, it is also possible to add <emphasis>methods</emphasis> to 
	    existing classes without modifying their source file. 
	    This is a special case of <emphasis>multi-methods</emphasis>.
	  </para>
	</listitem>
      </varlistentry>

      <varlistentry><term>Expressivity</term><listitem><para>
	    Many repetitive programming tasks can be
	    avoided by using Nice's advanced features. 
	    Ever got bored
	    of writing tons of loops, casts, overloaded methods with default
	    values, ... ?
	  </para>
	</listitem>
      </varlistentry>
    </variablelist>

  </chapter>

  <chapter><title>Packages</title>
    <para>
    </para>
  </chapter>

  <chapter><title>Classes</title>
    <section><title>Declaring a class</title>
      <para>
      </para>
    </section>

    <section><title>Fields</title>
      <para>
	The main component of a class is the list of its fields.
	A field is a variable that is attached to each instance of
	the class. It has a type, a name, and optionally a default 
	initial value.
	The syntax for field declaration is:
	<programlisting>
	  <type>Type</type> fieldName<optional> = initialValue</optional>;
	</programlisting>
	If no default value is given, then every call to the constructor
	must specify the value for this field.
	If it is given, a call to the constructor call still override
	it with a different value, in which case the default value is
	not computed (this fact is only important if it has side effects).
      </para>
    </section>

    <section id="constructor"><title>Constructors</title>
      <para>
	There is no way to define a constructor in Nice. The reason is that
	in languages that support them, most constructors just take 
	as parameters the initial values for the fields and assign them
	to the new object. This simple but tedious task has to be done
	by the programmer for each class definition.
	In Nice, such a constructor is generated automatically by the compiler.
	It is called the automatic constructor. 
	It takes the names of the fields as named arguments, 
	and those who have an initial value are optional.
	The constructor is called <literal>new</literal> followed by
	the name of the class to create.
      </para>

      <example><title>Class definition and creations using the automatic constructor</title>
	<programlisting lang="nice">
class Car
{
  String brand;
  String model;
  int numberOfWheels = 4;
  int numberOfDrivingWheels = 2;
}

void test()
{
  Car renault5 = new Car(brand: "Renault", model: "Cinq");
  Car jeep = new Car(brand: "Jeep", model: "Some jeep", numberOfDrivingWheels: 4);
}</programlisting>
      </example>
      
      <para>
	It is required to include the names of the fields in the call
	to the constructor. 
	This is important for two reasons.
	First, it is easy to understand what the arguments represent, without looking at the
	class definition.
	Second, it does not require some arbitrary ordering of the fields
	<footnote>
	  <para>
	    A problem happens in Java when the order of the parameters 
	    of a constructor should be changed.
	    This requires modifying all the call sites, which is at best tedious
	    and error-prone, at worse impossible (when writing a library used by others).
	    When the order is changed and some caller are not modified,
	    the following happens:
	    if the exchanged parameters have incompatible types, 
	    the compilation of the caller will fail; 
	    otherwise the code might even compile and produce
	    wrong results at runtime. 
	    There is no simple way to solve this issue in Java.
	    Using names in the call to the constructor in Nice is the solution.
	  </para>
	</footnote>. Because the names of the fields are used, they can be given
	in any order.
      </para>

      <para>
	If a behaviour different than that of the automatic constructor is 
	needed, it is possible to define
	a creation <link linkend="function">function</link> that can perform 
	the task, calling the constructor to create the object and 
	initialize the fields.
	This function should by convention be called <literal>create</literal>
	suffixed by the name of the class to create.
      </para>
    </section>

    <section><title>Parametric classes</title>
      <para>
      </para>
    </section>

    <section><title>Functions and methods</title>
      <para>
      </para>
    </section>
  </chapter>

  <chapter id="function"><title>Functions</title>
    <section><title>Declaration</title>
      <para>
      </para>
    </section>

    <section id="namedParameters"><title>Named parameters</title>
      <para>
	When calling a function (or a <link linkend="method">method</link>)
	it is possible to specify the name of a parameter, followed by
	<literal>:</literal> before the value given to that parameter.
	Named parameters can be given in any order.
	This is useful when writting the call, because one does not
	need to remember the order of the arguments, but only their names.
	When reading the code, it is much easier to understand
	what each parameter is, provided the name was well chosen.
	
	<example>
	  <title>Using named parameters</title>
	  <programlisting lang="nice">
void copy(File from, File to) { ... }
...
copy(from: f1, to: f2);
copy(to: f3, from: f4);</programlisting>
	</example>
	
	Of course it is still possible to omit the names of the parameters,
	in which case the arguments must be given in the order of the 
	declaration.
      </para>
    </section>

    <section id="optionalParameters"><title>Optional parameters</title>
      <para>
	Many functions have some parameters that are used most of the time
	with the same value. In Nice, a parameter can be given a default
	value. It can then be omitted when calling the function and the
	default value is used. 

	<example>
	  <title>Using named and optional parameters</title>
	  <programlisting lang="nice">
void copy(File from, File to, int bufferSize = 1000) { ... }
...
copy(from: f1, to: f2); // with a buffer size of 1000
copy(from: f1, to: f2, bufferSize: 4000);</programlisting>
	</example>

	In the function definition, the optional parameters should be 
	listed after the required parameters. This is needed to allow 
	calls that do not name the arguments and want to use the default
	values for the optional parameters.
      </para>
    </section>
  </chapter>

  <chapter id="method"><title>Methods</title>
    <section><title>Declaring methods</title>
      <para>
      </para>
    </section>
    <section><title>Implementing methods</title>
      <para>
      </para>
    </section>
    <section><title>Optional parameters</title>
      <para>
	Methods, like functions, can have optional parameters.
	They are declared in the method declaration, using the
	<link linkend="optionalParameters">same syntax as in the case 
	  of functions</link>.
	Method implementations must still binds all parameters,
	including the optional ones, and can dispatch on them.
      </para>
    </section>
  </chapter>

  <chapter id="contracts"><title>Assertions and contracts</title>
    <section><title>Syntax</title>
      <para>
        The syntax for assertions is the same as in Java (since 1.4).
        Assertions are statements of the following form:
	<literal>assert &lt;boolean expression&gt; : &lt;error message&gt;</literal>.
      </para>
      <para>
        Preconditions are introduced with the <literal>requires</literal>
	keyword, and postconditions with the <literal>ensures</literal>
	keyword. If there are several conditions in either section,
	they must be separated by commas. 
	For convenience, an optional trailing comma is accepted.
      </para>
      <para>
        In a method returning a value, the special variable name
	<literal>result</literal> can be used to refer to the result value
	of the method in the postcondition. 
	The <literal>old</literal> to refer to values before the 
	execution of the method is not supported yet.
      </para>
      <para>
	For example, we can define the contract of the add method
	of a <literal>Buffer</literal> interface.
	It is guaranteed that <literal>isEmpty</literal> returns true
	if, and only if, <literal>size</literal> returns <literal>0</literal>.
	The <literal>add</literal> method can be called only when the buffer
	is not full. It is guarantedd to make the buffer non-empty, and
	to increase the size by one.

	<example>
	<title>Contracts</title>
	<programlisting lang="nice"><![CDATA[
interface Buffer<Elem>
{
  int size();

  boolean isFull();
  boolean isEmpty() ensures result == (size() == 0);

  void add(Elem element)
    requires
         ! isfull() : "not full"         // A comma here is optional
    ensures
         !isEmpty() : "not empty",       // Note the comma
         size() == old(size()) + 1 : "count inc";
}]]></programlisting>
      </example>
      
      </para>
    </section>

    <section><title>Enabling assertions and contract checking</title>
      <para>
        By default, assertions and contracts are not used at runtime.
	They are discarded by the just-in-time compiler, and should
	cause no slow-down.
	They can be turned on when starting the JVM.
      </para>

      <section><title>JDK 1.4 and later</title>
        <para>
	  The mechanism is the same as for Java assertions. 
	  Checking can be enabled at runtime with java -ea ....
	</para>
      </section>

      <section><title>JDK 1.1, 1.2 and 1.3</title>
        <para>
          Contrarily to Java, Nice produces programs with assertions that can 
	  be run on earlier JDKs. Therefore there is no problem to distribute 
	  Nice programs using assertions anc contracts. Since java will not 
	  know the <literal>-ea</literal> command line option, they are 
	  disabled by default. You can enable them with 
	  <literal>java -Dassertions=true ...</literal>.
	</para>
      </section>
    </section>

  </chapter>

  <chapter><title>Statements</title>
    <section id="localFunctions"><title>Local functions</title>
      <para>
	Local functions are similar to toplevel functions, 
        except that they are defined inside another function or method,
        and therefore only usable in that scope.	
      </para>

      <example><title>Local function</title>
	<programlisting lang="nice">
Window createMyWindow()
{
  Window w = new Window();
  
  void addMyButton(String text)
  {
    w.addButton(new Button(text));
  }

  addMyButton("One");
  addMyButton("Two");
  addMyButton("Three");
}</programlisting>
      </example>

    </section>

  </chapter>

  <chapter><title>Expressions</title>
    <section><title>Tuples</title>
      <para>
       A tuple is a groupment of several values in a single expression.
       For instance, <literal>("Hello", 2*3, x.toString())</literal> 
       is a tuple whose elements are the string <literal>"Hello"</literal>,
       the number <literal>6</literal> and the string representation of 
       <literal>x</literal>. 
       The type of a tuple is a <emphasis>tuple type</emphasis>, 
       whose elements are the types of the corresponding values.
       The type of our example tuple is 
       <literal>(String, int, String)</literal>. 
      </para>

      <para>
       A tuple can be of any length. In english, a tuple of two elements
       is called a couple. For an arbitrary number n, a tuple of n
       elements is called a n-tuple.
      </para>

      <para>
       Tuple types are covariant, so a couple of <literal>int</literal>s 
       can be used where a couple of <literal>long</literal>s is expected.
      </para>

      <para>
       A funny feature is that swapping two variables can be done without a 
       temporary variable, using tuples: <literal>(x, y) = (y, x)</literal>.
       An important use of tuples is to allow a function or a method 
       to return several values. Example <xref linkend="tupleEx" /> defines
       and uses the function <literal>minMax</literal>, which takes 
       two integers, and returns the smallest first, the biggest second.
      </para>

      <example id="tupleEx">
	<title>Function returning several values using a tuple</title>
	<programlisting lang="nice"><![CDATA[
(int, int) minMax(int x, int y) = x < y ? (x, y) : (y, x);

void printTuple((int, int) tuple)
{
  /** Declare two local variables, and assign to each the corresponding value
      in the tuple.
  */
  (int x, int y) = tuple;

  println("(" + x + ", " + y + ")");
}

void main(String[] args)
{
  printTuple(minMax(14, 17));
  printTuple(minMax(42, 41));
}
}]]></programlisting>
      </example>

    </section>

    <section><title>Anonymous functions</title>
      <para>
      </para>
    </section>

    <section id="conversion"><title>Conversion between primitive types</title>
      <para>
	The primitive types are, from the largest to the smallest:
	<literal>double, float, long, int, short, byte</literal>, 
	and <literal>char</literal> which is smaller than 
	<literal>int</literal> but incomparable with <literal>short</literal>.
	Conversion from a smaller to a larger type is automatic.
	Conversion from a larger to a smaller type must be done explicitely,
	since they can lose information about the magnitude of the value.
      </para>
      <para>
	The explicit conversion is done by calling a special function, 
	whose name is the target type. For instance, here is code to read
	characters from a <literal>Reader</literal>, whose 
	<literal>read</literal> method returns an <literal>int</literal> 
	(<literal>-1</literal> meaning that the end of stream has been 
	reached):

	<example><title>Converting a value of a primitive type</title>
	<programlisting lang="nice">
BufferedReader r = new BufferedReader(new InputStreamReader(System.in));

int v;
while ((v = r.read()) != -1) {
  char c = char(v);
  ... // Do something the the character.
}</programlisting>
      </example>

      </para>
    </section>
  </chapter>

  <chapter><title>Interfacing with Java</title>
    <section><title>Using Java from Nice</title>
      <para>
        The Java libraries are automatically imported as necessary. 
	Therefore it is straightforward	to use existing Java code
	in Nice programs.
      </para>

      <para>
	This section lists advanced features related to the use of Java code
	in Nice.
      </para>

      <section id="importJava"><title>Importing packages</title>
	<para>
	  When Java classes of some package are used frequently,
	  it is possible to make the package part of their name implicit.
	  For instance, after a declaration
	  <literal>import java.io.*;</literal> it is possible
	  to refer to class <literal>java.io.File</literal>
	  with the short name <literal>File</literal>.
	</para>

	<para>
	  Classes defined in the current package always have priority
	  over imported packages. If a short name is used that refers
	  to two classes from imported packages, the compiler
	  will report an ambiguity, and the fully qualified name must be used.
	</para>
      </section>

      <section id="optionTypesJava"><title>Option types</title>
	<para>
	  Nice's advanced type system makes the distinction between normal 
	  (e.g. <literal>String</literal>) and option
	  (e.g. <literal>?String</literal>) types, which allows to 
	  prevent <literal>NullPointerExceptions</literal>
	  (see <link linkend="optionTypes">option types</link>).
	  This poses a problem when using 
	  existing Java libraries. If my Nice program calls a Java function
	  that returns a <literal>String</literal> (the Java type), 
	  does it mean <literal>String</literal> or 
	  <literal>?String</literal> in Nice? 
	  Since Java allows the value to be <literal>null</literal>, 
	  the Nice compiler 
	  currently suposes it's <literal>?String</literal> (it can only be 
	  sure about primitive types like <literal>int</literal>).
	</para>

	<programlisting lang="java">
// Java code
public class MyJavaClass {
  public String getName() {
    return "foo";
  }
}	</programlisting>

	<para>
          In Nice, if <literal>myJavaClass</literal> is a variable of type 
	  <literal>MyJavaClass</literal>, then 
	  <literal>myJavaClass.getName()</literal> has type 
	  <literal>?String</literal>.
	</para>

	<para>
	  If the Java code might indeed return <literal>null</literal>, 
	  or you are not sure, this is all good. To use the value you will 
	  have to test it against <literal>null</literal>. However there are 
	  many cases where you know the value cannot be 
	  <literal>null</literal>, for instance if this fact is specified in 
	  the Javadoc comment of the method. In that cases there are currently 
	  two possibilities. The first is to use the <literal>notNull</literal>
	  function. It tells the compiler that you know the value is not 
	  <literal>null</literal>. At runtime, it will throw a 
	  <literal>NullPointerException</literal> if this was not the case. 
	  So in our example <literal>notNull(myJavaClass.getName())</literal>
	  has type <literal>String</literal>. This solution is simple, but can 
	  be annoying if you call the same method many times, or because it 
	  makes your code less readable.
	</para>

	<para>
	  The second solution is to tell once and for all the compiler the 
	  precise type of the method (this is also useful for methods with 
	  parametric types):
	</para>

	<programlisting lang="nice">
String getName(MyJavaClass) = native String MyJavaClass.getName();</programlisting>

	<para>
          The Nice part (on the left of the <literal>=</literal> character) 
	  is the header of a function definition. Note that return type is 
	  <literal>String</literal> (without the optional type marker 
	  <literal>?</literal>). On the other hand, the right part says that 
	  the function is already defined in class 
	  <literal>MyJavaClass</literal>, with name <literal>getName</literal>,
	  the one that takes no argument and returns a 
	  <literal>String</literal>. With this declaration, 
	  <literal>myJavaClass.getName()</literal> has type 
	  <literal>String</literal>.
	</para>
      </section>
    </section>

    <section><title>Using Nice from Java</title>
      <para>
        It is possible to use libraries developed in Nice in a 
	Java program.
	Before anything, make sure that the classes generated by nicec
	can be found on your classpath when you compile the Java program
	with javac.
      </para>

      <section><title>Calling a function</title>
	<para>
	  You can call a <link linkend="function">function</link> 
	  <literal>f</literal>
	  defined in a nice package <literal>pkg</literal> 
	  by naming it <literal>pkg.fun.f</literal> in the Java program.
	</para>
      </section>

      <section><title>Calling a method</title>
	<para>
	  You can call a <link linkend="method">method</link>
	   <literal>m</literal>
	  defined in a nice package <literal>pkg</literal> 
	  by naming it <literal>pkg.dispatch.m</literal> in the Java program.
	  It does not matter in what package(s) <literal>m</literal> 
	  is implemented: 
	  <literal>pkg</literal> must simply be the package where the method 
	  was declared.
	</para>
      </section>

      <section id="constructorFromJava"><title>Calling a constructor</title>
	<para>
	To instantiate in Java a class defined in Nice, do as usual:
	call its constructor, using the <literal>new</literal> keyword.
	Nice classes have one <link linkend="constructor">automatically 
	generated constructor</link>, 
	with one parameter for each field of the class, 
	including those inherited from Nice super-classes.
	</para>
      </section>

      <section><title>Complete example</title>
      <para>
      <example><title>Using Nice from Java</title>
	<para>
	Let's see an example that illustrates all these features.
	Suppose you Nice library looks like this:
	<programlisting lang="nice">
package my.nice.pkg;

class Person
{
  String name;

  // A method:
  String display();
  display() = "Person: " + name;
}

class Worker extends Person
{
  int salary;

  display() = "Worker: " + name + " salary: " + salary;

  // A function:
  boolean isRich() = salary > 500;
}

	</programlisting>

	Then your Java program can create new persons and workers:
	<programlisting lang="java">
package main.java.pkg;

import my.nice.pkg.*;

public class Main
{
  public static void main(String[] args)
  {
    Person p = new Person("John");
    Worker w = new Worker("Julia", 1000);

    println(my.nice.pkg.dispatch.display(p));
    println(my.nice.pkg.dispatch.display(w));
    if (my.nice.pkg.fun.isRich(w))
      println("A well paid worker!");
  }
}
        </programlisting>
	</para>
      </example>
      </para></section>

      <section><title>Optional parameters</title>
	<para>
	  Nice allows function and method parameters to be 
	  <link linkend="optionalParameters">optional</link>.
	  Since this feature is not available in Java, you have to 
	  provide the value of all parameters, regardless of their
	  optionality.
	  The same applies for class fields with initializers:
	  they are ignored in the Java program, and must be given a value
	  in the call to the constructor.
        </para>
      </section>

      <section><title>Other aspects</title>
	<para>
	Fields of Nice classes are accessed normally from Java programs.
	It is possible to declare a Java subclass of a Java class.
	The constructor will need to call the 
	<link linkend="constructorFromJava">parent constructor</link>.
	It is not possible to override a Nice multi-methods in a Java
	program.
	</para>
      </section>

    </section>
  </chapter>

  <chapter><title>Types</title>
    <para>
    </para>

    <section id="optionTypes"><title>Option types</title>
      <para>
        See 
	<ulink url="http://nice.sourceforge.net/cgi-bin/view/Doc/OptionType">
	the Wiki site page about option types</ulink>.
      </para>
      </section>

  </chapter>

</book>

<!--
  Local Variables:
  sgml-validate-command: "xmllint -noout -valid"
  End:
 -->
