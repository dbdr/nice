/**************************************************************************/
/*                                N I C E                                 */
/*             A high-level object-oriented research language             */
/*                        (c) Daniel Bonniot 2002                         */
/*                                                                        */
/*  This program is free software; you can redistribute it and/or modify  */
/*  it under the terms of the GNU General Public License as published by  */
/*  the Free Software Foundation; either version 2 of the License, or     */
/*  (at your option) any later version.                                   */
/*                                                                        */
/**************************************************************************/

/**
    JavaCC parser for Nice.
*/

options {
  JAVA_UNICODE_ESCAPE = true;
  DEBUG_LOOKAHEAD = false;
  DEBUG_PARSER = false;
  DEBUG_TOKEN_MANAGER = false;
  STATIC = false;
}

PARSER_BEGIN(Parser)

package bossa.parser;

import java.io.*;
import java.util.*;

import bossa.util.*;
import bossa.syntax.*;

import mlsub.typing.TypeSymbol;
import mlsub.typing.TypeConstructor;
import mlsub.typing.MonotypeVar;

public class Parser
{
  private static Expression symb(String name, Token t, boolean quoted)
  {
    return bossa.syntax.dispatch.createIdentExp(new LocatedString(name, makeLocation(t),quoted));
  }
  private static Expression symb(String name, Token t)
  {
    return symb(name,t,true);
  }
  private static Expression symb(Token t)
  {
    return symb(t.image,t);
  }
  private static Expression symb(String name, Location loc)
  {
    return bossa.syntax.dispatch.createIdentExp(new LocatedString(name, loc));
  }

  private void parseException(String message) throws ParseException
  {
    ParseException ex = new ParseException(message);
    ex.currentToken = getToken(0);
    throw ex;
  }

  static Location makeLocation(Token t)
  {
    return Location.make(t.beginLine, t.beginColumn, t.endLine, t.endColumn);
  }

  private static Location makeLocation(Token start, Token end)
  {
    return Location.make(start.beginLine, start.beginColumn, end.endLine, end.endColumn);
  }

  private static boolean isDocStringToken(Token t)
  {
    return t.specialToken != null && t.specialToken.kind == FORMAL_COMMENT;
  }

}
PARSER_END(Parser)

/***********************************************************************
 * Comments
 ***********************************************************************/

// picked from JavaCC-1.1.jj grammar out of JavaCC examples

/* WHITE SPACE */

SKIP : { " " | "\t" | "\n" | "\r" | "\f" }

/* COMMENTS */
TOKEN_MGR_DECLS : { int nestingLevel = 0; }

MORE :
{
  <"/**" ~["/"]> { input_stream.backup(1); } : IN_FORMAL_COMMENT
|
  "/*" {nestingLevel++; }: IN_MULTI_LINE_COMMENT
}

SPECIAL_TOKEN : 
{ <SINGLE_LINE_COMMENT: "//" (~["\n", "\r"])* ("\n" | "\r" | "\r\n" )? > }

<IN_FORMAL_COMMENT>
SPECIAL_TOKEN :
{
  <FORMAL_COMMENT: "*/" > : DEFAULT
}

<IN_MULTI_LINE_COMMENT>
MORE :
{
  "/*" {nestingLevel++; }: IN_MULTI_LINE_COMMENT
}

<IN_MULTI_LINE_COMMENT>
SKIP :
{
 "*/" { if (--nestingLevel == 0) SwitchTo(DEFAULT); } 
}

<IN_FORMAL_COMMENT,IN_MULTI_LINE_COMMENT>
MORE :
{
  < ~[] >
}

/***********************************************************************
 * Reserved tokens
 ***********************************************************************/

TOKEN: /* Separators, Delimiters */
{
  < LPAR:       "("   >
| < RPAR:       ")"   >
| < LBRK:       "["   >
| < RBRK:       "]"   >
| < LBRACE:     "{"   >
| < RBRACE:     "}"   >
| < DOT:        "."   >
| < COLON:      ":"   >
| < COMMA:      ","   >
| < SEMI:       ";"   >
| < MAPSTO:     "->"  >
| < COND:       "?"   >
| < ANY:        "_"   >
| < BACKSLASH:  "\\"  >      
}

TOKEN: /* Operators */
{
  < EQ:      "="   >
| < PLUS:    "+"   >
| < MINUS:   "-"   >
| < RANGE:   ".."  >
| < POWER:   "**"  >
| < MULT:    "*"   >
| < SLASH:   "/"   >
| < NEQ:     "!="  >
| < MOD:     "%"   >
| < LNOT:    "!"   >
| < BAND:    "&"   >
| < BOR:     "|"   >
| < BXOR:    "^"   >
| < BNOT:    "~"   >
| < LEQ:     "<="  >
| < GEQ:     ">="  >
| < EQEQ:    "=="  >
| < SUB:     "<:"  >
| < LT:      "<"   >
| < GT:      ">"   >
| < LAND:    "&&"  >
| < LOR:     "||"  >
//| < LSHIFT:  "<<"  >
// RSHIFT is not a token: operator >> is made of two consecutive tokens ">"
}

TOKEN: /* Keywords */
{
  < CLASS:      "class"		>
| < INTERFACE:  "interface"	>
| < IMPLEMENTS: "implements"	>
| < EXTENDS:    "extends"    	>
| < ENUM:       "enum"    	>
| < OVERRIDE:   "override"      >

// Packages
| < IMPORT:     "import"     	>
| < PACKAGE:    "package"    	>

| < AT:         "@"          	>
| < EXACTLY_AT: "#"          	>

// Assertions
| < ASSERT:     "assert"     	>
| < REQUIRE:    "requires"     	>
| < ENSURE:     "ensures"     	>

// Expressions
| < FOR:        "for"        	>
| < IF:         "if"         	>
| < ELSE:       "else"       	>
| < WHILE:      "while"      	>
| < DO:		"do"		>
| < TRUE:       "true"       	>
| < FALSE:      "false"      	>
| < ALIKE:      "alike"      	> /* Nice specific */
| < UNKNOWN:	"unknown"       > /* Nice specific */
//| < THIS:       "this"       	>
| < SUPER:      "super"         >
| < INSTANCEOF: "instanceof" 	>
| < SYNCHRONIZED: "synchronized">
| < NEW:        "new"        	>
| < NULL:	"null"		>

| < BREAK:	"break"		>
| < CONTINUE:	"continue"	>

// switch is an unused keyword to improve error message
| < SWITCH:	"switch"	>

// Statements
| < RETURN:     "return"     	>
| < VARIABLE:   "var"   	> /* Nice specific */
| < LET:   	"let"   	> /* Nice specific */

// modifiers
| < PUBLIC:     "public"     	>
| < PRIVATE:    "private"    	>
| < PUBLICR:    "public-read" 	>
| < PRIVATEW:   "private-write"	>
| < PROTECTED:  "protected"  	>
| < STATIC:     "static"     	>
| < FINAL:      "final"      	>
| < TRANSIENT:  "transient"  	>
| < VOLATILE:   "volatile"   	>
| < CONST:      "const"      	>
| < NATIVE:     "native"     	> /* Nice specific */
| < INLINE:     "inline"        > /* Nice specific */
| < ABSTRACT:   "abstract"   	>

// exceptions
| < THROW:	"throw"		>
| < TRY:	"try" 		>
| < CATCH:	"catch" 	>
| < FINALLY:    "finally"    	>
}


/***********************************************************************
 * Literals
 ***********************************************************************/
TOKEN: /* Different kinds of digits */
{
  < #DIGIT:  ["0"-"9"] >                     // decimal
| < #XDIGIT: ["0"-"9", "a"-"f", "A"-"F"] >   // hexadecimal
| < #ODIGIT: ["0"-"7"] >		     // octal
| < #BDIGIT: ["0", "1"] >		     // binary
}


TOKEN :
{
  < INTEGER_LITERAL:
        <DECIMAL_LITERAL> (["l","L"])?
      | <HEX_LITERAL> (["l","L"])?
      | <OCTAL_LITERAL> (["l","L"])?
  >
|
  < #DECIMAL_LITERAL: ["1"-"9"] (["0"-"9", "_"])* >
|
  < #HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F","_"])+ >
|
  < #OCTAL_LITERAL: "0" (["0"-"7","_"])* >
}

TOKEN: /* Floating point literals */
{
  < FLOATING_POINT_LITERAL:
        ["0"-"9"] (["0"-"9", "_"])* "." (["0"-"9", "_"])+ (<EXPONENT>)? (["f","F","d","D"])?
      | "." ["0"-"9"] (["0"-"9", "_"])* (<EXPONENT>)? (["f","F","d","D"])?
      | ["0"-"9"] (["0"-"9", "_"])* <EXPONENT> (["f","F","d","D"])?
      | ["0"-"9"] (["0"-"9", "_"])* (<EXPONENT>)? ["f","F","d","D"]
  >
|
  < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9", "_"])+ >
}

TOKEN: /* Char literals */
{
  < CHARACTER_LITERAL:
      "'"
      (   (~["'","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )
      "'"
  >
}

TOKEN: /* String literals */
{
  < MULTILINESTRING:
      "\"" "\"" "\""
      (   (~["\"","\\"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
        | "\"" ~["\""]
      )*
      "\"" "\"" "\""
  >
|
  < LSTRING:
      "\""
      (   (~["\"","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )*
      "\""
  >
|
  < BACKQUOTEDSTRING:
      "`"
      (   (~["`","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )*
      "`"
  >
}

/***********************************************************************
 * Identifiers
 ***********************************************************************/
// identifiers are the same as in Java, except that:
// 2. the character ' is allowed
// XXX: conform to Java
TOKEN:
{
  < IDENT: <IDENT_START> (<IDENT_PART>)* >
| < #IDENT_PART:       (<IDENT_START> | <IDENT_DIGIT> | "'") >
| < #IDENT_START:
     [
      "\u0024",
      "\u0041"-"\u005a",
      "\u005f", 
      "\u0061"-"\u007a",
      "\u00c0"-"\u00d6",
      "\u00d8"-"\u00f6",
      "\u00f8"-"\u00ff",
      "\u0100"-"\u1fff",
      "\u3040"-"\u318f",
      "\u3300"-"\u337f",
      "\u3400"-"\u3d2d",
      "\u4e00"-"\u9fff",
      "\uf900"-"\ufaff"
     ]
  >
| < #IDENT_DIGIT:
    [
     "\u0030"-"\u0039",
     "\u0660"-"\u0669",
     "\u06f0"-"\u06f9",
     "\u0966"-"\u096f",
     "\u09e6"-"\u09ef",
     "\u0a66"-"\u0a6f",
     "\u0ae6"-"\u0aef",
     "\u0b66"-"\u0b6f",
     "\u0be7"-"\u0bef",
     "\u0c66"-"\u0c6f",
     "\u0ce6"-"\u0cef",
     "\u0d66"-"\u0d6f",
     "\u0e50"-"\u0e59",
     "\u0ed0"-"\u0ed9",
     "\u1040"-"\u1049"
    ]
  >
}
 
/*
 * Illegal tokens
 */
TOKEN:
{
  < ILLEGAL_TOKEN: (~[]) >
}

/***********************************************************************/
/*                          Grammar                                    */
/***********************************************************************/

String rawString():
{ Token t; }
{
  t=<LSTRING>
  { return t.image.substring(1, t.image.length() - 1); }
}

LocatedString ident():
{ Token t; }
{
  t=<IDENT> 
  { return new LocatedString(t.image, makeLocation(t)); }
}

String unlocIdent():
{ Token t; }
{
  t=<IDENT> 
  { return t.image; }
}

LocatedString identOrBackquoted():
{
  LocatedString res;
  Token name;
}
{
  (
   name=<BACKQUOTEDSTRING>
   { res = new LocatedString(name.image.substring(1, name.image.length() - 1),
			     makeLocation(name), true); }
  |
   res = ident()
  )
  { return res; }
}

/* This allows idents as well as nice specific keywords,
   which is useful to specify native java package, class or method names
*/
Token doted_string_component():
{ Token t; }
{
  ( t = <IDENT> 
  | t = "alike"
  | t = "var"
  | t = "inline" 
  | t = "native" 
  )
  { return t; }
}

LocatedString doted_string():
{
  Token start, t;
  StringBuffer image;
}
{
  start = <IDENT>
  { t = start; image = new StringBuffer(start.image); }

  ( LOOKAHEAD(2) // needed to distinguish with ".class"
    "." t=doted_string_component() 
    { image.append(".").append(t.image); } 
  )*

  { return new LocatedString(image.toString(), makeLocation(start, t)); }
}

/** Contains at least one "." */
LocatedString fullyQualifiedName():
{
  Token start, t;
  StringBuffer image;
}
{
  start = <IDENT>
  { t = start; image = new StringBuffer(t.image); }
  ( LOOKAHEAD(2) // needed to distinguish with ".class"
    "." t=doted_string_component() 
    { image.append(".").append(t.image); } 
  )+
  { return new LocatedString(image.toString(), makeLocation(start, t)); }
}

LocatedString doted_array_string():
{ LocatedString res; }
{
  res=doted_string()
  ( "[]" { res.prepend("["); } )*
  { return res; }
}

Collection strings():
{
  Collection res=new ArrayList();
  LocatedString s;
}
{
  s=ident() { res.add(s); }
  ( "," s=ident() { res.add(s); } )*
  { return res; }
}

LocatedString floatingLiteral():
{ Token t; }
{
  t = <FLOATING_POINT_LITERAL> 
  { return new LocatedString(t.image, makeLocation(t)); }
}

LocatedString integerLiteral():
{ Token t; }
{
  t = <INTEGER_LITERAL> 
  { return new LocatedString(t.image, makeLocation(t)); }
}

TypeConstantExp typeExpression():
{ LocatedString name; }
{
  name = doted_array_string()
  { return bossa.syntax.dispatch.createTypeConstantExp(name); }
}

/***********************************************************************/
/*                          Type Symbols                               */
/***********************************************************************/

TypeIdent typeConstructorIdent():
{ LocatedString name; }
{
  name=doted_string()
  { return new TypeIdent(name); }
}

TypeConstructor typeConstructor():
{ String name; }
{
  name=unlocIdent()
  { return new TypeConstructor(name); }
}

TypeIdent typeIdent():
{ LocatedString name; }
{
  name=doted_string()
  { return new TypeIdent(name); }
}

MonoSymbol monoSymbol():
{
  LocatedString name;
  Monotype type;
}
{
  type=monotype()
  name=ident()
  { return new MonoSymbol(name,type); }
}

/***********************************************************************/
/*                          Constraints                                */
/***********************************************************************/

TypeSymbol binder(Collection atomics):
{
  TypeIdent first;
  TypeConstructor second;
  MonotypeVar id;
  Token t;
}
{
  LOOKAHEAD( typeIdent() typeConstructor() )
  first=typeIdent() 
  second=typeConstructor()
  { 
    atomics.add(new TypeConstructorLeqCst(second,first)); 
    return second; 
  }
| { boolean sure = false; }
  [ "!" { sure = true; } ]
  id=monotypeVar()
  { 
    if (sure)
      atomics.add(AtomicConstraint.sureTypeVar(id));
    return id; 
  }
}

List binders(Collection atomics):
{
    List res=new ArrayList();
    TypeSymbol t;
}
{
    t=binder(atomics) { res.add(t); }
    ( "," t=binder(atomics) { res.add(t); } )*
    { return res; }
}

void atomicConstraint(List list):
{
  Monotype m1,m2;  
  TypeIdent t,i;
}
{
(  LOOKAHEAD(2)
   m1=monotype() "<:" m2=monotype()
   { list.add(new MonotypeLeqCst(m1,m2)); }
   ( "<:" { m1 = m2; }
     m2 = monotype()
     { list.add(new MonotypeLeqCst(m1,m2)); }
   )*
|
   t=typeConstructorIdent() ":" i=typeIdent()
   { list.add(new ImplementsCst(t,i)); }
)
}

void atomics(List res):
{}
{
  atomicConstraint(res)  ( "," atomicConstraint(res) )*
}

Constraint constraint():
{}
{
  [ { List b=null, atoms=new ArrayList(); }
    "<" b=binders(atoms) [ "|" atomics(atoms) ] ">" 
    { return new Constraint(b,atoms); }
  ]
  { return Constraint.True; }
}

/***********************************************************************/
/*                          Types                                      */
/***********************************************************************/

//Monotypes

MonotypeVar monotypeVar():
{ String name; }
{
  name=unlocIdent()
  { return new MonotypeVar(name); }
}

Monotype monotypeConstructor():
{
    TypeIdent t;
    List p=null;
    Token first,last;
}
{
  { first=getToken(1); }
  // monotypeConstructors with no type parameters (and no "<" ">")
  // are parsed as MonotypeVars, not here.
  // This is fixed during scoping.

    t=typeConstructorIdent() 
    "<" [  p=monotypes() ] ">"
    { if(p==null) p=new ArrayList(0);
      last=getToken(0);

      return bossa.syntax.fun.createMonotypeConstructor(t,bossa.syntax.dispatch.createTypeParameters(p),
				     makeLocation(first, last)); 
    }
}

Monotype funOrTupleMonotype():
{
  Monotype codomain;
  List domain = null;
  boolean maybe = false;
  Token start,end;
}
{
  start="(" [ domain = monotypes() ] end=")" 
  [ LOOKAHEAD("?"|"->")
  [ "?" { maybe = true; } ]
  "->"
  codomain = monotype()
  { 
    FunType res = bossa.syntax.dispatch.createFunType(domain, codomain); 
    res.nullness = maybe ? res.maybe : res.absent;
    return res; 
  }
  ]
  { 
    if (domain != null && domain.size() == 1)
      // (T) is T, the parenthesis helping to resolve ambiguities
      {
        return (Monotype) domain.get(0);
      }
    Monotype res;
    if (domain != null)
      res = new TupleType(domain, makeLocation(start, end)); 
    else
      res = new TypeIdent(new LocatedString("void",makeLocation(start, end)));
 
    res.nullness = res.absent;
    return res;
  }
}

Monotype monotype():
{ Monotype res; }
{
  res = simpleMonotype()
  res = arrayMonotype(res)

[ LOOKAHEAD(1)
  { boolean maybe = false; }
  [ "?" { maybe = true; } ]
  "->"
  { Monotype codomain; } codomain = monotype()
  { 
    Monotype[] domain;
    // Make void->... mean the same as ()->...
    if (res.isVoid())
      domain = null;
    else
      domain = new Monotype[]{ res };
    res = bossa.syntax.dispatch.createFunType_(domain, codomain); 
    res.nullness = maybe ? res.maybe : res.absent; }
]
  { return res; }
}

/**
   Parse an array type.
   Uses a recursive call to reverse the order of arrays.
   This is necessary since
     T[?][]
   is equivalent to
     ?Array<Array<T>>
   not
     Array<?Array<T>>
*/
Monotype arrayMonotype(Monotype res):
{ Token end; }
{
[ LOOKAHEAD(1)
  { boolean maybe = false; }
  ( end="[]" | end="[?]" { maybe = true; } )
  // parse recursively until then end of array qualifiers
  res = arrayMonotype(res)
  { 
    List tp = new LinkedList();
    tp.add(res);
    Location loc = res.location();
    res = bossa.syntax.fun.createMonotypeConstructor
      (new TypeIdent(new LocatedString("nice.lang.Array", loc)),
       bossa.syntax.dispatch.createTypeParameters(tp),
       loc);
    res.nullness = maybe ? res.maybe : res.absent;
  }
]
  { return res; }
}

Monotype simpleMonotype():
{
  Monotype res;
  List p=null;
  Token start, end;
  boolean maybe = false, sure = false;
}
{
  [
    // Consume "?" only if it does not appear by itself
    LOOKAHEAD( "?", { getToken(2).kind != COMMA && getToken(2).kind != GT})
    "?" { maybe = true; }
  | "!" { sure = true; }
  ]

  (
  res=funOrTupleMonotype()
|
  start="alike" [ "<" p=monotypes() ">" ]
  { res=bossa.syntax.dispatch.createAlike(p, makeLocation(start)); }
  { res.nullness = res.absent; }
|
  LOOKAHEAD(monotypeConstructor())
  res=monotypeConstructor()
  { res.nullness = res.absent; }
| 
  res=typeIdent() 
  { res.nullness = res.absent; }
  )
  { 
    if ((maybe || sure) && 
        (res.nullness != res.absent))
      throw bossa.util.User.error
        (res, "Nullness is specified in two ways for " + res);
    if (maybe)
      res.nullness = res.maybe;
    else if (sure)
      res.nullness = res.sure;
  }
  { return res; }
|
  ("unknown"  | "?")
  { return Monotype.create(mlsub.typing.UnknownMonotype.instance); }
}

List monotypes():
{
  List res=new ArrayList();
  Monotype t;
}
{
  t=monotype() { res.add(t); }
  ( "," t=monotype() { res.add(t); } )*
  { return res; }
}

/***********************************************************************/
/*                          Classes                                    */
/***********************************************************************/

Expression ParameterTuplePart(List statements, List monotypes):
{ LocatedString id; Monotype type; }
{
( 
  LOOKAHEAD( monotype() ident() )
  type=monotype()  id=ident()
  { monotypes.add(type);
    statements.add(bossa.syntax.dispatch.createLocalVariable(id, type, false, null)); 
    return bossa.syntax.dispatch.createIdentExp(id); }
| { Token first,last; }
  first="(" 
  { List parts = new LinkedList(); Expression part;
    List types = new LinkedList(); }
  part = ParameterTuplePart(statements, types) { parts.add(part); }
  ( "," part = ParameterTuplePart(statements, types) { parts.add(part); } )+
  last=")"
  { Monotype t = new TupleType(types, makeLocation(first, last));
    t.nullness = Monotype.absent;
    monotypes.add(t); 
    return new TupleExp(parts); }
)
}

FormalParameters.Parameter formalParameter(List statements):
{
  Monotype t;
  LocatedString id = null;
  Expression val = null;
}
{
(
  LOOKAHEAD(monotype())
  t=monotype() [ id=ident() [ "=" val=Expression() ]]
  { return FormalParameters.createParameter(t, id ,val); }
|
  { Token first,last;
  List parts = new LinkedList();
  Expression part;
  List types = new LinkedList();
  LocatedString ident; }
  first="("
  part = ParameterTuplePart(statements, types) { parts.add(part); }
  ( "," part = ParameterTuplePart(statements, types) { parts.add(part); } )+
  last=")"
  [ id=ident() [ "=" val=Expression() ] ]
  { if (id == null) {
      ident = new LocatedString("tuple_arg_" + first.beginLine + "_" + first.beginColumn, 
				makeLocation(first, last));
    } else { ident = id; }
    Expression exp = bossa.syntax.dispatch.createAssignExp(new TupleExp(parts),bossa.syntax.dispatch.createIdentExp(ident));
    exp.setLocation(makeLocation(first,last));
    statements.add(bossa.syntax.dispatch.createExpressionStmt(exp));
    t = new TupleType(types, makeLocation(first, last));
    t.nullness = Monotype.absent;

    return FormalParameters.createParameter(t, ident ,val);
  }
)  
}

FormalParameters formalParameters(boolean leaveRoomForThis, List statements):
{
  List params = new LinkedList();
  FormalParameters.Parameter p;
}
{
  { if (leaveRoomForThis) params.add(null); }
  [
    p = formalParameter(statements) { params.add(p); }
    ( "," p = formalParameter(statements) { params.add(p); } )*
  ]
  { return new FormalParameters(params.isEmpty() ? null : params ); }
}

Definition internalMethodOrFunction(MethodContainer c, boolean isOverride):
{
  LocatedString name;
  FormalParameters parameters;
  Constraint cst;
  Monotype returnType;
  Statement body = null;
  Contract contract;
  List statements = new LinkedList();
}
{
  cst=constraint()
  returnType=monotype()
  name=identOrBackquoted()
  "(" parameters = formalParameters(true, statements) ")"
  contract = contract()
  ( ";" | body = code() {statements.add(body);} )
  
  { return bossa.syntax.dispatch.createMemberMethod(c, name, cst, returnType, parameters, 
                             body != null ? bossa.syntax.dispatch.createBlock(statements) : null,
                             contract, isOverride); }
}

MonotypeConstructor superClass():
{ TypeIdent name; List params = null; }
{
  name=typeIdent()
    // ignore type parameters
    // they should be checked
    [ "<" params = monotypes() ">" ]
  { return bossa.syntax.fun.createMonotypeConstructor(name, params == null ? null : bossa.syntax.dispatch.createTypeParameters(params), name.location()); }
}

List interfaces():
{
  List res=new LinkedList();
  MonotypeConstructor name;
}
{
        name=superClass() { res.add(name); }
  ( "," name=superClass() { res.add(name); } )*
  { return res; }
}

void fieldLookahead():
{}
{
  ( "override" 
  |
    ( "public-read" [ "private-write" ]
    | "private-write"
    | ( ("public" | "private" | {} ) 
        [ "final" ]
      )
    ) 
    [ "transient" ]
    [ "volatile" ]
  )
  monoSymbol() 
  ( "=" | ";" )
}

void getField(CNiceClass c, boolean storeDocString):
{
  MonoSymbol field;
  boolean isFinal=false, isTransient = false, isVolatile = false;
  boolean isOverride = false;
  Expression value = null;
  Token t = getToken(1);
  String docString = null;
}
{
 {
   if (storeDocString && isDocStringToken(t))
     docString = t.specialToken.image;
 }
 (
   "override" { isOverride = true; }
 |
  ( 
    "public-read" [ "private-write" ]
  | "private-write"
  | ( ("public" | "private" | {} ) 
      [ "final" { isFinal=true; } ]
    )
  ) 
  [ "transient" { isTransient = true; } ]
  [ "volatile"  { isVolatile  = true; } ]
 )
  field=monoSymbol() 
  [ "=" value=Expression() ]
  ";" 
  { 
    if (isOverride)
      c.addOverride(field, value);
    else
      c.addField(field, value, isFinal, isTransient, isVolatile, docString);
  }
}

// The constraint prefixing the class keyword is optional
// It is useful for complex constraints
TypeDefinition typeDefinition(Constraint cst, List definitions, boolean storeDocString):
{
  TypeDefinition res;
  LocatedString name;
  MethodContainer.Constraint parameters = null;
  List l;
  List typeParametersVariances = new ArrayList(0);
  List imp = null, abs = null;
}
{

(
  "interface"
  name=ident() 
  [ parameters=classTypeParameters(cst, typeParametersVariances) ]
  { List ext = null; }
  [ "extends" ext = interfaces() ]
  [ "implements" imp=interfaces() ]
  [ "finally" "implements"  abs=interfaces() ]
  { res = bossa.syntax.dispatch.makeInterface
      (name, parameters, typeParametersVariances, ext, imp, abs); }
|
  { boolean isFinal=false, isAbstract=false; }
  [ "final"    { isFinal=true; } ]
  [ "abstract" { isAbstract=true; } ]
  "class"
  name=ident()
  [ parameters=classTypeParameters(cst, typeParametersVariances) ]

  { MonotypeConstructor sup = null; }

  [ "extends" sup = superClass() ]
  [ "implements" imp=interfaces() ]
  [ "finally" "implements"  abs=interfaces() ]
  { res = bossa.syntax.dispatch.makeClass
	(name,
	isFinal,isAbstract,
	parameters,typeParametersVariances,
	sup,imp,abs);
  }
)
  ( 
   "{"
   { CNiceClass impl = new CNiceClass(res); List methods = new ArrayList();}
   // internal fields and methods
   (
      // Initializer
      { Statement init; }
      init = Block()
      { impl.addInitializer(init); }
    |
      LOOKAHEAD ( "override" ident() "=" )
      { LocatedString fname; Expression value;}
      "override" fname=ident() "=" value=Expression() ";"
      { impl.addValueOverride(fname, value); }
    |
      LOOKAHEAD( fieldLookahead() )
      getField(impl, storeDocString)
    | { Definition m; Token t = getToken(1); boolean isOverride = false; }
      [ "public" | "private" ]
      [ "override" { isOverride = true; } ]
      (
	LOOKAHEAD( methodBodyDefinitionLookahead() )
	m = methodBodyDefinition(impl)
	{ definitions.add(m); }
      |
        m = internalMethodOrFunction(res, isOverride)
        { methods.add(m); }
      ) 
      { if (storeDocString && isDocStringToken(t))
          m.docString = t.specialToken.image;
      }
   )* 
   "}"
   {
     res.setImplementation(impl);
     definitions.addAll(methods);
   }
  | 
   "=" "native"
   ( { LocatedString javaName; }
     javaName=doted_string()
     { res.setImplementation(new JavaClass(res, javaName)); }
   | { res.setImplementation(bossa.syntax.dispatch.createPrimitiveType(res)); }
   ) ";"
  )
  { return res; } 
}

CustomConstructor customConstructor(Constraint cst):
{
  LocatedString name;
  FormalParameters params;
  List statements = new LinkedList();
  Expression exp;
  Statement stmt;
}
{ 
  "new" name=ident() "(" params=formalParameters(false, statements) ")"
  ( 
    "=" exp=Expression() ";" { statements.add(bossa.syntax.dispatch.createExpressionStmt(exp)); }
  | 
    "{"
    ( stmt=BlockStatement(statements) { statements.add(stmt); } )*
    "}"
  )
  {
    return bossa.syntax.dispatch.createCustomConstructor(name, cst, params, bossa.syntax.dispatch.createBlock(statements));
  }
}

AbstractInterface interfaceDefinition(Constraint prefix, List definitions):
{
  LocatedString name;
  MethodContainer.Constraint parameters = null;
  List extensions=null;
  List typeParametersVariances = new ArrayList(0);
  AbstractInterface res;
}
{
  "abstract" "interface"
  name=ident()
  [ parameters=classTypeParameters(prefix, typeParametersVariances) ]
  [ "extends" extensions=interfaces() ]
  "{"
  { res = bossa.syntax.dispatch.createAbstractInterface(name,parameters,typeParametersVariances,
				extensions); }
    (
      { Definition m; }
      [ "public" | "private" ]
      m = internalMethodOrFunction(res, false)
      { definitions.add(m); }
    )*
  "}"
  { return res; }
}

AbstractInterfaceImplementation abstractInterfaceImplementation():
{
  LocatedString className, interfaceName;
  boolean _finally = false;
  boolean _interface = false;
}
{
  ( "class" | "interface" {_interface = true;} )
  className=fullyQualifiedName()
  [ "finally" { _finally = true; } ]
  "implements" interfaceName=ident() ";"
  { return new AbstractInterfaceImplementation(className, /*Node.none*/4, className, interfaceName,
		_finally, _interface);
  }
}


MethodContainer.Constraint classTypeParameters(Constraint prefix, List tags):
{
  List binders = new ArrayList(3);
  List atoms = new ArrayList(3);
  MonotypeVar var;
  Token start;
  Location loc;
}
{
  start="<" { loc = makeLocation(start); }
  var=taggedMonotypeVar(tags, atoms) { binders.add(var); }
  ( "," var=taggedMonotypeVar(tags, atoms) { binders.add(var); } )*
  [ "|" atomics(atoms) ]
  ">"
  {
    // For the moment, disallow constraints to come from both the prefix
    // and the type parameters.
    if (prefix != Constraint.True && atoms.size() > 0)
      throw bossa.util.User.error
        (loc, "Constraints on type parameters should all be specified in the prefix constraint");

    MonotypeVar[] b = (MonotypeVar[]) binders.toArray(new MonotypeVar[binders.size()]);
    return MethodContainer.Constraint.make(prefix, b, atoms, loc);
  }
}

MonotypeVar taggedMonotypeVar(List tags, List atoms):
{
  MonotypeVar mv;
  Monotype bound = null;
  boolean sure = false;
}
{
  [ LOOKAHEAD( monotype() ("+" | "-" | monotypeVar()) )
    bound=monotype() 
  ]

  ( "+" { tags.add(Boolean.TRUE); }
  | "-" { tags.add(Boolean.FALSE); }
  |     { tags.add(null); }
  )
  [ "!" { sure = true; } ]

  mv = monotypeVar()
  { 
    if (bound != null)
      {
        bound.nullness = Monotype.absent;
        atoms.add(new MonotypeLeqCst(Monotype.createVar(mv), bound)); 
      }

    if (sure) atoms.add(AtomicConstraint.sureTypeVar(mv));

    return mv;
  }
}

EnumDefinition enumDefinition(List definitions):
{ 
  LocatedString name;
  List elements = new LinkedList();
  List fields = new LinkedList();
  MonoSymbol field;
  List argsList = new LinkedList();
  List imp = null;
}
{
  "enum" name=ident()
  [ 
    "(" field=monoSymbol() { fields.add(field); }
     ( "," field=monoSymbol() { fields.add(field); } )* ")"
  ]
  [
    "implements" imp=interfaces()
  ]
  "{" enumElement(elements, argsList)
   ( "," enumElement(elements, argsList) )+
  "}"
  { return bossa.syntax.dispatch.createEnumDefinition(name, elements, fields, argsList, definitions, imp); }
}

void enumElement(List elements, List argsList):
{
  LocatedString elem;
  Expression arg;
  List args = new LinkedList();
}
{
  elem=ident() { elements.add(elem); }
  [ "(" arg=Expression() { args.add(arg); }
     ( "," arg=Expression() { args.add(arg); } )* ")"
  ]
  { argsList.add(args); }
}

/***********************************************************************/
/*                          Methods                                    */
/***********************************************************************/

Pattern pattern():
{
  LocatedString name = null;
  LocatedString refName = null;
  TypeIdent tc=null, additional = null;
  TypeConstructor runtimeTC = null;
  ConstantExp val = null;
  Token t;
}
{
(
  LOOKAHEAD( typeIdent() ( ":" | ident() | "(" typeIdent() ")" ident() ) )
  tc=typeIdent()
  [
    ":" runtimeTC=typeConstructor()
  |
    "(" additional=typeIdent() ")"
  ]  
  name=ident()
  { return bossa.syntax.fun.createPattern(tc, name, false, additional, runtimeTC); }
|
  "#" tc=typeIdent() 
  [ "(" additional=typeIdent() ")" ] 
  [ name=ident() ] 
  { return bossa.syntax.fun.createPattern(tc, name, true, additional, null); }
|
  ( 
    val=patternLiteral() 
    [ "(" additional=typeIdent() ")" ]
    { return val.createPattern(additional);}
  |
    "@" tc=typeIdent() 
    [ "(" additional=typeIdent() ")" ]
    { User.warning(tc.location(), "This syntax is deprecated, use 'Type paramName' instead.");
      return bossa.syntax.fun.createPattern(tc, null, false, additional, null);
    }
  |
    name=ident()
    (
      "@" { User.warning(name.location(), "This syntax is deprecated, use 'Type paramName' instead."); }
      tc=typeIdent()
      [ ":" runtimeTC=typeConstructor() ]
      [ "(" additional=typeIdent() ")" ]
      { return bossa.syntax.fun.createPattern(tc, name, false, additional, runtimeTC); }
    |
      "#" tc=typeIdent() 
      [ "(" additional=typeIdent() ")" ] 
      { User.warning(name.location(), "This syntax is deprecated, use '#Type paramName' instead.");
        return bossa.syntax.fun.createPattern(tc, name, true, additional, null);
      }
    |
      ( t=">" | t=">=" | t="<" | t="<=" )
      ( val=negativeIntConstantExp()
      | val=intConstantExp() 
      | refName=ident()
      )
      { return bossa.syntax.dispatch.createPattern(t.toString(), name, val, refName, name.location()); }
    |
     { return bossa.syntax.dispatch.createPattern(name); } //name only
    )
  )
)
}

void methodBodyDefinitionLookahead():
{}
{
  [ "<" strings() ">" ] identOrBackquoted() "("
}

Statement code():
{ Statement code; }
{
  ( 
    // A true body
    code=Block()
  |
    // An expression
    { Expression exp; }
    "="
    (
      exp=Expression() ";"
      { code = bossa.syntax.dispatch.createReturnStmt(exp, /* fake */ true); }
    |
      {Statement res;}
      (
	res = ShortIfStatement()
      |
	res = ShortAssertStatement()
      |
	res = ShortThrowStatement()
      )
      ";" 
      { List statements = new LinkedList();
        statements.add(res);
	return bossa.syntax.dispatch.createBlock(statements); }
    )
  )
  { return code; }
}

MethodBodyDefinition methodBodyDefinition(NiceClass container):
{
    LocatedString name;
    Pattern p;
    Collection binders=null;
    LinkedList parameters=new LinkedList();
    Statement body;
    Expression exp;
}
{
    [ "<" binders=strings() ">" ]
    name=identOrBackquoted()
    "("
    [ p=pattern() { parameters.add(p); }
      ( "," p=pattern() { parameters.add(p); } )*
    ]
    ")"
    body = code()
    { return bossa.syntax.dispatch.createMethodBodyDefinition(container,name,binders,
				      parameters,body); }
}

Definition methodDeclaration(Constraint cst, boolean isOverride):
{
    LocatedString name;
    Monotype returnType;
    FormalParameters parameters;
    Definition res;
    List statements = new LinkedList();
}
{
    returnType=monotype()
    name=identOrBackquoted()
    "(" parameters = formalParameters(false, statements) ")"
    
    ( LOOKAHEAD(2)
      "=" 
      (
        "native" res=nativeMethodDeclaration(name,cst,returnType,parameters)
      |
	"inline" 
	{ LocatedString inlinedName; String param = null; }
	inlinedName = doted_string() 
	[
	  "(" [ param=rawString() ] ")"
	]
	";"
	{ res=bossa.syntax.dispatch.createInlinedMethod(name,cst,returnType,parameters,
				inlinedName, param); }
      )
    | { Contract contract; }
      contract = contract()
      (
        { Statement body; }
        body=code() { statements.add(body); }
        { res = bossa.syntax.dispatch.createMethodWithDefault
            (name, cst, returnType, parameters, 
             bossa.syntax.dispatch.createBlock(statements), 
             contract, isOverride);
        }
      |
        // Nice method
        ";"
        { res = bossa.syntax.dispatch.createNiceMethod
            (name, cst, returnType, parameters, contract, isOverride); }
      )
    )
  { return res; }
}

// Designing a java method, found thru reflection
MethodDeclaration nativeMethodDeclaration(LocatedString name,
					Constraint cst,
					Monotype returnType,
					FormalParameters parameters):
{
  List javaTypes=null;
  LocatedString method,s=null;
  boolean isNew=false;
}
{
(
  "new" { isNew = true; }
|
  s=doted_array_string() 
)

// If we stop here with a ";", it's a field else it's a method.
( 
  ";"
  { method=s; }
| 
  { 
    javaTypes=new ArrayList();
     if(!isNew) javaTypes.add(s);
  }

  method=doted_string()
  "("
  [
    s=doted_array_string() { javaTypes.add(s); }
    ( "," s=doted_array_string() { javaTypes.add(s); } )*
  ]
  ")"  
  ";"
)
  { 
    if(isNew)
      {
	javaTypes.add(0,method);
	return bossa.syntax.dispatch.createRetypedJavaMethod(method,"<init>",javaTypes,
			             name,cst,returnType,parameters);
      }
    int dot=method.toString().lastIndexOf('.');
    if(dot==-1)
      throw bossa.util.User.error(method, "Class or method name missing");
    
    String methodName=method.toString();
    methodName = methodName.substring(dot+1,methodName.length());
    LocatedString className=method.substring(0,dot);
    
    if(javaTypes!=null)
      return bossa.syntax.dispatch.createRetypedJavaMethod(className,methodName,javaTypes,
			           name,cst,returnType,parameters);
    else
      return bossa.syntax.dispatch.createJavaFieldAccess(className,methodName,
				 name,cst,returnType,parameters);
  }
}

Definition globalVariable():
{
  LocatedString name;
  Monotype t;
  Expression value=null;
  boolean constant = true;
}
{
  ( "var" {constant = false;} | "let" )
  t=monotype() name=ident() 
  "=" 
  ( LOOKAHEAD(funExpLookahead()) 
    value=funExp() 
  | 
    value=SideEffectFreeExpression()
  )
  ";"
  { return bossa.syntax.dispatch.createGlobalVarDeclaration(name,t,value,constant); }
}

Contract contract() :
{
  Contract res = bossa.syntax.fun.noContract;
  Expression condition, name;
}
{
  [ "requires" { res = new Contract(); }
    contractElements(res, true)
  ]
  [ "ensures" { if (res == bossa.syntax.fun.noContract) res = new Contract(); }
    contractElements(res, false)
  ]
  { return res; }
}

void contractElements(Contract contract, boolean precond) :
{}
{
  contractElement(contract, precond)
  ( "," [ // Trailing "," allowed for easy reordering, removal of last line..
    contractElement(contract, precond)
  ] )*
}

void contractElement(Contract contract, boolean precond) :
{ Expression condition, name=null; }
{
  condition = SideEffectFreeExpression() 
  [ ":" name = SideEffectFreeExpression() ]
  { contract.addElement(condition, name, precond); }
}


Definition definition(List definitions, boolean storeDocString):
{ Definition res; }
{
  (
    LOOKAHEAD( ("class" | "interface") fullyQualifiedName() )
    res=abstractInterfaceImplementation()
  | 
    LOOKAHEAD( methodBodyDefinitionLookahead() )
    res=methodBodyDefinition(null)
  |
    [ "public" | "private" ]
    ( 
      res=globalVariable()
    | res=enumDefinition(definitions)
    | "override" { Constraint cst; } cst = constraint() 
      res=methodDeclaration(cst, true)
    | cst = constraint()
      ( 
        res=customConstructor(cst)
      | LOOKAHEAD ( "abstract" "interface" )
        res=interfaceDefinition(cst, definitions)
      | res=typeDefinition(cst, definitions, storeDocString)
      | res=methodDeclaration(cst, false)
      )
    )
  )
  { return res; }
}

void readDefinitions(List definitions,boolean storeDocString):
{
  Definition d;
  Token t;
}
{ { t = getToken(1); }
  ( d = definition(definitions, storeDocString)
    { 
      if (storeDocString && isDocStringToken(t))
        d.docString = t.specialToken.image;

      definitions.add(d);
      t = getToken(1);
    }
  )*
  <EOF> 
}


/***********************************************************************/
/*                          Expressions                                */
/***********************************************************************/

ConstantExp nullConstantExp():
{ Token t; }
{
  t="null" 
  { return bossa.syntax.dispatch.createNullExp(makeLocation(t)); }
}

ConstantExp booleanConstantExp():
{ Token t; }
{
  t = "true"  { return bossa.syntax.dispatch.createBooleanConstant(true,  makeLocation(t)); }
| t = "false" { return bossa.syntax.dispatch.createBooleanConstant(false, makeLocation(t)); }
}

ConstantExp intConstantExp():
{ LocatedString representation; }
{
  representation=integerLiteral()
  { return bossa.syntax.dispatch.createIntegerConstantExp(representation); }
}

ConstantExp negativeIntConstantExp():
{ LocatedString representation; }
{ 
  "-" representation=integerLiteral()
  { 
    representation.prepend("-");
    return bossa.syntax.dispatch.createIntegerConstantExp(representation);
  }
}

ConstantExp floatConstantExp():
{ LocatedString representation; }
{
  representation=floatingLiteral()
  { return bossa.syntax.dispatch.createFloatConstantExp(representation); }
}

ConstantExp charConstantExp():
{ Token t; }
{
  t = <CHARACTER_LITERAL> 
  { return bossa.syntax.dispatch.createCharConstant
      (new LocatedString(t.image.substring(1, t.image.length() - 1),
			 makeLocation(t)));
  }
}

ConstantExp stringConstantExp():
{ String s; }
{
  s=rawString()
  { return bossa.syntax.dispatch.createStringConstantExp(s); }
}

ConstantExp multiLineStringExp():
{ Token t; String s; }
{
  t = <MULTILINESTRING>
  { s = t.image.substring(3, t.image.length() - 3);
    return bossa.syntax.dispatch.createStringConstantExp(s, true);
  }
}

Expression identExp():
{ LocatedString i; }
{
  i=identOrBackquoted()
  { return bossa.syntax.dispatch.createIdentExp(i); }
}

Expression SuperExp() :
{ TypeIdent typeId;  List types = null; }
{
  "super" 
  [ LOOKAHEAD("(") "(" 
    typeId=typeIdent() { types=new ArrayList(); types.add(typeId); }
    ( "," typeId=typeIdent() { types.add(typeId); } )*
    ")"
  ]
  { return new SuperExp(types); }
}

Expression newExp():
{
  Token t;
  TypeIdent classe;
  Expression e;
}
{
  t="new" classe=typeConstructorIdent()
  ( 
    { Arguments arguments; }
    arguments = arguments(false)
    { e = bossa.syntax.fun.createNewExp(classe, arguments); 
      e.setLocation(makeLocation(t));
      return e;
    }
  |
    { List args = new LinkedList(); int furtherDimensions = 0; }
    ( LOOKAHEAD(2) "[" e=Expression() "]" { args.add(e); } )+ 
    ( LOOKAHEAD(2) "[]" { furtherDimensions++; } )*
    { return new NewArrayExp(classe, args, furtherDimensions); }
  |
    "<"
    { parseException("Type parameters are not needed in constructor calls"); }
  )
}

void funExpLookahead():
{}
{
  ( 
    LOOKAHEAD ( "(" ")" ) "(" ")"
  |
    LOOKAHEAD ( monoSymbol() )
    monoSymbol()
  |
    constraint() "(" NestedMonoSymbols() ")"
  ) 
  "=>"
}

MonoSymbol funExpParameter(List statements):
{
  Monotype type;
  LocatedString name;
}
{
(
  LOOKAHEAD( monotype() )
  type=monotype() name=ident()
  { return new MonoSymbol(name,type); }
| 
  { Token first,last;
    List parts = new LinkedList();
    Expression part;
    List types = new LinkedList();
    LocatedString ident = null;
  }

  first="("
  part = ParameterTuplePart(statements, types) { parts.add(part); }
  ( "," part = ParameterTuplePart(statements, types) { parts.add(part); } )+
  last=")"
  [ ident=ident() ]
  { if (ident == null) {
      name = new LocatedString("tuple_arg_" + first.beginLine + "_" + first.beginColumn, 
				makeLocation(first, last));
    } else { name = ident; }
    Expression exp = bossa.syntax.dispatch.createAssignExp(new TupleExp(parts),bossa.syntax.dispatch.createIdentExp(name));
    exp.setLocation(makeLocation(first,last));
    statements.add(bossa.syntax.dispatch.createExpressionStmt(exp));
    type = new TupleType(types, makeLocation(first, last));
    type.nullness = Monotype.absent;
    return new MonoSymbol(name, type);
  }
)
}

Expression funExp():
{
  List formals = new LinkedList();
  Constraint cst = Constraint.True;
  MonoSymbol sym;
  Statement body;
  Expression exp;
  List statements = new LinkedList();
}
{
  ( 
    LOOKAHEAD ( "(" ")" ) "(" ")"
  | 
    LOOKAHEAD ( monoSymbol() ) 
    sym=monoSymbol() { formals.add(sym); }
  | 
    cst=constraint() "(" 
    sym=funExpParameter(statements) { formals.add(sym); }
    ( "," sym=funExpParameter(statements) { formals.add(sym); } )*
    ")"
  ) 
  "=>"
  (
    body=RootShortStatement()
  |
    exp=Expression() { body = bossa.syntax.dispatch.createReturnStmt(exp); }
  )
  { statements.add(body);
    return bossa.syntax.dispatch.createFunExp(cst, formals, bossa.syntax.dispatch.createBlock(statements)); }
}

/** A statement not terminated by a ";" if applicable. */
Statement RootShortStatement() :
{ Statement res; }
{
( res = Block()
| res = ShortIfStatement()
| res = ShortAssertStatement()
| res = ShortThrowStatement()
)
  { return res; }
}

Statement ShortStatement() :
{ Statement res; }
{
(  res = RootShortStatement()
|  res = ShortStatementExpression()
)
  { return res; }
}

// ( e1, ..., en )
Expression tupleExp():
{
  List exps;
  Expression e;
}
{
  // A tuple must have at least two elements (thus a ",")
  // which avoids ambiguity with expression grouping thru "(" ")"
  "(" { exps = new LinkedList(); }
  e=Expression() 

  // either we have another expression ans it's a real tuple
  // either we close the parenthesis and it was grouping
  (
    ")" { return e; }
  |
    { exps.add(e); }
    ( "," e=Expression() { exps.add(e); } )+
    ")"
    { return new TupleExp(exps); }
  )
}

// [ e1, ..., en ]
Expression arrayLiteralExp():
{
  List exps;
  Expression e;
}
{
  "[]" { return bossa.syntax.dispatch.createLiteralArrayExp(null); }
|
  "[" { exps = new LinkedList(); }
  [
    e=Expression() { exps.add(e); }
    (
      "," e=Expression() { exps.add(e); }
    )*
  ]
  "]"
  { return bossa.syntax.dispatch.createLiteralArrayExp(exps); }
}

/****************************************************************
 * Imported Packages
 ****************************************************************/

LocatedString readImports(List imports, Collection opens):
{ LocatedString pkgName=null, name; }
{
  [ "package" pkgName=doted_string() ";" ]
  (
   "import" name=doted_string() 
   ( ".*" { opens.add(name.toString()); }
     [ "(" "!" ")"  
       { nice.tools.code.Import.addStrictPackage(name.toString()); }
     ]
   |      { imports.add(name); }
   )
   ";"
  )*
  { return pkgName; }
}

void readOpens():
{}
{
  [ "package" doted_string() ";" ]
  (
   "import" doted_string() [ ".*" [ "(" "!" ")" ] ]
   ";"
  )*
}

/****************************************************************
 * Modules
 ****************************************************************/

void module(List definitions, boolean storeDocStrings):
{}
{
  readOpens()
  readDefinitions(definitions, storeDocStrings)
}

/****************************************************************
 * JAVA statements and expressions
 ****************************************************************/

// Java 1.1 syntax-compliant 
// Derived from the Java1.1.jj file that comes with JavaCC

/*
 * Expression syntax follows.
 */

Expression Expression() :
/*
 * This expansion has been written this way instead of:
 *   Assignment() | ConditionalExpression()
 * for performance reasons.
 * However, it is a weakening of the grammar for it allows the LHS of
 * assignments to be any conditional expression whereas it can only be
 * a primary expression.  Consider adding a semantic predicate to work
 * around this.
 */
{ Expression e1,e2; Token op; Token first,last; }
{
  { first=getToken(1); }

  ( 
    LOOKAHEAD(funExpLookahead()) e1=funExp() 
  |
    e1=ConditionalExpression()
    [ 
      { e1.setLocation(makeLocation(first, getToken(0))); }
      op=AssignmentOperator() 
      e2=Expression()
      {
        if(op.image.length()!=1)
          e2=bossa.syntax.dispatch.createCallExp(symb(op.image.substring(0, 1),op),e1,e2);
  
        e1=bossa.syntax.dispatch.createAssignExp(e1,e2);
      }
    ]
  )
  { 
    last=getToken(0);
    e1.setLocation(makeLocation(first, last));
    return e1;
  }
}

Expression SideEffectFreeExpression() :
{ Expression e; }
{
  e = ConditionalExpression()
  { return e; }
}

Token AssignmentOperator() :
{ Token res; }
{
  (
    res = "="
  |
    res= < assignmentOperator : 
      "*=" | "/=" | "%=" | "+=" | "-=" | 
      "<<=" | ">>=" | ">>>=" | "&=" | "^=" | "|=" 
      >
  )
  { return res; }
}

Expression ConditionalExpression() :
{ Expression res,e1,e2; Token start; }
{
  res=ImpliesExpression() 
    [
      "?" e1=Expression() start=":" e2=ConditionalExpression() 
      { e2.setLocation(makeLocation(start, getToken(0))); 
        res=new IfExp(res,e1,e2); }
    ]
  { return res; }
}

Expression ImpliesExpression() :
{ Expression e1,e2; Token t; }
{
  e1=ConditionalOrExpression() 
//    ( t="->" e2=ConditionalOrExpression() 
//      { e1=CallExp.create(symb(t), e1, e2); } )?
  { return e1; }
}

Expression ConditionalOrExpression() :
{ Expression e1,e2; Token t; }
{
  e1=ConditionalAndExpression() 
    ( t="||" e2=ConditionalOrExpression() 
      { e1=bossa.syntax.dispatch.createCallExp(symb(t), e1, e2); } )?
  { return e1; }
}

Expression ConditionalAndExpression() :
{ Expression e1,e2; Token t; }
{
  e1=InclusiveOrExpression() 
    ( t="&&" e2=ConditionalAndExpression()
      { e1=bossa.syntax.dispatch.createCallExp(symb(t), e1, e2); } )?
  { return e1; }
}

Expression InclusiveOrExpression() :
{ Expression e1,e2; Token t; }
{
  e1=ExclusiveOrExpression() 
    ( t="|" e2=ExclusiveOrExpression() 
      { e1=bossa.syntax.dispatch.createCallExp(symb(t),e1,e2); } )*
  { return e1; }
}

Expression ExclusiveOrExpression() :
{ Expression e1,e2; Token t; }
{
  e1=AndExpression() 
    ( t="^" e2=AndExpression() 
      { e1=bossa.syntax.dispatch.createCallExp(symb(t),e1,e2); } )*
  { return e1; }
}

Expression AndExpression() :
{ Expression e1,e2; Token t; }
{
  e1=EqualityExpression() 
    ( t="&" e2=EqualityExpression() 
      { e1=bossa.syntax.dispatch.createCallExp(symb(t),e1,e2); } )*
  { return e1; }
}

Expression EqualityExpression() :
{ Expression e1,e2; Token t; }
{
  e1=InstanceOfExpression() 
    ( ( t="==" | t="!=" ) e2=InstanceOfExpression() 
      { e1=bossa.syntax.dispatch.createCallExp(symb(t),e1,e2); }
      )*
  { return e1; }
}

Expression InstanceOfExpression() :
{ Expression res; }
{
  res=RelationalExpression()
  [ { Token t; TypeConstantExp type; }
    t="instanceof" type=typeExpression()
    { type.isLiteral = true; return bossa.syntax.dispatch.createCallExp(symb(t), res, type); }
  ]
  { return res; }
}

Expression RelationalExpression() :
{ Expression e1, e2, e3; Token t, t_prev = null; e3 = null; }
{
  e1=RangeExpression()
  ( (t=">"|t=">="|t="<"|t="<=") e2=RangeExpression()
    {
      if(e3 == null) e1=bossa.syntax.dispatch.createCallExp(symb(t),e1,e2);
      else
      {
        e1=bossa.syntax.dispatch.createCallExp(symb("&&",t),e1,bossa.syntax.dispatch.createCallExp(symb(t),e3,e2));
        if (t.image.charAt(0) != t_prev.image.charAt(0))
	  User.error(makeLocation(t), "All chained comparisons should be in the same direction");
      }
      e3 = e2;
      t_prev = t;
    }
  )*
  { return e1; }
}

Expression RangeExpression() :
{ Expression e1 = null,e2 = null; Token t = null; }
{
  ( 
    e1=ShiftExpression() [ t=".." [e2=ShiftExpression()]]
  |  
    t=".." [e2 = ShiftExpression()]
  )
  {
    if (t != null)
      {
        if (e1 == null)
          e1 = bossa.syntax.dispatch.createIntegerConstantExp(new LocatedString("0", makeLocation(t)));

	if (e2 == null)
	  e2 = bossa.syntax.dispatch.createNullExp(makeLocation(t));

        e1=bossa.syntax.dispatch.createCallExp(symb(t),e1,e2); 
      }

    return e1;
  }
}

Expression ShiftExpression() :
{ Expression e1,e2; Token t,t1=null; boolean left=false; }
{
  e1=AdditiveExpression() 
    ( LOOKAHEAD(2)
     ( t="<" "<" { left=true; }
     | t=">" ">" [ t1=">" ]
     )
     e2=AdditiveExpression() 
     { 
       String func;
       if(left)
         func = "<<";
       else
         func = t1==null ? ">>" : ">>>";
       e1=bossa.syntax.dispatch.createCallExp(symb(func,t),e1,e2); }
      )*
  { return e1; }
}

Expression AdditiveExpression() :
{ Expression e1,e2; Token t; }
{
  e1=MultiplicativeExpression() 
    ( ( t="+" | t="-" ) e2=MultiplicativeExpression() 
      { e1=bossa.syntax.dispatch.createCallExp(symb(t),e1,e2); }
      )*
  { return e1; }
}

Expression MultiplicativeExpression() :
{ Expression e1,e2; Token t; }
{
  e1=ExponentialExpression() 
    ( (t="*"|t="/"|t="%") e2=ExponentialExpression() 
      { e1=bossa.syntax.dispatch.createCallExp(symb(t),e1,e2); }
    )*
  { return e1; }
}

Expression ExponentialExpression() :
{ Expression e1,e2; Token t; }
{
  e1=UnaryExpression() 
    // '**' has right associativity
    [ t="**" e2=ExponentialExpression() 
      { e1=bossa.syntax.dispatch.createCallExp(symb(t),e1,e2); }
    ]
  { return e1; }
}

Expression UnaryExpression() :
{ Expression res; Token t=null; }
{
(
  ( ( t="~" | t="!" ) res=PrimaryExpression() 
    { res=bossa.syntax.dispatch.createCallExp(symb(t),res); }
  |
    ( t="+" | t="-" ) res=PrimaryExpression() 
    { if (res instanceof NumberConstantExp)
      {
        if (t.kind == MINUS)
          res = ((NumberConstantExp)res).makeNegative();
      } 
      else
	res=bossa.syntax.dispatch.createCallExp(symb(t),res);
    }
  )
|
  res=Pre_crementExpression()
|
  res=PostfixExpression()
)
  { return res; }
}

Expression Pre_crementExpression() :
{ Expression res; Token t; boolean inc = false; }
{
  ( t="++" {inc = true;} | t="--" ) res=PrimaryExpression()
  { return bossa.syntax.dispatch.createIncrementExp(res, true, inc); }
}

Expression PostfixExpression() :
{ Expression res; Token t; }
{
  res=PrimaryExpression() 
  [ "++" { res=bossa.syntax.dispatch.createIncrementExp(res, false, true); }
  | "--" { res=bossa.syntax.dispatch.createIncrementExp(res, false, false); }
  ] 
  { return res; }
}

Expression PrimaryExpression() :
{ Expression res; Token first = getToken(1);}
{
  res=PrimaryPrefix() 
    ( res=PrimarySuffix(res) )*
  { res.setLocation(makeLocation(first, getToken(0))); 
    return res; }
}

Expression PrimaryPrefix() :
{ Expression res; }
{
(
  res=Literal()
| 
  res = SuperExp()
|
  // This includes the case "(" Expression() ")" to avoid lookahead
  res=tupleExp()
|
  res=arrayLiteralExp() 
|
  res=newExp()
|
  LOOKAHEAD( doted_array_string() "." "class" )
  { TypeConstantExp type; Token t; }
  type=typeExpression() "." t="class"
  { type.isExpression = true; return type; }
|
  //Name()
  res=identExp()
)
  { return res; }
}

Expression PrimarySuffix(Expression start) :
{ 
  Expression res;
  Arguments args = null;
}
{
  { Token t; List bracketArgs = new ArrayList();
    bracketArgs.add(new Arguments.Argument(start)); }
  t="[" res=Expression() {bracketArgs.add(new Arguments.Argument(res));} 
    ( "," res=Expression() {bracketArgs.add(new Arguments.Argument(res));} )*
  "]"
  { return bossa.syntax.dispatch.createCallExp(symb("get",t,false),new Arguments(bracketArgs)); }
|
  "." res=identExp()
  [ LOOKAHEAD(1) // a.f(x) is parsed as f(a, x), not as (f(a))(x)
    args = arguments(true) ]
  { 
    boolean hasBrackets = args != null;

    if (args == null)
      args = Arguments.singleArgument(start);
    else
      args.addReceiver(start);

    return bossa.syntax.dispatch.createCallExp(res, args, true, hasBrackets); 
  }
|
  args = arguments(false)
  { return bossa.syntax.dispatch.createCallExp(start, args); }
}

// The expressions that can follow a string literal, to be concatenated with it
Expression StringLiteralSuffixExpression() :
{ Expression res; }
{
  res=identExp()
  ( LOOKAHEAD(2) res=PrimarySuffix(res) )*
{ return res; }
}

Expression Literal() :
{
  Expression res;
  Token t;
}
{
( res=nullConstantExp()
| res=booleanConstantExp()
| res=intConstantExp() 
| res=floatConstantExp()
| res=charConstantExp()
| res=stringConstantExp()
  ( {Expression e;} e=StringLiteralSuffixExpression() 
    { res = bossa.syntax.dispatch.createCallExp(symb("+", e.location()), res, e); }
    [ e=stringConstantExp() 
      { res = bossa.syntax.dispatch.createCallExp(symb("+", e.location()), res, e); }
    ]
  )*
| res=multiLineStringExp()
| res=atExpression()
)
{ return res; }
}

Expression atExpression() :
{ Token t; }
{
  (t="@")
  { return bossa.syntax.dispatch.createCallExp(symb(t), Arguments.noArguments()); }
}

ConstantExp patternLiteral() :
//restricted literal for use in dispatch patterns
{
  ConstantExp res;
  Token t;
}
{
( res=nullConstantExp()
| res=negativeIntConstantExp()
| res=intConstantExp() 
| res=charConstantExp()
| res=booleanConstantExp()
| res=stringConstantExp()
)
{ return res; }
}

Expression ExpLocalVariable():
{
  boolean constant = false;
  LocatedString name;
  Monotype type = null;
  Expression value;
}
{
  [ "var" | "let" {constant = true;} ]
  [LOOKAHEAD(monotype() ident()) type=monotype() ]
  name=ident()
  "="
  value=Expression()
  { return bossa.syntax.dispatch.createExpLocalVariable(name, value, constant, type); }
}

Arguments.Argument argument():
{
  Expression e;
  LocatedString id = null;
}
{
(
  LOOKAHEAD( "let" | "var" | (monotype() ident() "=") )
  e = ExpLocalVariable()
|
  [ LOOKAHEAD(ident() ":") id = ident() ":" ]
  e = Expression()
)
  { return new Arguments.Argument(e, id); }
}

Arguments arguments(boolean leaveRoomForReceiver):
{
  List res = new ArrayList();
  Arguments.Argument a;
}
{
  "("
  { if (leaveRoomForReceiver) res.add(null); }
  [
    a = argument() { res.add(a); }
    ( "," a = argument() { res.add(a); } )*
  ]
  ")"
  { return new Arguments(res); }
}

/*
 * Statement syntax follows.
 */

Statement Statement() :
{ Token first; Statement res; }
{
  { first = getToken(1); }
( 
  LOOKAHEAD(2)
  res=LabeledStatement()
| res=Block()
| res=RealStatementExpression()
| res=IfStatement()
| res=WhileStatement()
| res=DoStatement()
| res=ForStatement()
| res=BreakStatement()
| res=ContinueStatement()
| res=ReturnStatement()
| res=ShortThrowStatement() ";"
| res=TryStatement()
| res=ShortAssertStatement() ";"
| res=SynchronizedStatement()
)
  { 
    res.setLocation(makeLocation(first, getToken(0)));
    return res; 
  }
}

Statement LabeledStatement() :
{ LocatedString label; Statement res; boolean forLoop; }
{
  label=ident() ":" 
  { forLoop = "for".equals(getToken(1).toString()); }
  ( res=Block()
  | res=ForStatement()
  | res=WhileStatement()
  | res=DoStatement()
  )
  { 
    // Fix labeling of for loops:
    // for(int i, ...) is parsed as a block defining a local variable i
    // however we want the label to target the loop so that continue works
    if (forLoop && !(res instanceof LoopStmt))
      return new LabeledStmt(label, res, (LoopStmt) ((Block) res).last());
    else
      return new LabeledStmt(label, res); 
  }
}

Statement Block() :
{ Token first, last; Statement s; List statements; }
{
  { first = getToken(1); }
  "{" 
  { statements = new LinkedList(); }
  ( s=BlockStatement(statements) { statements.add(s); } )* 
  "}"
  { 
    last = getToken(0);
    Statement res = bossa.syntax.dispatch.createBlock(statements); 
    res.setLocation(makeLocation(first, last));
    return res;
  }
}

Statement BlockStatement(List statements) :
{ Statement res; }
{
(
  LOOKAHEAD( "var" | "let" | monotype() <IDENT>)
  ( 
    LOOKAHEAD( [ "var" | "let" ] monotype() <IDENT> "(" )
    res = LocalFunctionDeclaration() 
  |
    res = LocalDeclaration() ";"
  )
| //try first a tupleExp before a tupleDeclaration
  LOOKAHEAD ( LocalTupleExpLookahead() )
  res=Statement()
|
  LOOKAHEAD( LocalTupleDeclarationLookahead() )
  res=LocalTupleDeclaration(statements)
|
  res=Statement()
)
  { return res; }
}

Statement LocalDeclaration() :
{
  Monotype type = null;
  LocatedString id;
  Expression e = null;
  boolean constant = false;
  Token t = null;
  Statement res;
}
{
  (
    type=monotype()
  |
    ( "var" | "let" {constant = true;} )
    [ LOOKAHEAD ( monotype() <IDENT> ) type=monotype() ]
  )
  id=ident()
  [ "=" e=Expression() ] 
  { res = bossa.syntax.dispatch.createLocalVariable(id,type,constant,e); }
  ( LOOKAHEAD( "," <IDENT> ( "=" | ";" | ",") ) 
    "," id=ident() {e=null;} [ "=" e=Expression() ] { bossa.syntax.fun.addNextLocal(res,id,e); } )*

  { return res; }
}

Statement LocalFunctionDeclaration() :
{
  Monotype type = null;
  LocatedString id;
  FormalParameters parameters;
  Statement body;
  boolean constant = false;
  Token t = null;
  List statements = new LinkedList();
}
{
  [ "let" {constant = true;} | "var" ]
  type = monotype()
  id=ident()
  "(" parameters=formalParameters(false, statements) ")" 
  body=code() { statements.add(body); } 
  { return bossa.syntax.dispatch.createLocalFunction(id, type, parameters, body!=null?bossa.syntax.dispatch.createBlock(statements):null); }
}

Statement LocalTupleDeclaration(List statements) :
{
  Expression e;
  Token first,last;
}
{
  first="(" { List parts = new LinkedList(); Expression part; }
  part = LocalTuplePart(statements) { parts.add(part); }
  ( "," part = LocalTuplePart(statements) { parts.add(part); } )+
  last=")"
  "=" e=Expression() ";" 
  { Expression exp = bossa.syntax.dispatch.createAssignExp(new TupleExp(parts), e);
    exp.setLocation(makeLocation(first,last));
    return bossa.syntax.dispatch.createExpressionStmt(exp); }
}

Expression LocalTuplePart(List statements) :
{ LocatedString id; Monotype type; }
{
( //first look for a ident without matching a monotype
  LOOKAHEAD( doted_string() ( "," | ")" ) ) id=doted_string() 
  { return bossa.syntax.dispatch.createIdentExp(id); }
| //then look for a monotype without matching a tuplePart
  LOOKAHEAD( monotype() ident() ) type=monotype()  id=ident() 
  { statements.add(bossa.syntax.dispatch.createLocalVariable(id, type, false, null)); 
    return  bossa.syntax.dispatch.createIdentExp(id); }
| //otherwise it's localtuple part
  "(" { List parts = new LinkedList(); Expression part; }
  part = LocalTuplePart(statements) { parts.add(part); }
  ( "," part = LocalTuplePart(statements) { parts.add(part); } )+
  ")"
  { return new TupleExp(parts); }
)
}

void LocalTupleDeclarationLookahead() : {}
{
  /*
    It is impossible to match exactly the actual syntax of
    tuple declarations, because it would require nested lookaheads.
    However, since this is the only piece of syntax of the form
      ( ... ) = ...
    we just do an approximation in LocalTupleDeclarationContent.
    The important part is to accept all legal tokens, and to
    correctly parse "(" and ")", so we know the end of the tuple.
  */
  "(" NestedMonoSymbols() ")" "="
}

void NestedMonoSymbols() : { }
{
(
  "(" NestedMonoSymbols() ")"
// Identifiers, either in types, or as a variable to assign to.
| <IDENT>
// All tokens that can be part of a monotype
// (exception "(" and ")" which are already handled, since they are
// be balanced in a monotype too).
| "<" | ">" | "," | "->" | "." | "?" | "!" | "[]" | "[?]" | "alike"
)+
}

// lookahead for a tupleExp on left side of an assignment 
void LocalTupleExpLookahead() : {}
{
  "(" LocalTupleExpContent() ")" "="
}

void LocalTupleExpContent() : { }
{
( "(" LocalTupleExpContent() ")"
| doted_string()
) 
( "," 
  ( "(" LocalTupleExpContent() ")"
  | doted_string()
  )
)* 
}

void PostfixBlocks(Expression exp) :
{ LocatedString name; Statement block; }
{
(
  block=Block()
  { if ( exp instanceof CallExp && ((CallExp)exp).hasBrackets && ! (exp instanceof NewExp) )
      bossa.syntax.dispatch.addBlockArgument(exp,block, null);
    else
      throw bossa.util.User.error(exp,"Block arguments can only be added to normal function calls");
  }
)
}

Statement RealStatementExpression() :
{ Expression e1; Token first, last; Statement block; }
{
  { first = getToken(1); }
(
  e1=Pre_crementExpression() ";"
|
  ( LOOKAHEAD("super")
    e1=SuperExp() ";"
  |
    e1=PrimaryPrefix()
    ( 
      e1=PostfixStatementExpression(e1, first) ";"
    |
      ( e1=PrimarySuffix(e1) )+
      (
        ";"
      |
        PostfixBlocks(e1)
      |
        e1=PostfixStatementExpression(e1, first) ";"
      )
    )
  )
)
  {
    last = getToken(0);
    e1.setLocation(makeLocation(first, last));
    return bossa.syntax.dispatch.createExpressionStmt(e1); 
  }
}

Statement ShortStatementExpression() :
{ Expression e1; Token first, last; Statement block; }
{
  { first = getToken(1); }
(
  e1=Pre_crementExpression()
|
  ( LOOKAHEAD("super")
    e1=SuperExp()
  |
    e1=PrimaryPrefix()
    ( 
      e1=PostfixStatementExpression(e1, first)
    |
      ( e1=PrimarySuffix(e1) )+
      [
        PostfixBlocks(e1)
      |
        e1=PostfixStatementExpression(e1, first)
      ]
    )
  )
)
  {
    last = getToken(0);
    e1.setLocation(makeLocation(first, last));
    return bossa.syntax.dispatch.createExpressionStmt(e1); 
  }

}

Expression PostfixStatementExpression(Expression e1, Token first) :
{}
{
  (
    "++" { e1=bossa.syntax.dispatch.createIncrementExp(e1, false, true); }
  |
    "--" { e1=bossa.syntax.dispatch.createIncrementExp(e1, false, false); }
  |
    { Token op; Expression e2; 
      e1.setLocation(makeLocation(first, getToken(0)));
    }
    op=AssignmentOperator() 
    e2=Expression()
    {
      if(op.image.length()!=1)
        e2=bossa.syntax.dispatch.createCallExp(symb(op.image.substring(0, 1),op),e1,e2);
  
      e1=bossa.syntax.dispatch.createAssignExp(e1,e2);
    }
  )
  { return e1; }
}

Statement IfStatement() :
/*
 * The disambiguating algorithm of JavaCC automatically binds dangling
 * else's to the innermost if statement.  The LOOKAHEAD specification
 * is to tell JavaCC that we know what we are doing.
 */
{ Token first; Statement s1,s2=null; Expression cond; IfExp ifExp; }
{
  first="if" "(" cond=Expression() ")" 
    s1=Statement() [ LOOKAHEAD(1) "else" s2=Statement() ]
  { 
    return bossa.syntax.dispatch.createIfStmt(cond, s1, s2, 
				makeLocation(first, getToken(0)));
  }
}

Statement ShortIfStatement() :
/*
 * The disambiguating algorithm of JavaCC automatically binds dangling
 * else's to the innermost if statement.  The LOOKAHEAD specification
 * is to tell JavaCC that we know what we are doing.
 */
{ Token first; Statement s1,s2=null; Expression cond; IfExp ifExp; }
{
  first="if" "(" cond=Expression() ")" 
    s1=ShortStatement() [ LOOKAHEAD(1) "else" s2=ShortStatement() ]
  { 
    return bossa.syntax.dispatch.createIfStmt(cond, s1, s2, 
				makeLocation(first, getToken(0)));
  }
}

Statement WhileStatement() :
{ Expression cond; Statement body; }
{
  "while" "(" cond=Expression() ")" body=Statement()
  { return bossa.syntax.dispatch.createWhileLoop(cond,body); }
}

Statement DoStatement() :
{ Expression cond; Statement body; }
{
  "do" body=Statement() "while" "(" cond=Expression() ")" ";"
  { return bossa.syntax.dispatch.createDoLoop(cond,body); }
}

Statement ForStatement() :
{ Statement update = null;
  Statement loop = null, body, statexp;
  Expression cond = null;
  List init = new ArrayList();
}
{
  "for" "(" 
  (  
    LOOKAHEAD( <IDENT> ":" ) loop=ForInStatement()
  |
    LOOKAHEAD( monotype() <IDENT> ":" ) loop=ForInStatement()
  | (
      LOOKAHEAD( "var" | "let" | monotype() <IDENT>) 
      init=LocalDeclarationList() 
    | statexp=ShortStatementExpression() ";" {init.add(statexp);}
    | ";"
    )
    [ cond=Expression() ] ";" [ update=StatementExpressionList() ] ")" 
    body=Statement()
    { loop=bossa.syntax.dispatch.createForLoop(cond,update,body,init); }
  )
  { return loop; }
}

Statement ForInStatement() :                                                
{ Statement body; Monotype vartype = null; LocatedString var; Expression container; Token t; }
{
  ( 
    LOOKAHEAD( <IDENT> ":") var=ident()
  | 
    vartype=monotype() var=ident() 
  ) 
  t=":" container=Expression() ")"
  body=Statement()
  { return bossa.syntax.dispatch.createForInLoop(vartype,var,makeLocation(t),container,body); }
}

List LocalDeclarationList() :
{ Statement d; List declarations = new LinkedList(); }
{
  d=LocalDeclaration() {declarations.add(d);} 
  ( "," d=LocalDeclaration() {declarations.add(d);} )*
  ";"
  { return declarations; }
}

Statement StatementExpressionList() :
{ Statement s; List statements=new LinkedList(); }
{
  s=ShortStatementExpression() { statements.add(s); }
  ( "," s=ShortStatementExpression() { statements.add(s); }
  )*
  { return bossa.syntax.dispatch.createBlock(statements); }
}

Statement BreakStatement() :
{ LocatedString label = null; }
{
  "break" [ label=ident() ] ";"
  { return bossa.syntax.dispatch.createBreakStmt(label); }
}

Statement ContinueStatement() :
{ Statement res; LocatedString label = null; }
{
  "continue" [ label=ident() ] ";"
  { return bossa.syntax.dispatch.createContinueStmt(label); }
}

Statement ReturnStatement() :
{ Expression val=null; Token t; }
{
  t="return" [ val=Expression() ] ";"
  {
    Statement res = bossa.syntax.dispatch.createReturnStmt(val); 
    res.setLocation(makeLocation(t));
    return res;
  }
}

Statement ShortThrowStatement() :
{ Expression e; Token t; }
{
  t="throw" e=Expression()
  { return bossa.syntax.dispatch.createExpressionStmt(bossa.syntax.dispatch.createCallExp(symb(t),e)); }
}

Statement TryStatement() :
/*
 * Semantic check required here to make sure that at least one
 * finally/catch is present.
 */
{ TryStmt res; Statement body, b; 
  TypeIdent tc;
  LocatedString i;
}
{
  "try" body=Block()
  { res = new TryStmt(body); }
  ( "catch" "(" tc=typeConstructorIdent() i=ident() ")" b=Block() 
  { res.addCatch(tc, i, b); }
  )*
  [ "finally" b=Block() { res.setFinally(b); } ]
  { return res; }
}

Statement ShortAssertStatement() :
{
  Token t;
  Expression condition, message;
  Expression call;
}
{
  t = "assert"
  condition = SideEffectFreeExpression()
  ( ":" message = SideEffectFreeExpression() 
    { call = bossa.syntax.dispatch.createCallExp(symb(t), condition, message); }
  |
    { call = bossa.syntax.dispatch.createCallExp(symb(t), condition); }
  )
  { return bossa.syntax.dispatch.createExpressionStmt(call); }
}

Statement SynchronizedStatement() :
{ Expression object; Statement body; }
{
  "synchronized" "(" object=Expression() ")" body=Block()
  { return new SynchronizedStmt(object, body); }
}
