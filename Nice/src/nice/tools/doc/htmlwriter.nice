package nice.tools.doc;

/**
   

   @author Francis Barber
*/

    /*Below is various info that could be used in the
     *construction of the method entry
     */
    //The compiler doesn't like this:  println("Syntactic return type: " + m.getSyntacticReturnType());
    //println("Return type: " + m.getReturnType());
    //println("Arity: " + m.getArity());
    //println("Type: " + m.getType());
    //println("Formal Parameters: " + m.formalParameters());

import bossa.syntax.*;
import java.util.*;
import java.text.*;
import java.io.*;

/** Comment
 */
int testMethod(double testvar) {
    return 0;
}

/**
 *Comment
 */
class HTMLWriter {
    
  /**
   * Default implementation - does nothing
   * @param d a definition to document
   * @param packageName the name of the package this definition is in.
   */
  void write(Definition d, String packageName) {
      //System.err.println("Ignoring " + d.getName() + " (class: " + d.getClass().getName() + ") with docString: "+ d.docString());
  }

  write(ClassDefinition.Class c, packageName) {
    // Here we handle classes
    
    //Initialise a FileWriter
    // Output directory for this class
    File dir = new File(outdir, packageName.replace('.', java.io.File.separator));
    if(!dir.exists() && !dir.mkdirs()) {
        System.err.println("Error creating directory structure");
    }
    
    String fileName = c.getName().toString();
    //we only want information after the last .
    //that is, nice.lang.Maybe -> Maybe
    //this should also work when "." is not found
    fileName = fileName.substring(fileName.lastIndexOf(".") + 1);
    //escape any characters that might be illegal for the filesystem
    fileName = escapeFilename(fileName);
    BufferedWriter writer = new BufferedWriter
      (new FileWriter(new File(dir, fileName + ".html")));
    
    writer.write(getHeader(c.getName().toString()));

    writer.write("<h1>Class " + htmlEncode(c.getName()) + "</h1>\n");

    //Print hierarchy
    ArrayList<ClassDefinition.Class> list = new ArrayList();
    ?ClassDefinition.Class superClass = c.getSuperClassDefinition();
    while(superClass != null) {
      list.add(superClass);
      superClass = superClass.getSuperClassDefinition();
    }
    /*This creates a nice-looking String as follows:
     *Super-Super-Class
     *   |
     *   +--Super-Class
     *         |
     *         +--Class
     */
    String hierarchy = htmlEncode(c.getName());
    for(int i = 0; i < list.size(); i++) {
      String spaces = "";
      for(int j = 0; j < (list.size()-i)*6-3; j++)
        spaces = spaces + ' ';
      hierarchy = htmlEncode(list.get(i).getName()) + "\n" + spaces + "|\n" + spaces + "+--" + hierarchy;
    }
    writer.write("<pre>\n");
    writer.write(hierarchy);
    writer.write("</pre>\n");

    //Implemented interfaces
    ClassDefinition.Interface[?] interfaces = c.getImplementedInterfaces();
    if(interfaces != null && interfaces.length > 0) {
      writer.write("<b>Implemented interfaces:</b>\n");
      writer.write("<ul>\n");
      interfaces.foreach(ClassDefinition.Interface i => 
  		         writer.write("<li>" + htmlEncode(i.getName()) + "</li>\n"));
      writer.write("</ul>\n");
    }
    
    writer.write("<p>\n");
    String comments;
    if(c.docString() != null) {
        comments = notNull(c.docString());
        
        //Note: the comments is deliberately not htmlEncoded because I want people
        //to be able to put their own html in the comment.
        Comment c = new Comment(commentStr: comments);
        List<(?String, String)> tags = c.tags;
        //write the general comment
        (?String a, String b) = tags.removeAt(0);
        writer.write("<div class='generalComment' >\n");
        writer.write(b + "\n");
        writer.write("</div\n");
        writer.write("<table>\n");
        for((?String, String) tag : tags) {
            writer.write("<tr>\n");
            (?String x, String y) = tag;
            writer.write("<td style='font-style: italic'>" x ":</td>\n");
            writer.write("<td>" y "</td>\n");
            writer.write("</tr>\n");
        }
        writer.write("</table>\n");
    }
    writer.write("</p>\n");

    writer.write(getFooter());
    writer.close();
  }

  write(GlobalVarDeclaration gv, packageName) {
    //Handle global variables
    
    //Initialise a FileWriter
    File dir = new File(outdir, packageName.replace('.',java.io.File.separator));
    if(!dir.exists() && !dir.mkdirs()) {
        System.err.println("Error creating directory structure");
    }
    
    BufferedWriter writer = new BufferedWriter
      (new FileWriter(new File(dir, "gv_" escapeFilename("" gv.getName()) ".html")));
    
    writer.write(getHeader(gv.getName().toString()));
  
    writer.write("<h1>Global Variable " + htmlEncode(gv.getName()) + "</h1>\n");
  
    writer.write(htmlEncode(gv.toString()));
  
    //Note: the comments is deliberately not htmlEncoded because I want people
    //to be able to put their own html in the comment.
    writer.write("<p>\n");
    String comments;
    if(gv.docString() != null)
        comments = notNull(gv.docString());
    else
        comments = "null";
    writer.write(comments + "\n");
    writer.write("</p>\n");
 
    writer.write(getFooter());
    writer.close();
  }
  
  write(MethodDeclaration m, packageName) {
    //Handle methods
    
    //Initialise a FileWriter
    File dir = new File(outdir, packageName.replace('.', java.io.File.separator));
    if(!dir.exists() && !dir.mkdirs()) {
        System.err.println("Error creating directory structure");
    }
    
    BufferedWriter writer = new BufferedWriter
      (new FileWriter(new File(dir, escapeFilename(getMethodFilename(m)) + ".html")));
    
    writer.write(getHeader(m.getName().toString()));
  
    writer.write("<h1>Method " + htmlEncode(m.getName()) + "</h1>\n");
  
    writer.write(htmlEncode(m.toString()));
    
    //Note: the comments is deliberately not htmlEncoded because I want people
    //to be able to put their own html in the comment.
    writer.write("<p>\n");
    String comments;
    if(m.docString() != null)
        comments = notNull(m.docString());
    else
        comments = "null";
    writer.write(comments + "\n");
    writer.write("</p>");
 
    writer.write(getFooter());
    writer.close();
  }

  write(DefaultMethodImplementation m, packageName) {
    this.write(m.getDeclaration(), packageName);
  }

  void write(bossa.modules.Package p) {
    try {
      File dir = new File(outdir, p.getName().replace('.',java.io.File.separator));
      if(!dir.exists() && !dir.mkdirs()) {
          System.err.println("Error creating directory structure");
      }
      BufferedWriter writer = new BufferedWriter
        (new FileWriter(new File(dir, "index.html")));
      writer.write(getHeader("Package " + p.getName()));
            
      //we need to separate class, methods, and global variables
      ArrayList<ClassDefinition.Class> classes = new ArrayList();
      ArrayList<MethodDeclaration> methods = new ArrayList();
      ArrayList<GlobalVarDeclaration> globalVars = new ArrayList();
      for(Definition d : p.getDefinitions().definitions()) {
        if(d instanceof ClassDefinition.Class) {
          classes.add(d);
        }
        else if(d instanceof MethodDeclaration) {
          methods.add(d);
        }
        else if(d instanceof DefaultMethodImplementation) {
          methods.add(d.getDeclaration());
        }
        else if(d instanceof GlobalVarDeclaration) {
          globalVars.add(d);
        }
        else {
          //System.err.println("Ignoring " d "\n  (type " d.getClass() ")");
        }
      }
      
      //Write classes
      if(classes.size() > 0) {
        writer.write("<b>Classes:</b>\n");
        writer.write("<ul>\n");
        for(ClassDefinition.Class c : classes) {
            String s = c.getName().toString();
            int index = s.lastIndexOf('.');
            if(index != s.length()-1)
                s = s.substring(index+1);
            writer.write("<li><a href='" escapeFilename(s) ".html'>" htmlEncode(s) "</a></li>\n");
        }
        writer.write("</ul>\n");
      }
      
      //Write methods
      if(methods.size() > 0) {
        writer.write("<b>Methods:</b>\n");
        writer.write("<ul>\n");
        for(MethodDeclaration m : methods) {
            writer.write("<li><a href='" escapeFilename(getMethodFilename(m)) ".html'>" htmlEncode(m.getName()) "</a>" +
                   ": " htmlEncode(m.getType().toString()) "</li>\n");
        }
        writer.write("</ul>\n");
      }
      
      //Write global vars
      if(globalVars.size() > 0) {
        writer.write("<b>Global Variables:</b>\n");
        writer.write("<ul>\n");
        for(GlobalVarDeclaration gv : globalVars) {
            writer.write("<li><a href='gv_" escapeFilename("" gv.getName()) ".html'>" htmlEncode(gv.getName()) "</a></li>\n");
        }
        writer.write("</ul>\n");
      }
      
      writer.write(getFooter());
      writer.close();
    } catch(IOException ioe) {
      ioe.printStackTrace();
    }
  }
  
  /** This method takes a List containing all the packages that are going to be
   * documented.  It writes a page at the root of output dir called index.html
   * containing a list of hyperlinks to all the packages.
   */
  void write(List<bossa.modules.Package> packages) {
    try {
      BufferedWriter writer = new BufferedWriter(new FileWriter(new File(outdir, "index.html")));
      writer.write(getHeader("Packages"));
      writer.write("<b>Packages:</b>\n");
      writer.write("<ul>\n");
      for(bossa.modules.Package p : packages) {
          writer.write("<li><a href='" p.getName().replace('.', "/") "/index.html'>" htmlEncode(p.getName()) "</a></li>\n");
      }
      writer.write("</ul>\n");
      writer.write(getFooter());
      writer.close();
    } catch(IOException ioe) {
      ioe.printStackTrace();
    }
  }
}

/** Converts a String that may contain characters such as '<' to one that will display
 * properly in html.  Submitted by S. Bayer to http://www.rgagnon.com/javadetails/java-0306.html,
 * although I've made some changes.
 */
String htmlEncode(String s) {
    StringBuffer sb = new StringBuffer(s.length());
    //true if last char was blank - this is for handling non-breaking spaces
    boolean lastWasBlankChar = false;

    for (int i = 0; i < s.length(); i++) {
        char c = s.charAt(i);
        if (c == ' ') {
            // blank gets extra work,
            // this solves the problem you get if you replace all
            // blanks with &nbsp;, if you do that you lose
            // word breaking
            if (lastWasBlankChar) {
                lastWasBlankChar = false;
                sb.append("&nbsp;");
            }
            else {
                lastWasBlankChar = true;
                sb.append(' ');
            }
        }
        else {
            lastWasBlankChar = false;
            // HTML Special Chars
            if (c == '"')
                sb.append("&quot;");
            else if (c == '&')
                sb.append("&amp;");
            else if (c == '<')
                sb.append("&lt;");
            else if (c == '>')
                sb.append("&gt;");
            else if (c == '\n')
                // Handle Newline
                sb.append("&lt;br/&gt;");
            else {
                //char and int are not related in nice, so we can't do a direct cast
                //hence, we use int(c) instead of (int)c
                int ci = int(c);
                /*This was originally 160 in S. Bayer version, but I couldn't see the sense of that
                 *so I changed it to 128, as 127 is the maximum value of an ascii character
                 */
                if(ci < 128)
                    // nothing special only 7 Bit
                    sb.append(c);
                else {
                    // Not 7 Bit use the unicode system
                    sb.append("&#");
                    sb.append(ci);
                    sb.append(';');
                }
            }
        }
    }
    return sb.toString();
}

/** Convenience method that converts a LocatedString to a String and then htmlEncodes it.
 * @param s the string to encode
 */
String htmlEncode(LocatedString s) {
    return htmlEncode(s.toString());
}

/** Returns a string containing everything required up to and including the <body> tag
 * @param title a String to be displayed in the browser's title bar
 * @param depth the number of levels down we are (required for linking the stylesheet)
 */
String getHeader(String title, int depth) {
  //we could also include some kind of visible header as well
  
  //if depth is 2, this string will contain "../../" etc, etc
  String depthstr = "";
  for(int i = 0; i < depth; i++) {
      depthstr += "../";
  }
  
  //Create a DateFormatter and set the time zone
  DateFormat df = new SimpleDateFormat("dd/MM/yyyy 'at' HH:mm:ss z");
  df.setTimeZone(TimeZone.getTimeZone("GMT"));
  return
  "<html>\n" +
  "<head>\n" + 
  "<!-- Generated by nicedoc on "  df.format(new Date())  " -->\n" +
  "\t<title>" title "</title>\n" +
  "\t<link rel=\"stylesheet\" type=\"text/css\" href=\"" depthstr "main.css\" />\n" +
  "</head>\n" +
  "<body>\n";
}

String getHeader(String title) {
    return getHeader(title, 0);
}

/** Returns a string containing everything after and including the </body> tag
 */
String getFooter() {
  //we could also include other information here
  return
  "</body>\n" +
  "</html>\n";
}

/** Methods can be overloaded - we can't just use the method name as a file name.
 * This method returns a file name based upon the method name and its arguments.
 */
String getMethodFilename(MethodDeclaration md) {
     return md.getName().toString() + md.getType().toString().hashCode();
}

/**
 * Checks a filename to make sure it doesn't contain funny characters.
 */
String escapeFilename(String filename) {
    char[] chars = filename.toCharArray();
    StringBuffer buf = new StringBuffer();
    for(char c : chars) {
        if(!Character.isLetterOrDigit(c)) {
            buf.append('$');
            buf.append(hexEncode(int(c)));
        }
        else {
            buf.append(c);
        }
    }
    return buf.toString();
}

String hexEncode(int i) {
    String num = Integer.toHexString(i);
    for(int pad = num.length(); pad < 4; pad++)
        num = "0" + num;
    return num.toUpperCase();
}