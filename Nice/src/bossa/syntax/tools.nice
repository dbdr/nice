/**************************************************************************/
/*                                N I C E                                 */
/*             A high-level object-oriented research language             */
/*                        (c) Daniel Bonniot 2001                         */
/*                                                                        */
/*  This program is free software; you can redistribute it and/or modify  */
/*  it under the terms of the GNU General Public License as published by  */
/*  the Free Software Foundation; either version 2 of the License, or     */
/*  (at your option) any later version.                                   */
/*                                                                        */
/**************************************************************************/

package bossa.syntax;

/**
   Helper functions.

   @version $Date$
   @author Daniel Bonniot (bonniot@users.sourceforge.net)
 */

?LocatedString identString(?Expression);
identString(e) = null;
identString(e@IdentExp) = e.ident;
identString(e@SymbolExp) = e.getName();

boolean isCallTo(CallExp e, String name) 
{
  ?LocatedString f = identString(e.function);
  if (f == null)
    return false;
  else
    return f.toString().equals(name);
}

boolean isNullExp(Expression);
isNullExp(e@Expression) = false;
isNullExp(e@NullExp) = true;

?MonoSymbol localVariable(Expression);
localVariable(e@Expression) = null;
localVariable(e@SymbolExp)
{
  if (e.getSymbol() instanceof bossa.syntax.MonoSymbol)
    return cast(e.getSymbol());
  return null;
}
localVariable(e@AssignExp) = localVariable(notNull(e.to));

mlsub.typing.Monotype makeSure(mlsub.typing.Monotype m) = 
  notNull(bossa.syntax.Monotype.sure(nice.tools.code.Types.rawType(m)));

mlsub.typing.Monotype makeUnsure(mlsub.typing.Monotype m) = 
  notNull(bossa.syntax.Monotype.maybe(nice.tools.code.Types.rawType(m)));

/* 
   Make sure that the error is attached to a location.
   If not, located it a the given located object (which should be a close 
   container of the entity creating the error).
*/
bossa.util.UserError ensureLocated(bossa.util.UserError e, 
				   bossa.util.Located loc)
{
  if (e.responsible == null)
    e.responsible = loc;
  return e;
}

/****************************************************************
 * Temporary: this should be solved when AST classes are written 
 * in Nice, with precise types for the fields.
 ****************************************************************/

LocatedString name(VarSymbol) = native VarSymbol.name;
mlsub.typing.Polytype getType(Expression) = 
  native mlsub.typing.Polytype Expression.getType();
Statement statement(StatementExp) = native StatementExp.statement;
mlsub.typing.Monotype type(MonoSymbol) = native MonoSymbol.type;
GlobalTypeScope getGlobalTypeScope() = native GlobalTypeScope Node.getGlobalTypeScope();
List<TryStmt.Catch> catches(TryStmt) = native TryStmt.catches;
List<Block.LocalDeclaration> locals(Block) = native Block.locals;
?Statement[] statements(Block) = native Block.statements;
?gnu.bytecode.ClassType staticClass(Arguments) = native gnu.bytecode.ClassType Arguments.staticClass();
List<VarSymbol> findJavaMethods(?gnu.bytecode.ClassType, String, int) = native List JavaClasses.findJavaMethods(gnu.bytecode.ClassType,java.lang.String,int);
List<VarSymbol> findJavaMethods(?gnu.bytecode.ClassType, String) = native List JavaClasses.findJavaMethods(gnu.bytecode.ClassType,java.lang.String);
OverloadedSymbolExp newOverloadedSymbolExp(List<bossa.syntax.VarSymbol>, ?bossa.syntax.LocatedString) = native new OverloadedSymbolExp(List,LocatedString);
Arguments arguments(CallExp) = native CallExp.arguments;

// Retypings needed since java types are not strict.

Block newBlock(?Statement[] statements) = native new Block(Statement[]);
mlsub.typing.Polytype boolPolytype() = native PrimitiveType.boolPolytype;

// Local Variables:
// nice-xprogram: "nicec -d \"$HOME/Nice/classes\" --sourcepath=\"$HOME/Nice/src\" --classpath=\"$HOME/Nice/classes\""
// End:
