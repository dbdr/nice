<?xml version="1.0" standalone="no"?>
<!DOCTYPE book PUBLIC '-//OASIS//DTD DocBook XML V4.1.2//EN' 		     
'http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd' [ 
<!ENTITY nice "Nice">
<!ENTITY java "Java">
<!ENTITY NULL "<literal>null</literal>">
<!ENTITY LT "<literal>&lt;</literal>">
<!ENTITY GT "<literal>&gt;</literal>">
<!ENTITY LBRACE "<literal>{</literal>">
<!ENTITY RBRACE "<literal>}</literal>">
]>

<book>
  <bookinfo>
    <title>The Nice user's manual</title>
    <author><firstname>Daniel</firstname><surname>Bonniot</surname></author>
    <author><firstname>Bryn</firstname><surname>Keller</surname></author>
    <copyright><year>2003</year><holder>Daniel Bonniot</holder></copyright>
  </bookinfo>
  <preface><title>Foreword</title>
    <para>
      This manual describes the Nice programming language.
      It is currently under redaction, which means that many aspects of 
      the language are absent from it, or that some sections are mostly empty.
      During this time, it is recommended to read also the 
      <ulink url="http://nice.sf.net/language.html">Nice tutorial</ulink>, 
      which contains lots of additional information.
      Both documents currently assume some knowledge of Java, or at least
      of an object oriented language.
    </para>

    <para>
      The authors of this manual are Bryn Keller and Daniel Bonniot.
    </para>
  </preface>

  <chapter><title>Philosophy</title>
    <para>
      <blockquote>
	<attribution>Alan J. Perlis</attribution>
	<para>
	  A language that doesn't affect the way you think about programming, 
	  is not worth knowing.
	</para>
      </blockquote>

      The Nice programming language is a new object-oriented programming 
      language based on Java. 
      It incorporates features from functional programming, 
      and puts into practice state-of-the-art results from academic research. 
      This results in more expressivity, modularity and safety.
    </para>

    <variablelist>
      <varlistentry><term>Safety</term>
	<listitem>
	  <para>
	    Nice detects more errors during compilation than existing 
	    object-oriented languages (null pointer accesses, 
	    casts exceptions).
	    This means that programs written in Nice never throw the infamous
	    <literal>NullPointerException</literal> nor 
	    <literal>ClassCastException</literal>.
	    This aspect is developed in more details in 
	    <ulink url="http://nice.sf.net/safety.html">this article</ulink>.
	  </para>
	</listitem>
      </varlistentry>

      <varlistentry><term>Modularity</term><listitem><para>
	    In object-oriented languages, it is possible to add a new class 
	    to an existing class hierarchy. 
	    In Nice, it is also possible to add <emphasis>methods</emphasis> to 
	    existing classes without modifying their source file. 
	    This is a special case of <emphasis>multi-methods</emphasis>.
	  </para>
	</listitem>
      </varlistentry>

      <varlistentry><term>Expressivity</term><listitem><para>
	    Many repetitive programming tasks can be
	    avoided by using Nice's advanced features. 
	    Ever got bored
	    of writing tons of loops, casts, overloaded methods with default
	    values, ... ?
	  </para>
	</listitem>
      </varlistentry>
    </variablelist>

  </chapter>

  <chapter id = "packages" ><title>Packages</title>
    <para>
     A <firstterm>package</firstterm> is a group of related classes, functions,
     methods, and variables. You can declare that all the code in a particular
     <literal>.nice</literal> file belongs to a certain package with the 
     declaration:
    </para>
    <para>
      <literal>package <replaceable>package-name</replaceable>;</literal>
    </para>
    <para>
     To make use of all the public entities from another Nice package,
     use the <literal>import</literal> statement:
    </para>
    <para>
      <literal>import <replaceable>package-name</replaceable>;</literal>
    </para>
    <para>
      Note that this is somewhat different from Java packages.
      In Java, a class can be used independantly of its declaring package.
      In Nice methods can be declared outside classes, so importing
      the whole package is important to know the methods available for a
      given class.
      This probably implies that Nice projects should be designed with
      smaller, self-contained packages that Java projects.
    </para>
    <para>
      Therefore, only whole packages can be imported.
      It is not possible to import a single class.
      Likewise, there is no need to 
      include a <literal>.*</literal> after the package name as in Java. 
      In fact, using <literal>.*</literal> indicates that you wish to import 
      the contents of a Java package rather than a Nice package. 
      See the section on <link linkend="importJava">Java imports</link> 
      for details.
    </para>
  </chapter>

  <chapter><title>Classes</title>
    <section><title>Declaring a class</title>
      <para>
      </para>
    </section>

    <section><title>Fields</title>
      <para>
	The main component of a class is the list of its fields.
	A field is a variable that is attached to each instance of
	the class. It has a type, a name, and optionally a default 
	initial value.
	The syntax for field declaration is:
	<programlisting>
	  <type><replaceable>type</replaceable></type> <replaceable>field-name</replaceable><optional> = <replaceable>initial-value</replaceable></optional>;
	</programlisting>
	If no default value is given, then every call to the constructor
	must specify the value for this field.
	If it is given, a call to the constructor call still override
	it with a different value, in which case the default value is
	not computed (this fact is only important if it has side effects).
      </para>
    </section>

    <section id="constructor"><title>Constructors</title>
      <para>
	There is no way to define a constructor in Nice. The reason is that
	in languages that support them, most constructors just take 
	as parameters the initial values for the fields and assign them
	to the new object. This simple but tedious task has to be done
	by the programmer for each class definition.
	In Nice, such a constructor is generated automatically by the compiler.
	It is called the automatic constructor. 
	It takes the names of the fields as named arguments, 
	and those who have an initial value are optional.
	The constructor is called <literal>new</literal> followed by
	the name of the class to create.
      </para>

      <example><title>Class definition and creations using the automatic constructor</title>
	<programlisting lang="nice">
class Car
{
  String brand;
  String model;
  int numberOfWheels = 4;
  int numberOfDrivingWheels = 2;
}

void test()
{
  Car renault5 = new Car(brand: "Renault", model: "Cinq");
  Car jeep = new Car(brand: "Jeep", model: "Some jeep", numberOfDrivingWheels: 4);
}</programlisting>
      </example>
      
      <para>
	It is required to include the names of the fields in the call
	to the constructor. 
	This is important for two reasons.
	First, it is easy to understand what the arguments represent, without looking at the
	class definition.
	Second, it does not require some arbitrary ordering of the fields
	<footnote>
	  <para>
	    A problem happens in Java when the order of the parameters 
	    of a constructor should be changed.
	    This requires modifying all the call sites, which is at best tedious
	    and error-prone, at worse impossible (when writing a library used by others).
	    When the order is changed and some caller are not modified,
	    the following happens:
	    if the exchanged parameters have incompatible types, 
	    the compilation of the caller will fail; 
	    otherwise the code might even compile and produce
	    wrong results at runtime. 
	    There is no simple way to solve this issue in Java.
	    Using names in the call to the constructor in Nice is the solution.
	  </para>
	</footnote>. Because the names of the fields are used, they can be given
	in any order.
      </para>

      <para>
	If a behaviour different than that of the automatic constructor is 
	needed, it is possible to define
	a creation <link linkend="function">function</link> that can perform 
	the task, calling the constructor to create the object and 
	initialize the fields.
	This function should by convention be called <literal>create</literal>
	suffixed by the name of the class to create.
      </para>
    </section>

    <section id = "parametricClasses" ><title>Parametric classes</title>
      <para>
        A powerful feature of Nice is the ability to define 
        <firstterm>parametric classes</firstterm>.
        Parametric classes are like templates in C++, or similar constructs in
        various functional languages. Programming with parametric classes is
        sometimes called <firstterm>generic programming</firstterm>.
      </para>      
      <para>
        A parametric (or parameterized) class is simply a class which has a 
        parameter. In this case the parameter is a <emphasis>type</emphasis>
        rather than a value. You can consider a parametric class as a family
        of related classes, all of which have the same behavior and structure
        except for the part that is parameterized. A common case where this
        is useful is in data structures.
      </para>
  <example><title>Simple Java Collection</title>
	<programlisting lang="java">
class Stack
{
  List contents = new LinkedList();
  void push(Object o) 
  {
    contents.add(o);
  }
  
  //... omitted methods

  public static void main(String[] args)
  {
    Stack st = new Stack();
    st.push("Test");
    Integer num = (Integer)st.pop(); // Runtime error
  }
}
</programlisting>
      </example>
      <para>
        There is a big type safety problem here.
        We pushed a String on to the stack, and then tried to pop it off into
        an Integer, resulting in an exception at runtime. Parametric classes
        can solve this problem.
      </para>
  <example><title>Simple Nice Collection</title>
	<programlisting lang="nice"><![CDATA[
class Stack<T>
{
  List<T> contents = new LinkedList();
  void push(T t) 
  {
    contents.add(t);
  }
  
  //... omitted methods

}

void main(String[] args)
{
  Stack<String> st = new Stack();
  st.push("Test");
  Integer num = st.pop(); // Compile time error!
}
]]></programlisting>
      </example>
      <para>
        In the Nice version, we have parameterized <classname>Stack</classname> by 
        a type <type>T</type>. Essentially, <type>Stack&lt;T&gt;</type> 
        is a recipe for the compiler that tells it how to create a 
	<classname>Stack</classname> that 
        works for any given type. So now the compiler knows that we only mean 
        for Strings to go into our stack, and it reports an error when we
        write code that expects an <type>Integer</type> to come out of our 
        <type>Stack&lt;String&gt;</type>. 
      </para>
    </section>

    <section><title>Functions and methods</title>
      <para>
        Nice makes a simple distinction between functions and methods:
        Methods can be overridden and specialized, and functions cannot. A 
        function is just a reusable piece of code, much like a procedure
        in a language like Pascal or C, whereas a method may use different
        code depending on the types of its arguments, like methods in most
        object-oriented languages. We use the term <firstterm>functionals</firstterm>
        when we want to refer to both functions and methods without making
        a distinction.
      </para>
      <para>        
        Functions and methods in Nice have some important differences from
        other languages you may be used to - they are <firstterm>first class</firstterm>,
        which means they can be passed as arguments to other functionals, or
        used as return values from functionals.
      </para>
    </section>
  </chapter>

  <chapter id="function"><title>Functions</title>
    <section><title>Declaration</title>
      <para>
       Functions are declared like this:
      </para>

      <para>
       <literal>
       <optional><replaceable>type-parameters</replaceable></optional> 
       <replaceable>return-type</replaceable> 
       <replaceable>function-name</replaceable>
       (<optional><replaceable>parameters</replaceable></optional>) 
       &LBRACE; <replaceable>body</replaceable> &RBRACE;
       </literal>
      </para>

      <para>
       There is a also a simpler syntax for functions whose body
       consists of a single expression:
      </para>

      <para>
       <literal>
       <optional><replaceable>type-parameters</replaceable></optional> 
       <replaceable>return-type</replaceable> 
       <replaceable>function-name</replaceable>
       (<optional><replaceable>parameters</replaceable></optional>) 
       = <replaceable>expression</replaceable>;
       </literal>
      </para>

      
    </section>

    <section id="namedParameters"><title>Named parameters</title>
      <para>
	When <link linkend="call">calling</link> a function 
	(or a <link linkend="method">method</link>)
	it is possible to specify the name of a parameter, followed by
	<literal>:</literal> before the value given to that parameter.
	Named parameters can be given in any order.
	This is useful when writting the call, because one does not
	need to remember the order of the arguments, but only their names.
	When reading the code, it is much easier to understand
	what each parameter is, provided the name was well chosen.
	
	<example>
	  <title>Using named parameters</title>
	  <programlisting lang="nice">
void copy(File from, File to) { ... }
...
copy(from: f1, to: f2);
copy(to: f3, from: f4);</programlisting>
	</example>
	
	It is of course still possible to omit the names of the parameters,
	in which case the arguments must be given in the order of the 
	declaration.
      </para>
    </section>

    <section id="optionalParameters"><title>Optional parameters</title>
      <para>
	Many functions have some parameters that are used most of the time
	with the same value. In Nice, a parameter can be given a default
	value. It can then be omitted when calling the function and the
	default value is used. 

	<example>
	  <title>Using named and optional parameters</title>
	  <programlisting lang="nice">
void copy(File from, File to, int bufferSize = 1000) { ... }
...
copy(from: f1, to: f2); // with a buffer size of 1000
copy(from: f1, to: f2, bufferSize: 4000);</programlisting>
	</example>

	In the function definition, the optional parameters should be 
	listed after the required parameters. This is needed to allow 
	calls that do not name the arguments and want to use the default
	values for the optional parameters.
      </para>
      <para>
       Note that the optional values of parameters can be based on other
       parameters, for example:
      </para>
      <para>
       <literal> T[] slice(T[] array, int from = 0, 
       int to = array.length - 1);</literal>
      </para>
    </section>
  </chapter>

  <chapter id="method"><title>Methods</title>
    <section><title>Declaring methods</title>
      <para>
        Method declaration takes the following form:
      </para>

      <para>
        <literal>
        <optional><replaceable>type-parameters</replaceable></optional> 
        <replaceable>return-type</replaceable> 
        <replaceable>method-name</replaceable>
        (<optional><replaceable>parameters</replaceable></optional>);
        </literal>
      </para>

      <para>
        The syntax is very similar to that for functions, except that
        no body is provided. 
	Note that in Nice, methods can be defined within the
        body of a class definition, or outside of it - both are identical
        for the compiler's purposes.
      </para>
    </section>
    <section><title>Implementing methods</title>
      <para>
        In comparison to their declarations, method implementations are
        quite terse:
      </para>

      <para>
        <literal>
	<replaceable>method-name</replaceable>
        (<optional><replaceable>arguments</replaceable></optional>)
	&LBRACE; body &RBRACE;
        </literal>
      </para>

      <para>Like functions, there is another form for single expressions:</para>

      <para>
        <literal>
	<replaceable>method-name</replaceable>
        (<optional><replaceable>arguments</replaceable></optional>)
	= <replaceable>expression</replaceable>;
        </literal>
      </para>

      <para>
        The <optional><replaceable>arguments</replaceable></optional>
	consist of names, and optionally types, of the form
      </para>

      <para>
        <literal><replaceable>name</replaceable></literal>
      </para>

      <para>or</para>

      <para>
        <literal><replaceable>name</replaceable>@<replaceable>class-name</replaceable></literal>
      </para>

      <para>
        The <literal>@<replaceable>class-name</replaceable></literal> 
	is used to specialize the method on that argument. 
	An example should make the difference clear. Also note the
        use of both the block- and expression-style methods.
      </para>

      <example>
        <title>Method Implementation</title>
        <programlisting lang="nice">
class Vehicle {}
class Motorcycle extends Vehicle {}
class Car extends Vehicle {}

//Declare method
int numberOfWheels(Vehicle vehicle);

//Default implementation
numberOfWheels(vehicle) 
{
    throw new Exception("Unknown number of wheels!");
}

//Specialize for Cars
numberOfWheels(car@Car)
{ 
    return 4;
}

//Specialize for Motorcycles
numberOfWheels(mc@Motorcycle) = 2;

        </programlisting>
      </example>

      <para id="exactMatching">
       It is also possible to specialize a method on the 
       <emphasis>exact</emphasis> class of the argument. Then the method will
       apply to arguments which match the class exactly, and 
       <emphasis>not</emphasis> to an argument which is a subclass of the class
       specified. The syntax for exact matching is:
      </para>
      <para>
       <literal><replaceable>name</replaceable>#<replaceable>class-name</replaceable></literal>
      </para>

      <para>
        There is an <link linkend="ex:copy">example</link> where 
	exact matching is required to
	type-check a method with a precise polymorphic type.
      </para>

      <para>     
       When specializing a method with type parameters, it is not necessary 
       or possible to restate the type parameters in the method implementation.
       However, if you need access to the type parameters as in the example
       below, use the syntax:
      </para>
      <para>
        <literal>
	&LT;<replaceable>type-parameters</replaceable>&GT;
	<replaceable>method-name</replaceable>
        (<optional><replaceable>arguments</replaceable></optional>)
	&LBRACE; body &RBRACE;
        </literal>
      </para>
      <example>
       <title>Using Type Parameters in Method Implementations</title>
       <programlisting lang="nice"><![CDATA[

//Method definition
<T> T lastItem(Collection<T> coll);


/* This version is incorrect because the type parameter T is not in scope:

lastItem(coll)
{
  Iterator<T> it = coll.iterator();
  //...
}
*/

// This one will work correctly:
<T> lastItem(coll)
{
  Iterator<T> = coll.iterator();
  //...
}
]]></programlisting>
      </example>
        <para>
         Note that it is not possible to dispatch a method call on an array 
         type, nor to specialize a method on the subtype of a type parameter. 
         This means that methods of the form:
        </para>
        <para>
         <literal><![CDATA[foo(string@Collection<String>){}]]></literal>
        </para>
        <para>or</para>
        <para>
         <literal><![CDATA[foo(array@String[]){}]]></literal>
        </para>
        <para>
         are not valid. You should use respectively the specializers
	 <literal>@Collection</literal> and 
	 <literal>@Array</literal> instead.
        </para>        
       
    </section>
    <section><title>Value Dispatch</title>
      <para>
            In addition to choosing a method based on the classes of the
            arguments, it's even possible to override a method based on the
            actual values of the arguments. Currently this feature works 
            with integers, booleans, and strings. This feature makes it
            convenient to code things that might otherwise have required
            switch statements or nested if/else statements. Using value 
            dispatch can be more flexible than switch or if/else statements,
            because you can always add new alternatives conveniently by
            just adding a new method implementation.
      </para>
	<example>
	<title>Value Dispatch</title>
	<programlisting lang="nice"><![CDATA[
String digitToString(int digit, String language)
  requires digit < 10 && digit >= 0;

digitToString(digit, language) { throw new Exception("Couldn't convert " + digit + " to language " + language); }

digitToString(1, "english") = "one";
digitToString(2, "english") = "two";
digitToString(3, "english") = "three";

digitToString(1, "french") = "un";
digitToString(2, "french") = "deux";
digitToString(3, "french") = "trois";

String booleanToYesNo(boolean bool);

booleanToYesNo(true) = "yes";
booleanToYesNo(false) = "no";
]]></programlisting>
      </example>

    </section>
    <section><title>Optional parameters</title>
      <para>
	Methods, like functions, can have optional parameters.
	They are declared in the method declaration, using the
	<link linkend="optionalParameters">same syntax as in the case 
	  of functions</link>.
	Method implementations must still bind all parameters,
	including the optional ones, and can dispatch on them.
      </para>
    </section>
  </chapter>

  <chapter id="contracts"><title>Assertions and contracts</title>
    <section><title>Syntax</title>
      <para>
        The syntax for assertions is the same as in Java (since 1.4).
        Assertions are statements of the following form:
	<literal>assert &lt;boolean expression&gt; : &lt;error message&gt;</literal>.
        The &lt;error message&gt; is optional.
      </para>
      <para>
        Preconditions are introduced with the <literal>requires</literal>
	keyword, and postconditions with the <literal>ensures</literal>
	keyword. If there are several conditions in either section,
	they must be separated by commas. 
	For convenience, an optional trailing comma is accepted.
      </para>
      <para>
        In a method returning a value, the special variable name
	<literal>result</literal> can be used to refer to the result value
	of the method in the postcondition. 
	The <literal>old</literal> to refer to values before the 
	execution of the method is not supported yet.
      </para>
      <para>
	For example, we can define the contract of the add method
	of a <type>Buffer</type> interface.
	It is guaranteed that <literal>isEmpty</literal> returns 
	<literal>true</literal>	if, and only if, 
	<literal>size</literal> returns <literal>0</literal>.
	The <literal>add</literal> method can be called only when the buffer
	is not full. It is guaranteed to make the buffer non-empty, and
	to increase the size by one.

	<example>
	<title>Contracts</title>
	<programlisting lang="nice"><![CDATA[
interface Buffer<Elem>
{
  int size();

  boolean isFull();
  boolean isEmpty() ensures result == (size() == 0);

  void add(Elem element)
    requires
         !isfull() : "buffer must not be not full"  // A comma here is optional
    ensures
         !isEmpty() : "buffer must not be empty",   // Note the comma
         size() == old(size()) + 1 : "count inc";
}]]></programlisting>
      </example>
      
      </para>
    </section>

    <section id="enablingAssertions"><title>Enabling assertions and contract checking</title>
      <para>
        By default, assertions and contracts are not used at runtime.
	They are discarded by the just-in-time compiler, and should
	cause no slow-down.
	They can be turned on when starting the JVM.
      </para>

      <section><title>JDK 1.4 and later</title>
        <para>
	  The mechanism is the same as for Java assertions. 
	  Checking can be enabled at runtime with 
	  <userinput>java -ea ...</userinput>.
	</para>
      </section>

      <section><title>JDK 1.1, 1.2 and 1.3</title>
        <para>
          Contrarily to Java, Nice produces programs with assertions that can 
	  be run on earlier JDKs. Therefore there is no problem to distribute 
	  Nice programs using assertions and contracts. Since java will not 
	  know the <literal>-ea</literal> command line option, they are 
	  disabled by default. You can enable them with 
	  <userinput>java -Dassertions=true ...</userinput>.
	</para>
      </section>
    </section>

  </chapter>

  <chapter><title>Statements</title>
    <section id="localVars"><title>Local variables and constants</title>
     <para>
       Local variables may be defined with the <literal>var</literal> keyword.
       Here is the syntax:
     </para>
     <para>
      <literal>var <optional><replaceable>type</replaceable></optional> 
      <replaceable>variable-name</replaceable> 
      <optional>= <replaceable>initial-value</replaceable></optional>
      ;
      </literal>
     </para>
     <para>
       For local variables (not <link linkend = "packageVars">package 
       variables</link>), the Nice also accepts the Java style of 
       declaration:
     </para> 
     <para>
      <literal>
      <replaceable>type</replaceable> 
      <replaceable>variable-name</replaceable> 
      <optional>= <replaceable>initial-value</replaceable></optional>
      ;
      </literal>
     </para>
     <para>
      Constants are declared with "let":
     </para>
     <para>
      <literal>let <optional><replaceable>type</replaceable></optional> 
      <replaceable>variable-name</replaceable> 
      <optional>= <replaceable>initial-value</replaceable></optional>
      ;
      </literal>
     </para>
     <para>
       If the variable or constant is of a simple type (i.e., not a 
       <link linkend="parametricClasses">parameterized type</link>), then it is
       not necessary to specify the type yourself, the compiler can infer
       the correct type automatically.
     </para>
    </section>
    <section id="packageVars"><title>Package variables and constants</title>
     <para>
      Since Nice uses <link linkend="packages">packages</link> as its largest
      conceptual unit, variable and constant declarations may appear 
      outside class definitions, and are useful in the same way that 
      static variables in Java are. Package variables are introduced
      with <literal>var</literal>, and package constants with
      <literal>let</literal>. The type must be specified, since it is
      a useful documentation.
     </para>
    </section>
    <section id="forStatements"><title>Extended <literal>for</literal> statement</title>
     <para>
      Nice supports the traditional <literal>for</literal> loop, with the same
      syntax as in Java. In addition, it provides a form that allows iterating 
      over the items in a sequence like C#'s <literal>foreach</literal>.
      Here is the syntax:
     </para>
     <para>
      <literal>for (
      <replaceable>item-type</replaceable> 
      <replaceable>variable-name</replaceable> : 
      <replaceable>container</replaceable> ) { <replaceable>body</replaceable> }
      </literal>
     </para>
     <para>
      Currently, this version of the <literal>for</literal> statement can be
      used to iterate over <literal>Collection</literal>s, arrays, 
      <literal>String</literal>s, and <literal>StringBuffer</literal>s.
     </para>
     <para>
      <example><title>Extended <literal>for</literal> statement</title>
	<programlisting lang="nice">
let String[] strings = ["one", "two", "three"];
for(String s : strings)
{
  println(s);
}
</programlisting>
      </example>
     </para>
    </section>
    <section id="localFunctions"><title>Local functions</title>
      <para>
	Local functions are similar to toplevel functions, 
        except that they are defined inside another function or method,
        and therefore only usable in that scope.
	They can refer to local variables from their context.
      </para>

      <example><title>Local function</title>
	<programlisting lang="nice">
Window createMyWindow()
{
  Window w = new Window();
  
  void addMyButton(String text)
  {
    w.addButton(new Button(text));
  }

  addMyButton("One");
  addMyButton("Two");
  addMyButton("Three");
}</programlisting>
      </example>

    </section>

  </chapter>

  <chapter><title>Expressions</title>
    <section id="call"><title>Function calls</title>
      <para>
        A call is usually of the form <literal>f(e1, ..., en)</literal>.
	<literal>f</literal> can be a function name, a method name, or
	more generally any expression which has a functional type
	(for instance, a local parameter).
	<literal>e1, ..., en</literal> is the list of arguments to the 
	function. Arguments can optionally be 
	<link linkend="namedParameters">named</link>.
      </para>

      <para>
        In many object-oriented languages, methods are called with the
	syntax <literal>e1.f(e2, ..., en)</literal>. This syntax is also 
	accepted in Nice, and is completely equivalent to the previous one.
	In particular, <literal>e.f</literal> can be used to retrieve the value
	of the field <literal>f</literal> in the object <literal>e</literal>
	<footnote>
	  <para>
	    A consequence of these rules is that if the field 
	    <literal>f</literal> contains a function, it must be called with
	    <literal>(e.f)(e1, ..., en)</literal>.
	  </para>
	</footnote>.
      </para>

      <para>
        It is possible that a name refers to several unrelated functions.
	In that case, the types (and if applicable names)
	of the arguments are used to try to disambiguate which function
	must be called. If only one function is applicable, it is called.
	Moreoever, if several functions are applicable, but one has a more
	restricted domain than all the others, it is chosen
	<footnote>
	  <para>
	    For instance, suppose two functions 
	    <literal><![CDATA[<T> void foo(Collection<T>)]]></literal> and 
	    <literal><![CDATA[<T> void foo(List<T>)]]></literal> are declared, 
	    and <literal>aList</literal> is an expression of static type 
	    <type>List</type>.
	    The expression <literal>foo(aList)</literal> will result in
	    calling the second <literal>foo</literal> function, 
	    because <type>List</type>
	    is a subclass of <type>Collection</type>.
	  </para>
	</footnote>.
	Otherwise, the compiler reports an ambiguity error.
      </para>
    </section>

    <section><title>Tuples</title>
      <para>
       A tuple is a groupment of several values in a single expression.
       For instance, <literal>("Hello", 2*3, x.toString())</literal> 
       is a tuple whose elements are the string <literal>"Hello"</literal>,
       the number <literal>6</literal> and the string representation of 
       <literal>x</literal>. 
       The type of a tuple is a <emphasis>tuple type</emphasis>, 
       whose elements are the types of the corresponding values.
       The type of our example tuple is 
       <literal>(String, int, String)</literal>. 
      </para>

      <para>
       A tuple can be of any length. In english, a tuple of two elements
       is called a couple. For an arbitrary number n, a tuple of n
       elements is called a n-tuple.
      </para>

      <para>
       Tuple types are covariant, so a couple of <type>int</type>s 
       can be used where a couple of <type>long</type>s is expected.
      </para>

      <para>
       A funny feature is that swapping two variables can be done without a 
       temporary variable, using tuples: <literal>(x, y) = (y, x)</literal>.
       An important use of tuples is to allow a function or a method 
       to return several values. <xref linkend="tupleEx" /> defines
       and uses the function <literal>minMax</literal>, which takes 
       two integers, and returns the smallest first, the biggest second.
      </para>

      <example id="tupleEx">
	<title>Function returning several values using a tuple</title>
	<programlisting lang="nice"><![CDATA[
(int, int) minMax(int x, int y) = x < y ? (x, y) : (y, x);

void printTuple((int, int) tuple)
{
  /** Declare two local variables, and assign to each the corresponding value
      in the tuple.
  */
  (int x, int y) = tuple;

  println("(" + x + ", " + y + ")");
}

void main(String[] args)
{
  printTuple(minMax(14, 17));
  printTuple(minMax(42, 41));
}
]]></programlisting>
      </example>

    </section>

    <section id="anonymousFunctions"><title>Anonymous functions</title>
      <para>
       Since Nice allows functions and methods to be passed as arguments, and
       returned as results, it is convenient to allow small anonymous functions
       to be defined at the same point in the program in which they are used,
       similar to the use of anonymous classes in Java.       
      </para>
      <para>
       The syntax of anonymous functions is:
      </para>
      <para>
        <literal>
        (<optional><replaceable>parameters</replaceable></optional>)
        => &LBRACE; body &RBRACE;
        </literal>
      </para>
      <para>
       As with the other functionals, there is also a single-expression format:
      </para>
      <para>
        <literal>
	(<optional><replaceable>parameters</replaceable></optional>)
	=> <replaceable>expression</replaceable>
        </literal>
      </para>
      <para>
       The brackets around the parameters are optional if there is only one
       parameter.
      </para>
      <para>
       The return type of an anonymous function is automatically determined by 
       the compiler using a process called 
       <firstterm>type inference</firstterm>, so it is not necessary or possible
       to specify it.
      </para>
<example>
<title>Using Anonymous Functions</title>
<programlisting lang="nice"><![CDATA[
String concat(Collection<String> strings) 
{
    StringBuffer buff = new StringBuffer();
    strings.foreach(String s =>  {
        buff.append(s);
    });
    return buff.toString()
}

var String[] numberStrings = [1,2,3,4,5].map(int num => String.valueOf(num));

//Another way of defining "concat"
String concat2(Collection<String> strings)
{
  return strings.foldLeft((String accum, String s) => accum + s, "");
}
]]></programlisting>
</example>
    </section>

    <section id="conversion"><title>Conversion between numeric primitive types</title>
      <para>
	The numeric primitive types are, from the largest to the smallest:
	<type>double, float, long, int, short, byte</type>, 
	and <type>char</type> which is smaller than 
	<type>int</type> but incomparable with <type>short</type>.
	Conversion from a smaller to a larger type is automatic.
	Conversion from a larger to a smaller type must be done explicitely,
	since they can lose information about the magnitude of the value.
      </para>
      <para>
	The explicit conversion is done by calling a special function, 
	whose name is the target type. 
	If <replaceable>e</replaceable> is a numeric expression,
	and <replaceable>type</replaceable> one of the numeric types, then 
	<literal><replaceable>type</replaceable>(<replaceable>e</replaceable>)</literal> 
	will convert the value of the expression, so that it is
	represented as a value in <replaceable>type</replaceable>.
	This is equivalent to the 
	<literal>(<replaceable>type</replaceable>) e</literal>
	syntax in &java;.
      </para>
      <para>
        For instance, here is code to read
	characters from a <type>Reader</type>, whose 
	<literal>read</literal> method returns an <type>int</type> 
	(<literal>-1</literal> meaning that the end of stream has been 
	reached):

	<example><title>Converting a value of a primitive type</title>
	<programlisting lang="nice">
BufferedReader r = new BufferedReader(new InputStreamReader(System.in));

int v;
while ((v = r.read()) != -1) {
  char c = char(v);
  ... // Do something with the character.
}</programlisting>
      </example>

      </para>
    </section>
  </chapter>

  <chapter id="interfacingWithJava"><title>Interfacing with Java</title>
    <section><title>Using Java from Nice</title>
      <para>
        The Java libraries are automatically imported as necessary. 
	Therefore it is straightforward	to use existing Java code
	in Nice programs.
      </para>

      <para>
	This section lists advanced features related to the use of Java code
	in Nice.
      </para>

      <section id="importJava"><title>Importing packages</title>
	<para>
	  When Java classes of some package are used frequently,
	  it is possible to make the package part of their name implicit.
	  For instance, after a declaration
	  <literal>import java.io.*;</literal> it is possible
	  to refer to class <type>java.io.File</type>
	  with the short name <type>File</type>. It is not possible to 
          import only a single name, such as 
          <literal>import java.io.File;</literal>, you must import the whole
          package.
	</para>

	<para>
	  Classes defined in the current package always have priority
	  over imported packages. If a short name is used that refers
	  to two classes from imported packages, the compiler
	  will report an ambiguity, and the fully qualified name must be used.
	</para>
      </section>

      <section id="optionTypesJava"><title>Option types</title>
	<para>
	  Nice's advanced type system makes the distinction between normal 
	  (e.g. <type>String</type>) and option
	  (e.g. <type>?String</type>) types, which allows to 
	  prevent <literal>NullPointerExceptions</literal>
	  (see <link linkend="optionTypes">option types</link>).
	  This poses a problem when using 
	  existing Java libraries. If my Nice program calls a Java function
	  that returns a <type>String</type> (the Java type), 
	  does it mean <type>String</type> or 
	  <type>?String</type> in Nice? 
	  Since Java allows the value to be &NULL;, 
	  the Nice compiler 
	  currently suposes it's <type>?String</type> (it can only be 
	  sure about primitive types like <type>int</type>).
	</para>

	<programlisting lang="java">
// Java code
public class MyJavaClass {
  public String getName() {
    return "foo";
  }
}	</programlisting>

	<para>
          In Nice, if <literal>myJavaClass</literal> is a variable of type 
	  <type>MyJavaClass</type>, then 
	  <literal>myJavaClass.getName()</literal> has type 
	  <type>?String</type>.
	</para>

	<para>
	  If the Java code might indeed return &NULL;, 
	  or you are not sure, this is all good. To use the value you will 
	  have to test it against &NULL;. However there are 
	  many cases where you know the value cannot be 
	  &NULL;, for instance if this fact is specified in 
	  the Javadoc comment of the method. In that cases there are currently 
	  two possibilities. The first is to use the 
	  <link linkend="notNull"><literal>notNull</literal>
	  function</link>. 
	  So in our example <literal>notNull(myJavaClass.getName())</literal>
	  has type <type>String</type>. This solution is simple, but can 
	  be annoying if you call the same method many times, or because it 
	  makes your code less readable.
	</para>

	<para>
	  The second solution is to tell once and for all the compiler the 
	  precise type of the method (this is also useful for methods with 
	  parametric types):
	</para>

	<programlisting lang="nice">
String getName(MyJavaClass) = native String MyJavaClass.getName();</programlisting>

	<para>
          The Nice part (on the left of the <literal>=</literal> character) 
	  is the header of a function definition. Note that return type is 
	  <type>String</type> (without the optional type marker 
	  <literal>?</literal>). On the other hand, the right part says that 
	  the function is already defined in class 
	  <type>MyJavaClass</type>, with name <literal>getName</literal>,
	  the one that takes no argument and returns a 
	  <type>String</type>. With this declaration, 
	  <literal>myJavaClass.getName()</literal> has type 
	  <type>String</type>.
	</para>
      </section>
    </section>

    <section><title>Using Nice from Java</title>
      <para>
        It is possible to use libraries developed in Nice in a 
	Java program.
	Before anything, make sure that the classes generated by nicec
	can be found on your classpath when you compile the Java program
	with javac.
      </para>

      <section><title>Calling a function</title>
	<para>
	  You can call a <link linkend="function">function</link> 
	  <literal>f</literal>
	  defined in a nice package <literal>pkg</literal> 
	  by naming it <literal>pkg.fun.f</literal> in the Java program.
	</para>
      </section>

      <section><title>Calling a method</title>
	<para>
	  You can call a <link linkend="method">method</link>
	   <literal>m</literal>
	  defined in a nice package <literal>pkg</literal> 
	  by naming it <literal>pkg.dispatch.m</literal> in the Java program.
	  It does not matter in what package(s) <literal>m</literal> 
	  is implemented: 
	  <literal>pkg</literal> must simply be the package where the method 
	  was declared.
	</para>
      </section>

      <section id="constructorFromJava"><title>Calling a constructor</title>
	<para>
	To instantiate in Java a class defined in Nice, do as usual:
	call its constructor, using the <literal>new</literal> keyword.
	Nice classes have one <link linkend="constructor">automatically 
	generated constructor</link>, 
	with one parameter for each field of the class, 
	including those inherited from Nice super-classes.
	</para>
      </section>

      <section><title>Complete example</title>
      <para>
      <example><title>Using Nice from Java</title>
	<para>
	Let's see an example that illustrates all these features.
	Suppose your Nice library looks like this:
	<programlisting lang="nice">
package my.nice.pkg;

class Person
{
  String name;

  // A method:
  String display();
  display() = "Person: " + name;
}

class Worker extends Person
{
  int salary;

  display() = "Worker: " + name + " salary: " + salary;

  // A function:
  boolean isRich() = salary > 500;
}

	</programlisting>

	Then your Java program can create new persons and workers:
	<programlisting lang="java">
package main.java.pkg;

import my.nice.pkg.*;

public class Main
{
  public static void main(String[] args)
  {
    Person p = new Person("John");
    Worker w = new Worker("Julia", 1000);

    println(my.nice.pkg.dispatch.display(p));
    println(my.nice.pkg.dispatch.display(w));
    if (my.nice.pkg.fun.isRich(w))
      println("A well paid worker!");
  }
}
        </programlisting>
	</para>
      </example>
      </para></section>

      <section><title>Optional parameters</title>
	<para>
	  Nice allows function and method parameters to be 
	  <link linkend="optionalParameters">optional</link>.
	  Since this feature is not available in Java, you have to 
	  provide the value of all parameters, regardless of their
	  optionality.
	  The same applies for class fields with initializers:
	  they are ignored in the Java program, and must be given a value
	  in the call to the constructor.
        </para>
      </section>

      <section><title>Other aspects</title>
	<para>
	Fields of Nice classes are accessed normally from Java programs.
	It is possible to declare a Java subclass of a Nice class.
	The constructor will need to call the 
	<link linkend="constructorFromJava">parent constructor</link>.
	It is not possible to override a Nice multi-methods in a Java
	program.
	</para>
      </section>

    </section>
  </chapter>

  <chapter><title>Types</title>
    <section id="optionTypes"><title>Option types</title>
      <para>
        Nice (unlike Java) makes a distinction between a type that may be &NULL;, 
        and one that may not be. So, if you want to allow &NULL; 
        <classname>String</classname>s, you write <classname>?String</classname> 
        for the type. If &NULL;s should not be allowed, you just write 
        <classname>String</classname>. It is not possible to pass a 
        <classname>?String</classname> where a <classname>String</classname> is 
        expected, unless the compiler can prove it's not &NULL;. The easiest way
        to prove that the variable is not &NULL; is to use an 
        <literal>if</literal> statement:
      </para>

<example>
  <title>Using option types</title>
<programlisting lang="nice">
	void foo(String arg) {...}
	
	void bar(?String arg) {
		if (arg != null) {
			//Here Nice knows arg is not null, so it can 
			// be passed to a method which takes a String.
			foo(arg);
		} 
		foo(arg); //Here arg may or may not be null, 
			  //so Nice gives a compilation error.
	}
</programlisting>
</example>
      <para>
        Therefore, you never have to check that all your arguments 
        aren't &NULL; again, unless you actually want to allow &NULL;s.
      </para>

	<para id="notNull">
	  Sometimes, you know that a value cannot be &NULL;,
	  although it has an option type.
	  You can then use the <literal>notNull</literal> function to
	  assert this fact.
	  If an expression <replaceable>e</replaceable> has type
	  <type>?<replaceable>type</replaceable></type>, then
	  <literal>notNull(<replaceable>e</replaceable>)</literal>
	  has type <type>!<replaceable>type</replaceable></type>.
	  Note that if <replaceable>type</replaceable> is not a type
	  variable, <type>!<replaceable>type</replaceable></type>
	  is the same as <type><replaceable>type</replaceable></type>.
	</para>
	<para>
	  The <literal>notNull</literal> function uses 
	  <link linkend="contracts"><literal>assert</literal></link>
	  to check that the argument is not &NULL;. 
	  This means that the check will only happen at runtime
	  if <link linkend="enablingAssertions">assertion checks are
	  enabled</link>.
	  Otherwise, execution will continue, but the JVM will probably
	  fail soon afterwards with a <literal>NullPointerException</literal>
	  if the value is &NULL;, and it is used as
	  if it was not &NULL;. 
	</para>

      <para>
	There are (rare) situations where it is necessary to allow a 
	&NULL; where one shouldn't normally go, for
	instance if you need to declare a variable before entering a
	loop, but don't have a value to initialize it with. 
	You should first try to think about an alternative way of
	writing the code so that this is not needed. However, if there
	is none, a solution is to use <literal>cast(null)</literal>.
	This expression will be accepted in any context.
	It is then your responsability to make sure that this value is
	not used.
      </para>

      <para>
        Note that <literal>notNull</literal> and <literal>cast(null)</literal>
	have completely different uses. <literal>notNull</literal> is
	used to tell the compiler that you know a certain value is not 
	&NULL;, although the type system does not guarantee it. 
	On the other hand, <literal>cast(null)</literal>
	is used to provide a non-null value which is never going to be
	used. You could not use <literal>notNull(null)</literal> for
	that purpose, because this would fail at runtime if assertion
	checks are enabled.
      </para>

      <para>
        Additional information is available on
	<ulink url="http://nice.sourceforge.net/cgi-bin/twiki/view/Doc/OptionTypes">
	the Wiki page about option types</ulink>.
      </para>

      <para>
       There is related type, which is prefixed with an exclamation point
       (<literal>!</literal>). This is used to specify a non-&NULL; type
       when it is not known if the original type allowed &NULL; or not. This
       is only needed for type parameters; for all other types,
       <type>!<replaceable>type</replaceable></type> is
       equivalent to <type><replaceable>type</replaceable></type>.
      </para>
      <para>
	For instance, in the following function:
      </para>
      <para>
       <literal><![CDATA[<T> T myFunction(Collection<T>);]]></literal>
      </para>
      <para>
       the type parameter <type>T</type> can be
       instantiated at <emphasis>any</emphasis> type, including option types
       like <type>?String</type>. If it is necessary to exclude option types
       from the domain of <type>T</type>, the type can be specified this way:
      </para>
      <para>
       <literal><![CDATA[<!T> !T myFunction(Collection<!T>);]]></literal>
      </para>
      </section>

      <section id = "typeParameters"><title>Type Parameters</title>
        <para>
          Classes, functions, and methods can all be parameterized with type
          variables in Nice as is demonstrated in each of their respective
          chapters. In addition to the ability to introduce type variables,
          Nice provides the ability to constrain those types in certain ways.
          <link linkend="optionTypes">Option types</link> are one such constraint.
        </para>
        <para>
          Simple type parameters of the form
        </para>
        <para>
          <type>&LT;<replaceable>type-variable</replaceable></type>
	  <optional><type>, <replaceable>type-variable</replaceable> ...</type>
	  </optional><type>&GT;</type>
        </para>
        <para>
          are commonly encountered in Nice, but are a simplified form of a more
          general syntax. <type>&lt;T&gt;</type> is actually shorthand for
          <type>&lt;Any T&gt;</type>, which says that <type>T</type> may be any 
          type at all. It is possible to constrain <type>T</type> so that it 
          must be a subtype of some other type. This example shows that
          <literal>filter</literal> may be implemented for any type 
          <type>T</type>, but <type>C</type> must be a subclass of Collection.
        </para>
        <para>
          <literal>
<![CDATA[<Collection C, Any T> C<T> filter(C<T>, T->boolean);]]>
          </literal>
        </para>
        <para>
          It's also possible to enforce some relation among the type parameters,
          such that one must be a subtype of the other, as in this example from
          the standard library, which can be read as "Any T and U, so long as U
          is a subtype of T".
        </para>
        <para>
          <literal>
<![CDATA[<Any T, Any U | U <: T> U[] fill(T[] array, int->U value)]]>
          </literal>
        </para>
        <para>
         Note the notation <literal>&lt;T | T &lt;: SomeType &gt;</literal> means the
         same thing as <literal>&lt;SomeType T&gt;</literal>.
        </para>
        <para>
          There is also a notation for the same class as the declaring class
	  of a method: <type>alike</type>.
	  For instance, the following class <type>Foo</type> declares
	   a method <literal>copy</literal>, such that 
	   <literal>x.copy()</literal>
	  has the same type as <literal>x</literal>, <literal>x</literal> 
	  being of any subclass of <type>Foo</type>.
        </para>
        <para>
	<example id="ex:copy"><title>A copy method with an exact type</title>
	<programlisting lang="nice">
class Foo
{
  String value;

  alike copy();
}

copy(f#Foo) = new Foo(value: f.value);

class Bar extends Foo
{
  int id;
}

copy(b#Bar) = new Bar(value: b.value, id: generateNewId());
</programlisting>
        </example>
	</para>
        <para>
          Note that <link linkend="exactMatching">exact matching</link>
	  is required to implement the
	  <literal>copy</literal> method.
        </para>
      </section>
      <section id = "abstractInterfaces">
        <title>Abstract Interfaces</title>
        <para>
          Nice offers a powerful tool known as the <firstterm>abstract interface</firstterm>. 
          Abstract interfaces are similar in some respects to regular
          Java- or Nice-style interfaces in that they define a set of methods that
          a type must implement to be considered a member of the interface.
        </para>
        <para>
          Two things make an abstract interface different from a regular interface.
          First, a class can be made to implement an abstract interface <emphasis>after</emphasis>
          it's been defined, and even the source code is unnecessary. You can make
          the basic <literal>String</literal> class implement your new
	  abstract interface, if you like.
          Second, an abstract interface is not actually a type, it's an annotation
          which can be applied to types. This means that when you declare an abstract
          interface, you're not creating a new type, you're saying "types which implement
          this abstract interface will all have these methods", but those types are
          not related in any other way. So it is not possible to make a <literal>
          List&lt;MyAbstractInterface&gt;</literal>, or to use an abstract interface
          as a type declaration like <literal>var MyAbstractInterface absInter = ...
          </literal>.
        </para>
        <para>
          So what is an abstract interface <emphasis>for</emphasis>? Abstract interfaces
          can appear in type parameters, so one can write methods for them:
        </para>
        <para>
         <literal>&lt;MyAbstractInterface T&gt; void doSomething(T thing);</literal>
        </para>
        <para>
         and then apply these methods to any object whose class implements <literal>
         MyAbstractInterface</literal>. It's especially useful for situations where
         one wants to use a method on a group of unrelated types, as in the example 
         below. We have a <literal>log()</literal> method which is parameterized
         for any class which implements the abstract interface <literal>LogEntry</literal>,
         and we make a number of classes implement
	 <literal>LogEntry</literal>, so they can be passed to our log method.
        </para>
        <para>
	<example id="ex:abstractInterface"><title>Abstract Interfaces</title>
	<programlisting lang="nice"><![CDATA[
//Abstract interface for things which can be logged.
abstract interface LogEntry
{
  String toLogString();
  int severity();
}

//Some constants for severity levels
let int DEBUG = 1;
let int INFO = 2;
let int ERROR = 3;

<LogEntry E> void log(E entry, int severity = -1) 
{
  if (severity < 0)
    severity = entry.severity();
  someLogWriter.println(timeStamp() + " " + severity + " " + entry.toLogString());
}

//Make strings pass straight through as DEBUG info.
class java.lang.String implements LogEntry;

toLogString(s@String) = s;
severity(s@String) = DEBUG;


//Make throwables print a stack trace, plus a message
class nice.lang.Throwable implements LogEntry;

toLogString(t@Throwable) 
{
  let writer = new StringWriter();
  let printWriter = new PrintWriter(writer);
  printWriter.println("ERROR: " + t.getClass().getName() + ": " + t.getMessage());
  t.printStackTrace(printWriter);
  printWriter.close();
  return writer.toString();
}

severity(t@Throwable) = ERROR;

//We like to log requests, too
class javax.servlet.http.HttpServletRequest implements LogEntry;

toLogString(r@HttpServletRequest) = "Request from: " + r.getRemoteHost();
severity(r@HttpServletRequest) = INFO;

]]>
</programlisting>
        </example>
        </para>
        <para>
          There are some interesting things to notice about this code. First, 
          we only had to write <literal>log()</literal> once, and we left it
          up to the LogEntry to do the formatting. This could be done with a
          regular interface as well, except that we also made String and 
          Throwable implement our abstract interface, which we couldn't have 
          done with a regular interface. So now we can write code like
        </para>
        <para>
          <programlisting lang="nice">
            log(request);
            log("Beginning processing");
            try 
              {
                1/0;
              } 
            catch (Exception e)
              {
                log(e);
              }
          </programlisting>
        </para>
        <para>
          and our abstract interface implementations will take care of making
          sure that we get the right formatting and severity levels. The most
          interesting thing about this code is that if we write <literal>log(5)
          </literal> then the compiler will catch the error, because <literal>
          byte</literal> doesn't implement <literal>LogEntry</literal>. If
          we had defined <literal>log</literal> with the signature <literal>
          &lt;E&gt; void log(E entry, int severity = -1)</literal>, we could 
          have achieved all the same effects, but we would have lost the
          type safety abstract interfaces gave us above - because
	  <literal>&lt;E&gt;</literal> means <emphasis>any</emphasis>
	  type is allowed, so we would have had to define some defaults:
        </para>
        <para>
          <programlisting lang="nice">
            toLogString(e)
            {
              throw new Exception("No toLogString method defined!");
            }

            severity(e)
            {
              throw new Exception("No severity method defined!");
            }
          </programlisting>
        </para>
        <para>
          Then we'd be no better off than in a dynamically typed language -
          we wouldn't find out that we'd tried to log an integer until we got an
          exception at runtime. With abstract interfaces, we were able to
          tell the compiler <emphasis>exactly</emphasis> which classes 
          should be allowed as arguments to <literal>log</literal>, and so
          our program is safer as a result.
        </para>
        <para>
          Daniel Bonniot, Nice's creator, invented abstract interfaces. You 
          can read more about them in the 
          <ulink url = "http://nice.sourceforge.net/research.html">Academic
          Research</ulink> section of the Nice website.
        </para>

      </section>      

  </chapter>
  

</book>

<!--
  Local Variables:
  sgml-validate-command: "xmllint -noout -valid"
  End:
 -->
