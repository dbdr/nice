package nice.tools.doc;

/**
   

   @author Francis Barber
*/

/*TODO
 * 1)Make it file system independent by using java.io.File.separator instead of '/'
 * Nice seems to reject this - 
 *    Ambiguity for symbol File. Possibilities are :
 *    java.io.File File(?String, String)
 *    java.io.File File(?File, String)
 */
 
    /*Below is various info that could be used in the
     *construction of the method entry
     */
    //The compiler doesn't like this:  println("Syntactic return type: " + m.getSyntacticReturnType());
    //println("Return type: " + m.getReturnType());
    //println("Arity: " + m.getArity());
    //println("Type: " + m.getType());
    //println("Formal Parameters: " + m.formalParameters());

import bossa.syntax.*;
import java.util.*;
import java.text.*;
import java.io.*;

class HTMLWriter {
  //mainPackage = mainPackage.deleteAtEnd("/").replace('/', ".");
  
  void write(Definition d, String packageName) {
  }

  write(c@ClassDefinition.Class, packageName) {
    // Here we handle classes
    
    //Initialise a FileWriter
    // Output directory for this class
    File dir = new File(outdir, packageName.replace('.', java.io.File.separator));
    if(!dir.exists() && !dir.mkdirs()) {
        System.err.println("Error creating directory structure");
    }
    
    String fileName = c.getName().toString();
    //we only want information after the last .
    //that is, nice.lang.Maybe -> Maybe
    //this should also work when "." is not found
    fileName = fileName.substring(fileName.lastIndexOf(".") + 1);
    BufferedWriter writer = new BufferedWriter
      (new FileWriter(new File(dir, fileName + ".html")));
    
    writer.write(getHeader(c.getName().toString()));

    writer.write("<h1>Class " + c.getName() + "</h1>");

    //Print hierarchy
    ArrayList<ClassDefinition.Class> list = new ArrayList();
    ?ClassDefinition.Class superClass = c.getSuperClassDefinition();
    while(superClass != null) {
      list.add(superClass);
      superClass = superClass.getSuperClassDefinition();
    }
    /*This creates a nice-looking String as follows:
     *Super-Super-Class
     *   |
     *   +--Super-Class
     *         |
     *         +--Class
     */
    String hierarchy = c.getName().toString();
    for(int i = 0; i < list.size(); i++) {
      String spaces = "";
      for(int j = 0; j < (list.size()-i)*6-3; j++)
        spaces = spaces + ' ';
      hierarchy = list.get(i).getName() + "\n" + spaces + "|\n" + spaces + "+--" + hierarchy;
    }
    writer.write("<pre>");
    writer.write(hierarchy);
    writer.write("</pre>");

    //Implemented interfaces
    ClassDefinition.Interface[?] interfaces = c.getImplementedInterfaces();
    if(interfaces != null) {
      writer.write("<b>Implemented interfaces:</b>");
      writer.write("<ul>");
      interfaces.foreach(ClassDefinition.Interface i => 
  		         writer.write("<li>" + i.getName() + "</li>"));
      writer.write("</ul>");
    }

    writer.write(getFooter());
    writer.close();
  }

  write(gv@GlobalVarDeclaration, packageName) {
    //Handle global variables
    
    //Initialise a FileWriter
    File dir = new File(outdir, packageName.replace('.',java.io.File.separator));
    if(!dir.exists() && !dir.mkdirs()) {
        System.err.println("Error creating directory structure");
    }
    
    BufferedWriter writer = new BufferedWriter
      (new FileWriter(new File(dir, "gv_" gv.getName() ".html")));
    
    writer.write(getHeader(gv.getName().toString()));
  
    writer.write("<h1>Global Variable " + gv.getName() + "</h1>");
  
    writer.write(htmlSafe(gv.toString()));
  
    writer.write("<p>");
    writer.write("nicedoc comments would go here...");
    writer.write("</p>");
 
    writer.write(getFooter());
    writer.close();
  }
  
  write(m@MethodDeclaration, packageName) {
    //Handle methods
    
    //Initialise a FileWriter
    File dir = new File(outdir, packageName.replace('.',java.io.File.separator));
    if(!dir.exists() && !dir.mkdirs()) {
        System.err.println("Error creating directory structure");
    }
    
    BufferedWriter writer = new BufferedWriter
      (new FileWriter(new File(dir, calculateMethodFilename(m))));
    
    writer.write(getHeader(m.getName().toString()));
  
    writer.write("<h1>Method " + m.getName() + "</h1>");
  
    writer.write(htmlSafe(m.toString()));
  
    writer.write("<p>");
    writer.write("nicedoc comments would go here...");
    writer.write("</p>");
 
    writer.write(getFooter());
    writer.close();
  }

  write(m@DefaultMethodImplementation, packageName) {
    this.write(m.getDeclaration(), packageName);
  }

  void write(bossa.modules.Package p) {
    try {
      File dir = new File(outdir, p.getName().replace('.',java.io.File.separator));
      if(!dir.exists() && !dir.mkdirs()) {
          System.err.println("Error creating directory structure");
      }
      BufferedWriter writer = new BufferedWriter
        (new FileWriter(new File(dir, "index.html")));
      writer.write(getHeader("Package " + p.getName()));
            
      //we need to separate class, methods, and global variables
      ArrayList<ClassDefinition.Class> classes = new ArrayList();
      ArrayList<MethodDeclaration> methods = new ArrayList();
      ArrayList<GlobalVarDeclaration> globalVars = new ArrayList();
      for(Definition d : p.getDefinitions().definitions()) {
        if(d instanceof ClassDefinition.Class) {
          classes.add(d);
        }
        else if(d instanceof MethodDeclaration) {
          methods.add(d);
        }
        else if(d instanceof DefaultMethodImplementation) {
          methods.add(d.getDeclaration());
        }
        else if(d instanceof GlobalVarDeclaration) {
          globalVars.add(d);
        }
        else {
          System.err.println("Ignoring " d "\n  (type " d.getClass() ")");
        }
      }
      
      //Write classes
      writer.write("<b>Classes:</b>\n");
      writer.write("<ul>\n");
      for(ClassDefinition.Class c : classes) {
        String s = c.getName().toString();
        int index = s.lastIndexOf('.');
        if(index != s.length()-1)
            s = s.substring(index+1);
        writer.write("<li><a href='" + s + ".html'>" + s + "</a></li>\n");
      }
      writer.write("</ul>\n");
      
      //Write methods
      writer.write("<b>Methods:</b>\n");
      writer.write("<ul>\n");
      for(MethodDeclaration m : methods) {
          writer.write("<li><a href='" calculateMethodFilename(m) "'>" m.getName() "</a>" +
                       ": " m.getType() "</li>\n");
      }
      writer.write("</ul>\n");
      
      //Write global vars
      writer.write("<b>Global Variables:</b>\n");
      writer.write("<ul>\n");
      for(GlobalVarDeclaration gv : globalVars) {
           writer.write("<li><a href='gv_" gv.getName() ".html'>" gv.getName() "</a></li>\n");
      }
      writer.write("</ul>\n");
      
      writer.write(getFooter());
      writer.close();
    } catch(IOException ioe) {
      ioe.printStackTrace();
    }
  }
  
  /** This method takes a List containing all the packages that are going to be
   * documented.  It writes a page at the root of output dir called index.html
   * containing a list of hyperlinks to all the packages.
   */
  void write(List<bossa.modules.Package> packages) {
    try {
      BufferedWriter writer = new BufferedWriter(new FileWriter(new File(outdir, "index.html")));
      writer.write(getHeader("Packages"));
      writer.write("<b>Packages:</b>\n");
      writer.write("<ul>\n");
      for(bossa.modules.Package p : packages) {
          writer.write("<li><a href='" + p.getName().replace('.', "/") + "/index.html'>" + p.getName() + "</a></li>\n");
      }
      writer.write("</ul>\n");
      writer.write(getFooter());
      writer.close();
    } catch(IOException ioe) {
      ioe.printStackTrace();
    }
  }
}

/** Converts a String that may contain characters such as '<' to one that will display
 * properly in html.  Submitted by S. Bayer to http://www.rgagnon.com/javadetails/java-0306.html,
 * although I've made some changes.
 */
String htmlSafe(String s) {
    StringBuffer sb = new StringBuffer(s.length());
    //true if last char was blank - this is for handling non-breaking spaces
    boolean lastWasBlankChar = false;

    for (int i = 0; i < s.length(); i++) {
        char c = s.charAt(i);
        if (c == ' ') {
            // blank gets extra work,
            // this solves the problem you get if you replace all
            // blanks with &nbsp;, if you do that you lose
            // word breaking
            if (lastWasBlankChar) {
                lastWasBlankChar = false;
                sb.append("&nbsp;");
            }
            else {
                lastWasBlankChar = true;
                sb.append(' ');
            }
        }
        else {
            lastWasBlankChar = false;
            // HTML Special Chars
            if (c == '"')
                sb.append("&quot;");
            else if (c == '&')
                sb.append("&amp;");
            else if (c == '<')
                sb.append("&lt;");
            else if (c == '>')
                sb.append("&gt;");
            else if (c == '\n')
                // Handle Newline
                sb.append("&lt;br/&gt;");
            else {
                //char and int are not related in nice, so we can't do a direct cast
                //hence, we use int(c) instead of (int)c
                int ci = int(c);
                /*This was originally 160 in S. Bayer version, but I couldn't see the sense of that
                 *so I changed it to 128, as 127 is the maximum value of an ascii character
                 */
                if(ci < 128)
                    // nothing special only 7 Bit
                    sb.append(c);
                else {
                    // Not 7 Bit use the unicode system
                    sb.append("&#");
                    sb.append(new Integer(ci).toString());
                    sb.append(';');
                }
            }
        }
    }
    return sb.toString();
}

/** Returns a string containing everything required up to and including the <body> tag
 */
String getHeader(String title) {
  //we could also include some kind of visible header as well
  
  //Create a DateFormatter and set the time zone
  DateFormat df = new SimpleDateFormat("dd/MM/yyyy 'at' HH:mm:ss z");
  df.setTimeZone(TimeZone.getTimeZone("GMT"));
  return
  "<html>\n" +
  "<head>\n" + 
  "<!-- Generated by nicedoc on "  df.format(new Date())  " -->\n" +
  "\t<title>" + title + "</title>\n" +
  "</head>\n" +
  "<body>\n";
}

/** Returns a string containing everything after and including the </body> tag
 */
String getFooter() {
  //we could also include other information here
  return
  "</body>\n" +
  "</html>\n";
}

/** Methods can be overloaded - we can't just use the method name as a file name.
 * This method returns a file name based upon the method name and its arguments.
 */
String calculateMethodFilename(MethodDeclaration md) {
    String filename = md.getName().toString() + md.getType().toString().hashCode();
    filename = filename.replace('/', "@slash").replace('.', "@dot");
    return filename + ".html";
}