/**************************************************************************/
/*                                N I C E                                 */
/*             A high-level object-oriented research language             */
/*                        (c) Daniel Bonniot 2000                         */
/*                                                                        */
/*  This program is free software; you can redistribute it and/or modify  */
/*  it under the terms of the GNU General Public License as published by  */
/*  the Free Software Foundation; either version 2 of the License, or     */
/*  (at your option) any later version.                                   */
/*                                                                        */
/**************************************************************************/

package nice.tools.compiler;

/**
   Nice compiler main program.

   Exit code table:
   0 : Normal exit (compilation sucessful, version message)
   1 : Abnormal termination (bug in the compiler)
   2 : Error reported (file missing, type error, ...)
   3 : Warning reported

   Changes to this table should be reflected in function 
   <code>nice-compilation-exit</code> in emacs mode file 
   <tt>nice-mode.el</tt>.

   @version $Date$
   @author Daniel Bonniot (d.bonniot@mail.dotcom.fr)
 */

import mlsub.compilation;
import nice.getopt;
import bossa.modules;

main(args)
{
  ?Throwable uncaughtException = null;
  boolean memInfo = false;

  try{

  Compilation compilation = new Compilation();

  Sequence<Option> options;
  options = 
  [
   option('?', "sourcepath",
	  "Lookup path for source packages\nPATH is a list of directories and .jar archives",
	  "path",
	  fun(String path) => { compilation.sourcePath = path; }),

   option('d', "destination",
	  "Destination directory for compiled packages",
	  "dir",
	  fun(String dir)=>{ compilation.destinationDir = dir; }),

   option('?', "packagepath",
	  "Additional lookup path for compiled packages\nPATH is a list of directories and .jar archives",
	  "path",
	  fun(String path) =>{ compilation.packagePath = path; }),

   option('?', "classpath",
	  "Lookup path for external classes",
	  "path",
	  fun(String path) => nice.tools.code.Types.setClasspath(path)),


   option('a', "jar",
	  "Compile to archive\nYou can then run the program with 'java -jar FILE'",
	  "file",
	  fun(String output) => { compilation.output = output; }),

   // This will specify native compilation in the future
   option('o', "output",
	  "Generate native executable (not supported yet)",
	  "file",
	  fun(String output) => { compilation.output = output; }),


   option('r', "recompile",
	  "Force recompilation of package",
	  fun() => { compilation.recompileCommandLine = true; }),

   option('R', "recompile-all",
	  "Force recompilation of all dependant packages",
	  fun() => { compilation.recompileAll = true; }),

   option('c', "compile",
	  "Compile packages but do not link them",
	  fun() => { compilation.skipLink = true; }),


   // This options is usefull for the compiler itself. 
   // Should not be advertised since it should not be usefull otherwise
   option('?', "exclude-runtime", 
	  "Avoid inclusion of the runtime in the archive", 
	  fun() => { compilation.excludeRuntime = true; }),


   option('h', "help", "Print help message and exit",
	  fun()=>
            {
	      println(printOptions(options));
	      System.exit(1);
	    }),

   option('?', "version",
	  "Print version info and exit",
	  fun()=>version()),

   option('?', "usage",
	  "Print usage information and exit",
	  fun()=>usage()),

   option('?', "memory",
	  "Print memory usage information after compilation",
	  fun()=>{ memInfo = true; })
  ];

  Sequence<String> rest = parse("nicec", args, options);
  if (rest.size() != 1 || rest[0].length() == 0)
    {
      if (rest.size() > 1)
	println("Supply only one package on the command line.\n" +
		"nicec will automatically find dependancies.");
      usage();
    }

  compilation.setMainPackage(rest[0]);
  make(compilation);
  }
  catch(bossa.util.UserError e){
    nice.tools.compiler.OutputMessages.error(e.getMessage());
  }
  catch(ExceptionInInitializerError e){
    uncaughtException = e.getException();
  }
  catch(Throwable e){
    uncaughtException = e;
  }

  if(uncaughtException != null)
    {
      Throwable exn = notNull(uncaughtException);

      println
      ("\nAn exception has occured in the compiler\n" +
       "Please fill-in a bug report at the following webpage:\n" +
       "http://sourceforge.net/tracker/?func=add&group_id=12788&atid=112788" +
       "\n\nException: " + exn.toString() +
       "\n\nStack trace:\n");
      exn.printStackTrace();
      System.exit(1);
    }
  
  if (memInfo) printMemoryUsage();

  OutputMessages.exit();
}

void usage()
{
  println("Usage: nicec [options] [package]");
  println("Type \"nicec --help\" for a list of options");
  System.exit(0);
}

void version()
{
  println("Nice compiler beta version (" + buildDate + ")");
  println("Copyright (C) 2001 Daniel Bonniot");
  println("Visit the Nice homepage: http://nice.sourceforge.net");
  System.exit(0);
}

String prettyBytes(long bytes)
{
  long K = 1024;
  if (bytes < 10 * K)
    return ""+bytes+" B";
  else if (bytes < 100 * K)
    return ""+(bytes/K) + "." + ((bytes % K)/100) + " KB";
  else if (bytes < 10*K*K)
    return ""+(bytes/K) + " KB";
  else if (bytes < 100*K*K)
    return ""+(bytes/(K*K)) + "." + ((bytes % (K*K))/(100*K)) + " MB";
  else if (bytes < 10*K*K*K)
    return ""+(bytes/(K*K)) + " MB";
  else 
    return ""+(bytes/(K*K*K)) + " GB";
}

void printMemoryUsage()
{
  Runtime r = getRuntime();
  r.gc();
  long total = r.totalMemory();
  long free  = r.freeMemory();
  println("Memory allocated: " + prettyBytes(total) + 
	  ", used: " + prettyBytes(total - free));
}
