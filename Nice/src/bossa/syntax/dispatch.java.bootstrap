
package bossa.syntax;

import java.util.List;
/*
  This file is only useful to bootstrap the compiler,
  since bossa.syntax is implemented both in Java and Nice,
  while we need mutual recursion between the two.

  This class must have the interface of the Nice part of the package.
*/

public class dispatch
{
  public static NiceClass createNiceClass(ClassDefinition cdef)
  {return null;}

  public static Statement createReturnStmt(Expression value, boolean fake)
  { return null; }

  public static Expression createLiteralArrayExp(List exps)
  { return null; }

  public static Expression createNewExp(TypeIdent ti, Arguments arguments) 
  { return null; }

  public static Expression createCallExp(Expression function, Expression param1)
  { return null; }

  public static Expression createCallExp(Expression function, Expression param1, Expression param2)
  { return null; }

  public static VarSymbol createMethodSymbol(MethodDeclaration declaration, LocatedString name, Constraint constraint, Monotype returnType)
  { return null; }
  
  public static VarSymbol createMethodSymbol(MethodDeclaration declaration, LocatedString name, mlsub.typing.Polytype type)
  { return null; }

  public static VarSymbol createConstructorCallSymbol(MethodDeclaration declaration, LocatedString name, mlsub.typing.Polytype type)
  { return null; }

  public static gnu.bytecode.Method getImplementationAbove(JavaMethod decl, gnu.bytecode.ClassType firstArg)
  { return null; }

  static List removeNonMinimal(List l)
  { return null; }

  static void resolveCCThis(Statement stmt, bossa.util.Located thisloc, NiceClass classe) {}

  static Pattern resolveGlobalConstants(Pattern pattern)
  { return null; }

  public static Pattern readPattern(String rep, int[] pos)
  { return null; }

  public static Pattern createPattern(LocatedString name)
  { return null; }

  public static Pattern createPattern(LocatedString name, TypeIdent ti)
  { return null; }

  public static Pattern createPattern(LocatedString name, mlsub.typing.TypeConstructor tc, boolean sure)
  { return null; }

  public static Pattern createPattern(TypeIdent tc, LocatedString name, boolean exactly, TypeIdent additional, mlsub.typing.TypeConstructor runtimeTC)
  { return null; }

  public static Pattern createPattern(ConstantExp value)
  { return null; }

  public static Pattern createPattern(ConstantExp value, TypeIdent additional)
  { return null; }

  public static Pattern createPattern(String kind, LocatedString name, ConstantExp value, LocatedString refName, bossa.util.Location loc)
  { return null; }

  public static boolean leq(Pattern a, Pattern b)
  { return false; }

  public static boolean disjoint(Pattern a, Pattern b)
  { return false; }
  
  public static Statement createBlock(List statements)
  { return null; }

  public static ConstantExp createStringConstantExp(String value)
  { return null; }

  static Statement analyse(Statement  s, VarScope v, TypeScope t, boolean r)
  { return null; }

  static Statement analyseMethodBody(Statement s, VarScope varScope, TypeScope typeScope, MonoSymbol[] params, boolean mustReturnAValue)
  { return null; }
  
  static Expression analyse(Expression e, VarScope v, TypeScope t) 
  { return null; }

  static Expression analyse(Expression e, Info i) 
  { return null; }

  static void typecheck(Statement s) {}
  static void typecheck(Expression e) {}

  static bossa.util.UserError unknownIdent(LocatedString ident)
  {
    return null;
  }

  static bossa.util.UserError assignmentError
    (bossa.util.Located responsible,
     String target,
     String targetType,
     Expression value)
  { return null; }

  public static void _printStackTraceWithSourceInfo(Throwable t) {}
}

class UnknownIdentException extends bossa.util.UserError
{
  LocatedString ident;
}

class Info {}
