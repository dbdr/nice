/**************************************************************************/
/*                                N I C E                                 */
/*             A high-level object-oriented research language             */
/*                        (c) Daniel Bonniot 2000                         */
/*                                                                        */
/*  This program is free software; you can redistribute it and/or modify  */
/*  it under the terms of the GNU General Public License as published by  */
/*  the Free Software Foundation; either version 2 of the License, or     */
/*  (at your option) any later version.                                   */
/*                                                                        */
/**************************************************************************/

/*
   Type checking.
*/

package bossa.syntax;

import mlsub.typing.*;

// Interface

void typecheck(?Statement);
void typecheck(?Expression);

/****************************************************************
 * Expressions
 ****************************************************************/

typecheck(@null(Expression)) {}

typecheck(e@AssignExp)
{
  Expression to = notNull(notNull(e.to).noOverloading());
  e.to = to;
  typecheck(to);
  if(!to.isAssignable())
    bossa.util.User.error(e, "" + to + " cannot be assigned a value");
  
  try{
    e.value = checkAssignment(notNull(to.getType()), notNull(e.value));
  }
  catch(TypingEx t){
    if (notNullError(t, e, e.value.toString()))
      throw assignmentError(e, to.toString(), 
			    to.getType().toString(), notNull(e.value));
  }
}

void typecheckExps(?Expression[] exps)
{
  for (int i = 0; i < exps.length; i++)
    typecheck(exps[i]);
}

void typecheck(Arguments);
typecheck(args@Arguments)
{
  for (int i = 0; i < args.size(); i++)
    typecheck(args.getExp(i));
}

typecheck(e@CallExp)
{
  // forces computation of the type if not done.
  mlsub.typing.Polytype t = e.getType();
    
  // Prepare the bytecode type for EnsureTypeProc
  if (t.getConstraint() != mlsub.typing.Constraint.True)
    try{
      Typing.enter();
      try{
	mlsub.typing.Constraint.assert(t.getConstraint());
	nice.tools.code.Types.setBytecodeType(t.getMonotype());
      }
      finally{
	Typing.leave();
      }
    }
  catch(TypingEx e){
  }

  typecheck(e.function);
  notNull(e.arguments).typecheck();
}

typecheck(e@FunExp)
{
  Function saved = Node.getCurrentFunction();
  Node.setCurrentFunction(e);
  typecheck(e.body);
  Node.setCurrentFunction(saved);
}

typecheck(e@IdentExp)
{
  throw new Error("typecheck in IdentExp");
}

/**
   Analyse a boolean test to check if it ensures that some
   local variable is always null or alwyas non-null.

    @return 
      the local variable found, or null
    and
      true  if the variable if always null     when the test succeeds
      false if the variable if always non-null when the test succeeds
*/
<?MonoSymbol, boolean> nullnessInfo(Expression test);
nullnessInfo(test) = (null, false);
nullnessInfo(test@CallExp)
{
  boolean isAlwaysNull;
  if (test.isCallTo("=="))
    isAlwaysNull = true;
  else if (test.isCallTo("!="))
    isAlwaysNull = false;
  else /// give up
    return (null, false);

  int varPosition;
  if (isNullExp(notNull(notNull(test.arguments).getExp(0))))
    varPosition = 1;
  else if (isNullExp(notNull(notNull(test.arguments).getExp(1))))
    varPosition = 0;
  else /// give up
    return (null, false);

  return (localVariable(notNull(notNull(test.arguments).getExp(varPosition))), isAlwaysNull);
}

/** 
    Collects knowledge about more precise type in branches of conditionals.
    
    At the moments only tests agains null are considered.
    Later, instanceof tests will also be taken into account.
*/

var int ifLevel;
var Stack<int> levels = new Vector();
var Stack<<MonoSymbol, mlsub.typing.Monotype>> conditionalTypes = 
  new Vector();

void enterIf() { ifLevel++; }
void exitIf()
{ 
  ifLevel--;
  while (levels.size() > 0 && levels.top() == ifLevel)
    {
      levels.pop();
      MonoSymbol variable; 
      mlsub.typing.Monotype baseType;
      (variable, baseType) = conditionalTypes.pop();
      variable.type = baseType;
    }
}

void pushConditionalType(MonoSymbol variable, mlsub.typing.Monotype baseType)
{
  levels.push(ifLevel);
  conditionalTypes.push((variable, baseType));
}

typecheck(e@IfExp)
{
  Expression condition = notNull(e.condition);

  try{
    condition = checkAssignment(notNull(ConstantExp.boolPolytype), condition);
    e.condition = condition;
  }
  catch(TypingEx t){
    if (notNullError(t, e, condition.toString()))
      throw new bossa.util.UserError
      (e, 
       "The condition must be a boolean.\n" + 
       condition + " has type " + condition.getType());
  }

  enterIf();

  try{
    ?MonoSymbol variable;
    boolean isAlwaysNull;
    (variable, isAlwaysNull) = nullnessInfo(condition);

    if (variable == null)
      {
	typecheck(e.thenExp);
	typecheck(e.elseExp);
	return;
      }

    MonoSymbol variable = notNull(variable);

    if (! isAlwaysNull)
      // variable is non-null in the 'then' part
      {
	mlsub.typing.Monotype type = variable.type;
	variable.type = makeSure(type);
	typecheck(e.thenExp);

	variable.type = type;
	typecheck(e.elseExp);

	// If else never returns, the variable is known to be non-null
	// up-to the end of this conditional block
	if (e.elseUnreachable)
	  {
	    variable.type = makeSure(type);
	    pushConditionalType(variable, type);
	  }
      }
    else
      // variable is non-null in the 'else' part
      {
	mlsub.typing.Monotype type = variable.type;
	typecheck(e.thenExp);

	variable.type = makeSure(type);
	typecheck(e.elseExp);

	if (e.thenUnreachable)
	  pushConditionalType(variable, type);
	else
	  variable.type = type;
      }
  }
  finally{
    exitIf();
  }
}

typecheck(e@IncrementExp)
{
  try{
    e.variable = checkAssignment(notNull(ConstantExp.longPolytype), 
				 notNull(e.variable));
  }
  catch(TypingEx t){
    if (notNullError(t, e, e.description()))
      throw new bossa.util.UserError
      (e, 
       notNull(e.description()) + " is only valid on integers.\n" + 
       e.variable + " has type " + notNull(e.variable).getType());
  }
}

typecheck(e@LiteralArrayExp)
{
  typecheckExps(notNull(e.elements));
}

typecheck(e@NewArrayExp)
{
  ?Expression[] knownDimensions = notNull(e.knownDimensions);
  typecheckExps(knownDimensions);
  for (int i=0; i<knownDimensions.length; i++)
    {
      Expression dim = notNull(knownDimensions[i]);
      try{
	Typing.leq(dim.getType(),
		   ConstantExp.intPolytype);
      }
      catch(TypingEx ex){
	if (notNullError(ex, dim, 
			 dim.toString()))
	  bossa.util.User.error(dim, "" + dim + " should be an integer");
      }
    }
}

typecheck(e@NewExp)
{
  // force computation of type
  e.getType();
  notNull(e.arguments).typecheck();
}

typecheck(e@StatementExp)
{
  typecheck(e.statement);
}

typecheck(e@TupleExp)
{
  typecheckExps(notNull(e.expressions));
}

typecheck(e@ClassExp) {}
typecheck(c@ConstantExp){}
typecheck(e@NullExp) {}
typecheck(e@OverloadedSymbolExp) {}
typecheck(e@PackageExp) {}
typecheck(e@SymbolExp) {}

/****************************************************************
 * Statements
 ****************************************************************/

typecheck(@null(Statement)) {}

typecheck(b@Block)
{
  javaList(notNull(b.locals)).iter(fun(?Block.LocalDeclaration d)=> typecheck(d));
  notNull(b.statements).iter(fun(?Statement s)=> typecheck(s));
}

typecheck(decl@Block.LocalVariable)
{
  if (decl.value == null)
    return;

  MonoSymbol target = decl.getLeft();

  try{
    decl.value = checkAssignment(notNull(target.getType()), notNull(decl.value));
  }
  catch(TypingEx t){
    if (notNullError(t, target, decl.value.toString()))
      throw assignmentError(target, target.name.toString(), 
			    target.getMonotype().toString(), 
			    notNull(decl.value));
  }
}

typecheck(decl@Block.LocalFunction)
{
  typecheck(decl.value);
  try{
    Typing.leq(decl.inferredReturnType(), decl.declaredReturnType());
  }
  catch(TypingEx t){
    if (notNullError(t, decl, "returned value"))
      wrongReturnType(decl, 
		      decl.inferredReturnType().toString(), 
		      decl.declaredReturnType().toString(), t);
  }
}

typecheck(s@ExpressionStmt)
{
  typecheck(s.exp);
}

typecheck(l@LoopStmt)
{
  typecheck(l.whileExp);
  typecheck(l.loopBody);
  typecheck(l.iterationStatements);
}

typecheck(r@ReturnStmt)
{
  r.includingFunction = Node.currentFunction;

  if (r.value != null)
    {
      r.value = notNull(r.value).noOverloading();
      typecheck(r.value);
    }
  
  mlsub.typing.Monotype declaredRetType = notNull(r.includingFunction).getReturnType();
  if (declaredRetType == null)
    return;
  
  try{
    Typing.leq(r.returnType(), declaredRetType);
  }
  catch(TypingEx e){
    if (notNullError(e, r, r.value.toString()))
      wrongReturnType(r, r.returnType().toString(), 
		      declaredRetType.toString(), e);
  }
}

typecheck(t@TryStmt)
{
  typecheck(t.body);
  javaList(notNull(t.catches)).iter(fun(TryStmt$Catch c)=> typecheck(c.body));
  typecheck(t.finallyBody);
}


/****************************************************************
 * Error handling
 ****************************************************************/

/**
   Checks that right can be assigned to a variable of type left.
   Returns a new expression to be used instead of right,
   since overloading resolution is done on the expected type.
*/
Expression checkAssignment(mlsub.typing.Polytype left, Expression right)
{
  Expression val = right.resolveOverloading(left);
  typecheck(val);
  Typing.leq(val.getType(), left);
  return val;
}

/**
   Throws a UserError with an explicit message if 
     the error is that value might be null.
   Returns true iff there is another type error.
*/
boolean notNullError(TypingEx ex, bossa.util.Located resp, ?String value);
notNullError(@TypingEx, resp, value) = true;
notNullError(ex@MonotypeLeqEx, resp, value)
{
  /*
    This is an approximation.
    An exact report of nullness errors would probably need
    to keep track of the lowlevel exception.
  */
  TypeConstructor tc1 = notNull(ex.getM1()).head();
  TypeConstructor tc2 = notNull(ex.getM2()).head();

  if (tc1 == tc2) return true;

  if (tc1 == ConstantExp.maybeTC &&
      (tc2 != ConstantExp.maybeTC || tc2 != null))
    {
      //throw new bossa.util.UserError(resp, "" + value + " may be null");
      bossa.util.User.warning(resp, "" + value + " may be null");
      return false;
    }
  return true;
}

void wrongReturnType(bossa.util.Located responsible, 
		     String typeFound, 
		     String typeExpected, Exception e)
{
  String message = 
    "Incorrect return type:" +
    "\nFound   : " + typeFound +
    "\nExpected: " + typeExpected;

  if (bossa.util.Debug.powerUser)
    message = message + "\n\nLowlevel error: " + e;

  throw new bossa.util.UserError(responsible, message);
}

// Local Variables:
// nice-xprogram: "nicec -d \"$HOME/Nice/classes\" --sourcepath=\"$HOME/Nice/src\" --classpath=\"$HOME/Nice/classes\""
// End:
