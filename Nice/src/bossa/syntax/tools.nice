/**************************************************************************/
/*                                N I C E                                 */
/*             A high-level object-oriented research language             */
/*                        (c) Daniel Bonniot 2001                         */
/*                                                                        */
/*  This program is free software; you can redistribute it and/or modify  */
/*  it under the terms of the GNU General Public License as published by  */
/*  the Free Software Foundation; either version 2 of the License, or     */
/*  (at your option) any later version.                                   */
/*                                                                        */
/**************************************************************************/

package bossa.syntax;

/**
   Helper functions.

   @version $Date$
   @author Daniel Bonniot (bonniot@users.sourceforge.net)
 */

?LocatedString identString(?Expression);
identString(e) = null;
identString(e@IdentExp) = e.ident;
identString(e@SymbolExp) = e.getName();
identString(e@OverloadedSymbolExp) = e.ident;

boolean isCallTo(CallExp e, String name) 
{
  ?LocatedString f = identString(e.function);
  if (f == null)
    return false;
  else
    return f.toString().equals(name);
}

boolean isNullExp(Expression);
isNullExp(e@Expression) = false;
isNullExp(e@NullExp) = true;

?MonoSymbol localVariable(Expression);
localVariable(e@Expression) = null;
localVariable(e@SymbolExp)
{
  let sym = e.getSymbol();
  if (sym instanceof bossa.syntax.MonoSymbol) {
    //don't allow nullness inference on global variables.
    if (sym instanceof GlobalVarDeclaration.GlobalVarSymbol &&
		sym.isAssignable())
      return null;

    return cast(e.getSymbol());
  }
  return null;
}
localVariable(e@AssignExp) = localVariable(notNull(e.to));

mlsub.typing.Monotype makeSure(mlsub.typing.Monotype m) = 
  notNull(bossa.syntax.Monotype.sure(nice.tools.code.Types.rawType(m)));

mlsub.typing.Monotype makeUnsure(mlsub.typing.Monotype m) = 
  notNull(bossa.syntax.Monotype.maybe(nice.tools.code.Types.rawType(m)));

mlsub.typing.Monotype checkMonomorphic(mlsub.typing.Polytype type,
				       Block.LocalValue decl)
{
  if (! type.isMonomorphic())
    {
      type.simplify();

      if (! type.isMonomorphic())
	throw new bossa.util.UserError
	(decl, 
	 "The value has a polymorphic type: " + type +
	 "\nOmitting the type here is not supported by Nice yet." + 
	 "\nPlease declare the monomorphic type of " + decl.getName());
    }

  return type.getMonotype();
}

/* 
   Make sure that the error is attached to a location.
   If not, located it a the given located object (which should be a close 
   container of the entity creating the error).
*/
bossa.util.UserError ensureLocated(bossa.util.UserError e, 
				   bossa.util.Located loc)
{
  if (e.location == null)
    e.location = loc.location();
  return e;
}

?(MonoSymbol, mlsub.typing.Monotype) getInstanceof(CallExp condition)
{
  if (! condition.isCallTo("instanceof") || condition.arguments.size() != 2)
    return null;

  Expression arg1 = condition.arguments.getExp(0);
  if (! (arg1 instanceof SymbolExp))
    return null;

  SymbolExp symExp = cast(arg1);
  if (! (symExp.getSymbol() instanceof MonoSymbol))
    return null;

  MonoSymbol sym = cast(symExp.getSymbol());

  Expression arg2 = condition.arguments.getExp(1);
  if (! (arg2 instanceof TypeConstantExp))
    return null;

  TypeConstantExp type = cast(arg2);
  if (type.representedType == null)
    return null;

  TypeConstructor tc = notNull(type.representedType);
  mlsub.typing.Monotype[?] parameters;

  if (tc.arity() == 0)
    parameters = null;
  else 
    {
      let originalType = nice.tools.code.Types.rawType(sym.getMonotype());
      if (originalType instanceof mlsub.typing.MonotypeConstructor)
	parameters = originalType.getTP();
      else
	return null;
    }

  try {
    return (sym, Monotype.sure(new mlsub.typing.MonotypeConstructor(tc, parameters)));
  } catch(BadSizeEx e) {
    return null;
  }
}

/****************************************************************
 * Temporary: this should be solved when AST classes are written 
 * in Nice, with precise types for the fields.
 ****************************************************************/

LocatedString name(VarSymbol) = native VarSymbol.name;
mlsub.typing.Polytype getType(Expression) = 
  native mlsub.typing.Polytype Expression.getType();
Statement statement(StatementExp) = native StatementExp.statement;
mlsub.typing.Monotype type(MonoSymbol) = native MonoSymbol.type;
GlobalTypeScope getGlobalTypeScope() = native GlobalTypeScope Node.getGlobalTypeScope();
List<TryStmt.Catch> catches(TryStmt) = native TryStmt.catches;
List<Block.LocalDeclaration> locals(Block) = native Block.locals;
?Statement[] statements(Block) = native Block.statements;
?gnu.bytecode.ClassType staticClass(Arguments) = native gnu.bytecode.ClassType Arguments.staticClass();
List<VarSymbol> findJavaMethods(?gnu.bytecode.ClassType, String, int) = native List JavaClasses.findJavaMethods(gnu.bytecode.ClassType,java.lang.String,int);
List<VarSymbol> findJavaMethods(?gnu.bytecode.ClassType, String) = native List JavaClasses.findJavaMethods(gnu.bytecode.ClassType,java.lang.String);
OverloadedSymbolExp newOverloadedSymbolExp(List<bossa.syntax.VarSymbol>, ?bossa.syntax.LocatedString) = native new OverloadedSymbolExp(List,LocatedString);
Arguments arguments(CallExp) = native CallExp.arguments;

// Retypings needed since java types are not strict.

Block newBlock(?Statement[] statements) = native new Block(Statement[]);
mlsub.typing.Polytype boolPolytype() = native PrimitiveType.boolPolytype;
mlsub.typing.Polytype longPolytype() = native PrimitiveType.longPolytype;

// Local Variables:
// nice-xprogram: "nicec -d \"$HOME/Nice/classes\" --sourcepath=\"$HOME/Nice/src\" --classpath=\"$HOME/Nice/classes\""
// End:
