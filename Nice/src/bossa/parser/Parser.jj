/**************************************************************************/
/*                           B O S S A                                    */
/*        A simple imperative object-oriented research language           */
/*                   (c)  Daniel Bonniot 1999                             */
/*                                                                        */
/*  This program is free software; you can redistribute it and/or modify  */
/*  it under the terms of the GNU General Public License as published by  */
/*  the Free Software Foundation; either version 2 of the License, or     */
/*  (at your option) any later version.                                   */
/*                                                                        */
/**************************************************************************/

// File    : parser.jj
// Created : Thu Jul 01 10:27:05 1999 by bonniot
//$Modified: Mon Oct 09 17:04:56 2000 by Daniel Bonniot $
// Description : Parseur JavaCC pour Nice
//   Tokens based on the Jazz parser

options {
  JAVA_UNICODE_ESCAPE = true;
  DEBUG_LOOKAHEAD = false;
}

PARSER_BEGIN(Parser)

package bossa.parser;

import java.io.*;
import java.util.*;

import bossa.util.*;
import bossa.syntax.*;

import mlsub.typing.TypeSymbol;
import mlsub.typing.TypeConstructor;
import mlsub.typing.MonotypeVar;

class Parser
{
  private static IdentExp symb(String name, Token t)
  {
    return new IdentExp(new LocatedString(name,new Location(t)));
  }
  private static IdentExp symb(Token t)
  {
    return symb(t.image,t);
  }

  private static final Expression trueExp = 
    new IdentExp(new LocatedString("true", Location.nowhere()));

  private static final Expression falseExp = 
    new IdentExp(new LocatedString("false", Location.nowhere()));

  static List globalDefinitions;
}
PARSER_END(Parser)

/***********************************************************************
 * Comments
 ***********************************************************************/

// picked from JavaCC-1.1.jj grammar out of JavaCC examples

/* WHITE SPACE */

SKIP : { " " | "\t" | "\n" | "\r" | "\f" }

/* COMMENTS */

MORE :
{
  "//" : IN_SINGLE_LINE_COMMENT
|
  <"/**" ~["/"]> { input_stream.backup(1); } : IN_FORMAL_COMMENT
|
  "/*" : IN_MULTI_LINE_COMMENT
}

<IN_SINGLE_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <SINGLE_LINE_COMMENT: "\n" | "\r" | "\r\n" > : DEFAULT
}

<IN_FORMAL_COMMENT>
SPECIAL_TOKEN :
{
  <FORMAL_COMMENT: "*/" > : DEFAULT
}

<IN_MULTI_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <MULTI_LINE_COMMENT: "*/" > : DEFAULT
}

<IN_SINGLE_LINE_COMMENT,IN_FORMAL_COMMENT,IN_MULTI_LINE_COMMENT>
MORE :
{
  < ~[] >
}

/***********************************************************************
 * Reserved tokens
 ***********************************************************************/

TOKEN: /* Separators, Delimiters */
{
  < LPAR:       "("   >
| < RPAR:       ")"   >
| < LBRK:       "["   >
| < RBRK:       "]"   >
| < LBRACE:     "{"   >
| < RBRACE:     "}"   >
| < LPRAGMA:    "<*"  >
| < RPRAGMA:    "*>"  >
| < DOT:        "."   >
| < COLON:      ":"   >
| < COMMA:      ","   >
| < SEMI:       ";"   >
| < DOTDOT:     ".."  >
| < MAPSTO:     "->"  >
| < COND:       "?"   >
| < ANY:        "_"   >
| < BACKSLASH:  "\\"  >      
}

TOKEN: /* Operators */
{
  < EQ:      "="   >
| < PLUS:    "+"   >
| < MINUS:   "-"   >
| < POWER:   "**"  >
| < MULT:    "*"   >
| < SLASH:   "/"   >
| < NEQ:     "!="  >
| < MOD:     "%"   >
| < LNOT:    "!"   >
| < BAND:    "&"   >
| < BOR:     "|"   >
| < BXOR:    "^"   >
| < BNOT:    "~"   >
| < LEQ:     "<="  >
| < GEQ:     ">="  >
| < EQEQ:    "=="  >
| < SUB:     "<:"  >
| < LT:      "<"   >
| < GT:      ">"   >
| < LAND:    "&&"  >
| < LOR:     "||"  >
//| < LSHIFT:  "<<"  >
// RSHIFT is not a token: operator >> is made of two consecutive tokens ">"
}

TOKEN: /* Keywords */
{
  < CLASS:      "class"		>
| < INTERFACE:  "interface"	>
| < IMPLEMENTS: "implements"	>
| < EXTENDS:    "extends"    	>

// Packages
| < IMPORT:     "import"     	>
| < PACKAGE:    "package"    	>

| < AT:         "@"          	>
| < EXACTLY_AT: "#"          	>
| < ANY_:	"Any"        	> /* Nice specific */

// Expressions
//| < ASSERT:     "assert"     	>
| < FOR:        "for"        	>
| < IF:         "if"         	>
| < ELSE:       "else"       	>
| < WHILE:      "while"      	>
| < DO:		"do"		>
//| < TRUE:       "true"       	>
//| < FALSE:      "false"      	>
| < FUN:        "fun"        	> /* Nice specific */
| < ALIKE:      "alike"      	> /* Nice specific */
//| < THIS:       "this"       	>
//| < INSTANCEOF: "instanceof" 	>
| < NEW:        "new"        	>
| < NULL:	"null"		>

// Statements
| < RETURN:     "return"     	>
| < VARIABLE:   "var"   	> /* Nice specific */

// modifiers
| < PUBLIC:     "public"     	>
| < PRIVATE:    "private"    	>
| < PROTECTED:  "protected"  	>
| < STATIC:     "static"     	>
| < FINAL:      "final"      	>
| < NATIVE:     "native"     	> /* Nice specific */
| < INLINE:     "inline"        > /* Nice specific */
| < ABSTRACT:   "abstract"   	>

// exceptions
| < THROW:	"throw"		>
| < TRY:	"try" 		>
| < CATCH:	"catch" 	>
| < FINALLY:    "finally"    	>
}


/***********************************************************************
 * Literals
 ***********************************************************************/
TOKEN: /* Different kinds of digits */
{
  < #DIGIT:  ["0"-"9"] >                     // decimal
| < #XDIGIT: ["0"-"9", "a"-"f", "A"-"F"] >   // hexadecimal
| < #ODIGIT: ["0"-"7"] >		     // octal
| < #BDIGIT: ["0", "1"] >		     // binary
}


TOKEN :
{
  < INTEGER_LITERAL:
        <DECIMAL_LITERAL> (["l","L"])?
      | <HEX_LITERAL> (["l","L"])?
      | <OCTAL_LITERAL> (["l","L"])?
  >
|
  < #DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])* >
|
  < #HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
|
  < #OCTAL_LITERAL: "0" (["0"-"7"])* >
}

TOKEN: /* Floating point literals */
{
  < FLOATING_POINT_LITERAL:
        (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? (["f","F","d","D"])?
      | "." (["0"-"9"])+ (<EXPONENT>)? (["f","F","d","D"])?
      | (["0"-"9"])+ <EXPONENT> (["f","F","d","D"])?
      | (["0"-"9"])+ (<EXPONENT>)? ["f","F","d","D"]
  >
|
  < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
}

TOKEN: /* Char literals */
{
  < CHARACTER_LITERAL:
      "'"
      (   (~["'","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )
      "'"
  >
}

TOKEN: /* String literals */
{
  < LSTRING:
      "\""
      (   (~["\"","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )*
      "\""
  >
|
  < BACKQUOTEDSTRING:
      "`"
      (   (~["`","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )*
      "`"
  >
}

/***********************************************************************
 * Identifiers
 ***********************************************************************/
// identifiers are the same as in Java, except that:
// 2. the character ' is allowed
// XXX: conform to Java
TOKEN:
{
  < IDENT: <IDENT_START> (<IDENT_PART>)* >
| < #IDENT_PART:       (<IDENT_START> | <IDENT_DIGIT> | "'") >
| < #IDENT_START:
     [
      "\u0024",
      "\u0041"-"\u005a",
      "\u005f", 
      "\u0061"-"\u007a",
      "\u00c0"-"\u00d6",
      "\u00d8"-"\u00f6",
      "\u00f8"-"\u00ff",
      "\u0100"-"\u1fff",
      "\u3040"-"\u318f",
      "\u3300"-"\u337f",
      "\u3400"-"\u3d2d",
      "\u4e00"-"\u9fff",
      "\uf900"-"\ufaff"
     ]
  >
| < #IDENT_DIGIT:
    [
     "\u0030"-"\u0039",
     "\u0660"-"\u0669",
     "\u06f0"-"\u06f9",
     "\u0966"-"\u096f",
     "\u09e6"-"\u09ef",
     "\u0a66"-"\u0a6f",
     "\u0ae6"-"\u0aef",
     "\u0b66"-"\u0b6f",
     "\u0be7"-"\u0bef",
     "\u0c66"-"\u0c6f",
     "\u0ce6"-"\u0cef",
     "\u0d66"-"\u0d6f",
     "\u0e50"-"\u0e59",
     "\u0ed0"-"\u0ed9",
     "\u1040"-"\u1049"
    ]
  >
}
 
/*
 * Illegal tokens
 */
TOKEN:
{
  < ILLEGAL_TOKEN: (~[]) >
}

/***********************************************************************/
/*                          Grammar                                    */
/***********************************************************************/

String rawString():
{
  Token t;
}
{
  t=<LSTRING>
  { return t.image.substring(1, t.image.length() - 1); }
}

LocatedString ident():
{
  Token t;
}
{
  t=<IDENT> 
  { return new LocatedString(t.image,new Location(t)); }
}

String unlocIdent():
{
  Token t;
}
{
  t=<IDENT> 
  { return t.image; }
}

LocatedString methodName():
{
  LocatedString res;
  Token name;
}
{
  (
   name=<BACKQUOTEDSTRING>
   { res = new LocatedString(name.image.substring(1, name.image.length() - 1),
			     new Location(name),
			     true); }
  |
   res = ident()
  )
  { return res; }
}

/* This allows idents as well as nice specific keywords,
   which is useful to specify native java package, class or method names
*/
Token doted_string_component():
{
  Token t;
}
{
  ( t = <IDENT> 
  | t = "Any"
  | t = "fun"
  | t = "alike"
  | t = "var"
  | t = "inline" 
  | t = "native" 
  )
  { return t; }
}

LocatedString doted_string():
{
  Token t;
  StringBuffer image;
  Location loc;
}
{
  t = <IDENT>
  { image = new StringBuffer(t.image); loc = new Location(t); }

  ( "." t=doted_string_component() 
    { image.append(".").append(t.image); 
      loc.englobe(new Location(t)); } 
  )*

  { return new LocatedString(image.toString(), loc); }
}

LocatedString doted_array_string():
{
  LocatedString res;
}
{
  res=doted_string()
  ( "[]" { res.prepend("["); } )*
  { return res; }
}

Collection strings():
{
  Collection res=new ArrayList();
  LocatedString s;
}
{
  s=ident() { res.add(s); }
  ( "," s=ident() { res.add(s); } )*
  { return res; }
}

LocatedString floatingLiteral():
{
  Token t;
}
{
  t = <FLOATING_POINT_LITERAL> 
  { return new LocatedString(t.image, new Location(t)); }
}

LocatedString integerLiteral():
{
  Token t;
}
{
  t = <INTEGER_LITERAL> 
  { return new LocatedString(t.image, new Location(t)); }
}

/***********************************************************************/
/*                          Type Symbols                               */
/***********************************************************************/

TypeIdent typeConstructorIdent():
{
  LocatedString name;
}
{
  name=doted_string()
  { return new TypeIdent(name); }
}

TypeConstructor typeConstructor():
{
  String name;
}
{
  name=unlocIdent()
  { return new TypeConstructor(name); }
}

TypeIdent typeIdent():
{
  LocatedString name;
}
{
  name=doted_string()
  { return new TypeIdent(name);
  }
}

MonoSymbol monoSymbol():
{
  LocatedString name;
  Monotype type;
}
{
  type=monotype()
  name=ident()
  { return new MonoSymbol(name,type,null); }
}

List monoSymbols():
{
  List res=new ArrayList();
  MonoSymbol name;
}
{
  (
    name=monoSymbol() { res.add(name); }
    ( "," name=monoSymbol() { res.add(name); } )*
  )?
  { return res; }
}

/***********************************************************************/
/*                          Constraints                                */
/***********************************************************************/

TypeSymbol binder(Collection atomics):
{
  TypeIdent first;
  TypeConstructor second;
  MonotypeVar id;
}
{
  "Any" id=monotypeVar()
  { return id;
  }
|
  first=typeIdent() 
  second=typeConstructor()
  { 
    atomics.add(new TypeConstructorLeqCst(second,first)); 
    return second; 
  }
}

List binders(Collection atomics):
{
    List res=new ArrayList();
    TypeSymbol t;
}
{
    t=binder(atomics) { res.add(t); }
    ( "," t=binder(atomics) { res.add(t); } )*
    { return res; }
}

AtomicConstraint atomicConstraint():
{
  Monotype m1,m2;  
  TypeIdent t;
  TypeIdent i;
  AtomicConstraint res;
}
{
(
  LOOKAHEAD(2)
  (
   m1=monotype()
   "<:"
   m2=monotype()
   { res=new MonotypeLeqCst(m1,m2); }
  )
|
  (
   t=typeConstructorIdent()
   ":"
   i=typeIdent()
   { res=new ImplementsCst(t,i); }
  )
)
  { return res; }
}

List atomics(List init):
// if init is null, we just want lookahead
{
  List res=init;
  AtomicConstraint k;
}
{
  k=atomicConstraint() { if(res!=null) res.add(k); }
  ( "," k=atomicConstraint() { if(res!=null) res.add(k); } ) *
  { return res; }
}

Constraint nonVoidConstraint():
{
  List b=null;
  List atoms=new ArrayList();
}
{
  "<"
  ( 
    LOOKAHEAD(atomics(null)) atoms=atomics(atoms) 
  | 
    b=binders(atoms) [ "|" atoms=atomics(atoms) ] 
  )
  ">" 
  { return new Constraint(b,atoms); }
}

Constraint constraint():
{
  Constraint res;
}
{
  ( LOOKAHEAD(nonVoidConstraint())
    res = nonVoidConstraint()
  |
    { res = Constraint.True; }
  )
  { return res; }
}

/***********************************************************************/
/*                          Types                                      */
/***********************************************************************/

//Monotypes

MonotypeVar monotypeVar():
{
  String name;
}
{
  name=unlocIdent()
  { return new MonotypeVar(name); }
}

MonotypeVar taggedMonotypeVar(List tags):
{
  MonotypeVar mv;
}
{
  ( "+" { tags.add(Boolean.TRUE); }
  | "-" { tags.add(Boolean.FALSE); }
  |     { tags.add(null); }
  )
  mv = monotypeVar()
  { return mv; }
}

List monotypeVars(List tags):
{
    List res=new ArrayList(0);
    MonotypeVar var;
}
{
    ( "<" 
      var=taggedMonotypeVar(tags) { res.add(var); }
      ( "," var=taggedMonotypeVar(tags) { res.add(var); } )*
    ">" )?
    { return res; }
}

Monotype monotypeConstructor():
{
    TypeIdent t;
    List p=null;
    Token first,last;
}
{
  { first=getToken(1); }

  // monotypeConstructors with no type parameters (and no "<" ">")
  // are parsed as MonotypeVars, not here.
  // This is fixed during scoping.

    t=typeConstructorIdent() 
    "<" [  p=monotypes() ] ">"
    { if(p==null) p=new ArrayList(0);
      last=getToken(0);

      return new MonotypeConstructor(t,new TypeParameters(p),
				     new Location(first, last)); 
    }
}

FunType funmonotype():
{
    Monotype codom=null;
    List dom=null;
    Constraint cst;
    Token t;
}
{
    "fun" "(" [ dom=monotypes() ] ")" 
    t="(" [ codom=monotype() ] ")"
    { 
      if (codom == null) codom = ConstantExp.synVoidType;
      return new FunType(dom, codom); 
    }
}

Monotype monotype():
{
  Monotype res;
  List p=null;
  Token start, end;
}
{
  (
  res=funmonotype()
|
  start="alike" [ "<" p=monotypes() ">" ]
  { res=new Alike(p, new Location(start)); }
|
  start="<"
  p=monotypes()
  end=">"
  { res = new TupleType(p, new Location(start, end)); }
|
  LOOKAHEAD(monotypeConstructor())
  res=monotypeConstructor()
| 
  res=typeIdent() 
  )
  
// T[] as a shortcut for Array<T>
(
  end="[]" 
  { 
    List tp = new LinkedList();
    tp.add(res);
    Location loc = res.location().englobe(new Location(end));
    res = new MonotypeConstructor
      (new TypeIdent(new LocatedString("Array", loc)),
       new TypeParameters(tp),
       loc);
  }			  
)*

  { return res; }
}

List monotypes():
{
  List res=new ArrayList();
  Monotype t;
}
{
  t=monotype() { res.add(t); }
  ( "," t=monotype() { res.add(t); } )*
  { return res; }
}

List namedMonotypes():
{
  List res=new ArrayList();
  Monotype t;
}
{
  t=monotype() [ident()] { res.add(t); }
  ( "," t=monotype() [ident()] { res.add(t); } )*
  { return res; }
}

TypeParameters typeParameters():
{
  List res=new ArrayList();
  Monotype t;
}
{
  ( "<" 
    t=monotype() { res.add(t); }
    ( "," t=monotype() { res.add(t); } )*
  ">" )
  { return new TypeParameters(res); }
}

/***********************************************************************/
/*                          Classes                                    */
/***********************************************************************/

FormalParameters.Parameter formalParameter():
{
  Monotype t;
  LocatedString id;
  Expression val;
}
{
  t = monotype() 
  [ 
    id = ident() 
    [ 
      "=" val = Expression() 
      { return new FormalParameters.OptionalParameter(t, id, val); }
    ]
    { return new FormalParameters.NamedParameter(t, id); }
  ]
  { return new FormalParameters.Parameter(t); }
}

FormalParameters formalParameters(boolean leaveRoomForThis):
{
  List params = null;
  FormalParameters.Parameter p;
}
{
  { 
    if (leaveRoomForThis) 
    {
      params = new LinkedList();
      params.add(null);
    }
  }
  [
    p = formalParameter() 
    { if (params ==null) params = new LinkedList(); 
      params.add(p); }
    ( "," p = formalParameter() { params.add(p); } )*
  ]
  { return new FormalParameters(params); }
}

MethodDeclaration internalMethodOrFunction(MethodContainer c):
{
  LocatedString name;
  FormalParameters parameters;
  Constraint cst;
  Monotype returnType;
  Statement body = null;
}
{
  cst=constraint()
  returnType=monotype()
  name=methodName()
  "(" parameters = formalParameters(true) ")"
  ( ";" | body = code() )
  
  { return NiceMethod.create(c, name, cst, returnType, parameters, body); }
}

List extensions():
{
  List res=new ArrayList(0);
  TypeIdent name;
}
{
  "extends"
  name=typeIdent() 
    // ignore type parameters
    // they should be checked
    [ "<" ident() ( "," ident() )* ">" ]
  { res.add(name); }
  ( "," name=typeIdent() 
    // ignore type parameters
    // they should be checked
    [ "<" ident() ( "," ident() )* ">" ]
    { res.add(name); } )*
    { return res; }    
}

List interfaces():
{
  List res=new ArrayList(0);
  TypeIdent name;
}
{
  name=typeIdent() 
    // ignore type parameters
    // they should be checked
    [ "<" ident() ( "," ident() )* ">" ]
  { res.add(name); }
  ( "," name=typeIdent() [ "<" ident() ( "," ident() )* ">" ]
    { res.add(name); } )*
    { return res; }
}

void getField(List fields):
{
  MonoSymbol field;
  boolean isFinal=false;
}
{
  ( "final" { isFinal=true; } 
  | "public" | "private"
  )* 
  field=monoSymbol() ";" 
  { fields.add(new NiceClass.Field(field, isFinal)); }
}

ClassDefinition classDefinition():
{
  LocatedString name;
  List parameters;
  List fields=new ArrayList(),methods=null;
  List ext=new ArrayList(0),imp=new ArrayList(0),abs=new ArrayList(0);
  List l;
  List typeParametersVariances = new ArrayList(0);
  boolean isFinal=false, isAbstract=false, isInterface=false;
}
{
(
  [ "final"    { isFinal=true; } 
  | "abstract" { isAbstract=true; }
  ]
  "class"
|
  "interface" { isInterface=true; }
)
  name=ident() 
  parameters=monotypeVars(typeParametersVariances) 

  ( "implements" l=interfaces() { imp.addAll(l); } 
  | "finally" "implements"  l=interfaces() { abs.addAll(l); }
  | l=extensions()      { ext.addAll(l); }
  )*

  ( 
   "{"
   {
     NiceClass res;
     res=new NiceClass
     (name,
      isFinal,isAbstract,isInterface,
      parameters,typeParametersVariances,
      ext,imp,abs);
   }
   // internal fields and methods
   (
      LOOKAHEAD( [ "final" | "public" | "private" ] monoSymbol() ";" )
      getField(fields)
    |
      [ "public" | "private" ]
      (
	LOOKAHEAD( methodBodyDefinitionLookahead() )
	{ MethodBodyDefinition mb; }
	mb = methodBodyDefinition(res)
	{ globalDefinitions.add(mb); }
      |
        { MethodDeclaration m; }
        m = internalMethodOrFunction(res)
        { 
          if (methods == null)
            methods = new ArrayList(5);
          methods.add(m);
	  //globalDefinitions.add(m);
        }
      )
   )* 
   "}"
   {
     res.setFieldsAndMethods(fields, methods);
     return res;
   }
  | 
   "=" "native"
   { LocatedString javaName=null; }
   [ javaName=doted_string() ] ";"
   {
     return new JavaClass
	(name,
	isFinal,isAbstract,isInterface,
	parameters,typeParametersVariances,
	ext,imp,abs,javaName);
   }
  ) 
}

AbstractInterface interfaceDefinition():
{
  LocatedString name;
  List parameters;
  List extensions=null;
  List typeParametersVariances = new ArrayList(0);
  AbstractInterface res;
}
{
  "abstract" "interface"
  name=ident()
  parameters=monotypeVars(typeParametersVariances)
  [ "extends" extensions=interfaces() ]
  "{"
  { res = new AbstractInterface(name,parameters,typeParametersVariances,
				extensions); }
    (
      { MethodDeclaration m; }
      [ "public" | "private" ]
      m = internalMethodOrFunction(res)
      { res.addMethod(m); }
    )*
  "}"
  { return res; }
}

Pattern pattern():
{
  Pattern res = null;
  LocatedString i;
}
{
( res = anonymousPattern(null)
| i = ident()
  ( res = anonymousPattern(i) | { res = new Pattern(i); } )
)
{ return res; }
}

Pattern anonymousPattern(LocatedString name):
{
  TypeIdent tc=null, additional = null;
  Monotype type=null;
  Expression val = null;
  boolean exactlyAt = false;
}
{
  (
    "@" ( val=Literal() | tc=typeIdent() )
  | 
    "#" tc=typeIdent() { exactlyAt = true; }
  )
  [ "(" additional = typeIdent() ")" ]
  [ ":" type=monotype() ]
  { return new Pattern(name, tc, val, exactlyAt, additional, type); }
}

void methodBodyDefinitionLookahead():
{}
{
  methodName() [ "<" strings() ">" ] "("
}

Statement code():
{
  Statement code;
}
{
  ( 
    // A true body
    code=Block()
  |
    // An expression
    { Expression exp; }
    "=" exp=Expression() ";"
    { 
      code = new ReturnStmt(exp);
      code.setLocation(exp.location());
    }
  )
  { return code; }
}

MethodBodyDefinition methodBodyDefinition(NiceClass container):
{
    LocatedString name;
    Pattern p;
    Collection binders=null;
    //List newTypeVars=null;
    LinkedList parameters=new LinkedList();
    Statement body;
    Expression exp;
}
{
    name=methodName()
    [ "<" binders=strings() ">" ]

// introducing new Type variables
//    [ "[" newTypeVars=typeConstructors() "]" ]

    "("
    ( 
	p=pattern() { parameters.add(p); }
	( "," p=pattern() { parameters.add(p); } )*
    )?
    ")"
    body = code()
    { return new MethodBodyDefinition(container,name,binders,
				      //newTypeVars,
				      parameters,body); }
}

MethodDeclaration methodDeclaration():
{
    LocatedString name;
    Monotype returnType;
    FormalParameters parameters;
    Constraint cst;
    MethodDeclaration res;
}
{
  cst=constraint()
    returnType=monotype()
    name=methodName()
    "(" parameters = formalParameters(false) ")"
    
    (
      // Nice method
      ";"
      { res = new NiceMethod(name,cst,returnType,parameters); }
    | LOOKAHEAD(2)
      { Statement body; }
      body = code()
      { res = new ToplevelFunction(name, cst, returnType, parameters, body);}
    |
      "=" 
      (
        "native" res=nativeMethodDeclaration(name,cst,returnType,parameters)
      |
	"inline" 
	{ LocatedString inlinedName; String param = null; }
	inlinedName = doted_string() 
	[
	  "(" [ param=rawString() ] ")"
	]
	";"
	{ res=new InlinedMethod(name,cst,returnType,parameters,
				inlinedName, param); }
      )
    )
  { return res; }
}

// Designing a java method, found thru reflection
MethodDeclaration nativeMethodDeclaration(LocatedString name,
					Constraint cst,
					Monotype returnType,
					FormalParameters parameters):
{
  List javaTypes=null;
  LocatedString method,s=null;
  boolean isNew=false;
}
{
(
  "new" { isNew = true; }
|
  s=doted_array_string() 
)

// if we stop here with a ";", it's a static field
// else it's a method
( 
  ";"
  { method=s; }
| 
  { 
    javaTypes=new ArrayList();
     if(!isNew) javaTypes.add(s);
  }

  method=doted_string()
  "("
  [
    s=doted_array_string() { javaTypes.add(s); }
    ( "," s=doted_array_string() { javaTypes.add(s); } )*
  ]
  ")"  
  ";"
)

  { 
    if(isNew)
      {
	javaTypes.add(0,method);
	return new JavaMethod(method,"<init>",javaTypes,
			      name,cst,returnType,parameters);
      }
    int dot=method.toString().lastIndexOf('.');
    if(dot==-1){
      System.err.println("class or method name missing");
      System.exit(-1);
    }
    
    String methodName=method.toString();
    methodName = methodName.substring(dot+1,methodName.length());
    LocatedString className=method.substring(0,dot);
    
    if(javaTypes!=null)
      return new JavaMethod(className,methodName,javaTypes,
			    name,cst,returnType,parameters);
    else
      return new JavaFieldAccess(className,methodName,
				 name,cst,returnType,parameters);
  }
}

Definition globalVariable():
{
  LocatedString name;
  Monotype t;
  Expression value=null;
}
{
  "var"
  t=monotype()
  name=ident()
  [ "=" value=Expression() ]
  ";"
  { return new GlobalVarDeclaration(name,t,value); }
}

Definition definition():
{
    Definition res;
}
{
  (
    LOOKAHEAD ( "abstract" "interface" )
    res=interfaceDefinition()
  | 
    res=classDefinition()
  | 
    res=globalVariable()
  | 
    LOOKAHEAD( methodBodyDefinitionLookahead() )
    res=methodBodyDefinition(null)
  |
    res=methodDeclaration()
  )
  { return res; }
}

void readDefinitions(List definitions):
{
    Definition d;
    globalDefinitions = definitions;
}
{
  ( 
   d = definition() { definitions.add(d); } 
  )*
  <EOF> 
}

/***********************************************************************/
/*                          Expressions                                */
/***********************************************************************/

Expression intConstantExp():
{
  LocatedString representation;
}
{
  representation=integerLiteral()
  { return ConstantExp.makeNumber(representation); }
}

Expression floatConstantExp():
{
  LocatedString representation;
}
{
  representation=floatingLiteral()
  { return ConstantExp.makeFloating(representation); }
}

StringConstantExp stringConstantExp():
{
  String s;
}
{
  s=rawString()
  { return new StringConstantExp(s); }
}

IdentExp identExp():
{
  LocatedString i;
}
{
  i=ident()
  { return new IdentExp(i); }
}

IdentExp backquotedIdentExp():
{
  Token t;
}
{
  t=<BACKQUOTEDSTRING> 
  { return symb(t.image.substring(1,t.image.length()-1),t); }
}

Expression newExp():
{
  TypeIdent t;
  Expression e;
}
{
  "new" 
  t=typeConstructorIdent()
  ( 
    { Arguments arguments; }
    arguments = arguments(false)
    { return new NewExp(t, arguments); }
  |
    { List args = new LinkedList(); int furtherDimensions = 0; }
    ( LOOKAHEAD(2) "[" e=Expression() "]" { args.add(e); } )+ 
    ( LOOKAHEAD(2) "[]" { furtherDimensions++; } )*
    { return new NewArrayExp(t, args, furtherDimensions); }
  )
}

FunExp funExp():
{
  List formals;
  Constraint cst;
  Statement body;
  Expression exp;
}
{
  "fun" 
  cst=constraint()
  "(" formals=monoSymbols() ")"
  "=>"
  (
    body=Block()
  |
    exp=Expression()
    { 
      body=new ReturnStmt(exp);
      body.setLocation(exp.location());
    }
  )
  { return new FunExp(cst,formals,body); }
}

// ( e1, ..., en )
Expression tupleExp():
{
  List exps;
  Expression e;
}
{
  // A tuple must have at least two elements (thus a ",")
  // which avoids ambiguity with expression grouping thru "(" ")"

  "(" { exps = new LinkedList(); }
  e=Expression() 

  // either we have another expression ans it's a real tuple
  // either we close the parenthesis and it was grouping
  (
    ")" { return e; }
  |
    { exps.add(e); }
    "," e=Expression() { exps.add(e); }
    (
      "," e=Expression() { exps.add(e); }
    )*
    ")"
    { return new TupleExp(exps); }
  )
}

// [ e1, ..., en ]
Expression arrayLiteralExp():
{
  List exps;
  Expression e;
}
{
  "[" { exps = new LinkedList(); }
  
  [
    e=Expression() { exps.add(e); }
    (
      "," e=Expression() { exps.add(e); }
    )*
  ]

  "]"
  { return new LiteralArrayExp(exps); }
}

/****************************************************************
 * Imported Packages
 ****************************************************************/

LocatedString readImports(List imports, Collection opens):
{
  LocatedString pkgName=null, name;
}
{
  [ "package" pkgName=doted_string() ";" ]

  (
   "import" name=doted_string() 

   ( ".*" { opens.add(name.toString()); }
   | { imports.add(name); }
   )
   ";"
  )*
  { return pkgName; }
}

/****************************************************************
 * Modules
 ****************************************************************/

LocatedString module(List definitions,
		     List imports,
	             Collection opens):
{
  LocatedString pkgName;
}
{
  pkgName = readImports(imports, opens)
  {
    readDefinitions(definitions);
    return pkgName;
  }
}

/****************************************************************
 * JAVA statements and expressions
 ****************************************************************/

// Java 1.1 syntax-compliant 
// Derived from the Java1.1.jj file that comes with JavaCC

/*
 * Expression syntax follows.
 */

Expression Expression() :
/*
 * This expansion has been written this way instead of:
 *   Assignment() | ConditionalExpression()
 * for performance reasons.
 * However, it is a weakening of the grammar for it allows the LHS of
 * assignments to be any conditional expression whereas it can only be
 * a primary expression.  Consider adding a semantic predicate to work
 * around this.
 */
{ Expression e1,e2; Token op; Token first,last; }
{
  { first=getToken(1); }

  e1=ConditionalExpression()
  [ 
    op=AssignmentOperator() 
    e2=Expression()
    {
      if(op.image.length()!=1)
        e2=CallExp.create(symb(op.image.substring(0, 1),op),e1,e2);

      e1=AssignExp.create(e1,e2);
    }
  ]
  { 
    last=getToken(0);
    e1.setLocation(new Location(first, last));
    return e1; 
  }
}

Token AssignmentOperator() :
{ Token res; }
{
  (
    res = "="
  |
    res= < assignmentOperator : 
      "*=" | "/=" | "%=" | "+=" | "-=" | 
      "<<=" | ">>=" | ">>>=" | "&=" | "^=" | "|=" 
      >
  )
  { return res; }
}

Expression ConditionalExpression() :
{ Expression res,e1,e2; Token start; }
{
  res=ConditionalOrExpression() 
    [ "?" e1=Expression() start=":" e2=ConditionalExpression() 
      { e2.setLocation(new Location(start, getToken(0))); 
        res=new IfExp(res,e1,e2); }
    ]
  { return res; }
}

Expression ConditionalOrExpression() :
{ Expression e1,e2; Token t; }
{
  e1=ConditionalAndExpression() 
    ( t="||" e2=ConditionalAndExpression() 
      { e1=new IfExp(e1, Parser.trueExp, e2); } )*
  { return e1; }
}

Expression ConditionalAndExpression() :
{ Expression e1,e2; Token t; }
{
  e1=InclusiveOrExpression() 
    ( t="&&" e2=InclusiveOrExpression() 
      { e1=new IfExp(e1, e2, Parser.falseExp); } )*
  { return e1; }
}

Expression InclusiveOrExpression() :
{ Expression e1,e2; Token t; }
{
  e1=ExclusiveOrExpression() 
    ( t="|" e2=ExclusiveOrExpression() 
      { e1=CallExp.create(symb(t),e1,e2); } )*
  { return e1; }
}

Expression ExclusiveOrExpression() :
{ Expression e1,e2; Token t; }
{
  e1=AndExpression() 
    ( t="^" e2=AndExpression() 
      { e1=CallExp.create(symb(t),e1,e2); } )*
  { return e1; }
}

Expression AndExpression() :
{ Expression e1,e2; Token t; }
{
  e1=EqualityExpression() 
    ( t="&" e2=EqualityExpression() 
      { e1=CallExp.create(symb(t),e1,e2); } )*
  { return e1; }
}

Expression EqualityExpression() :
{ Expression e1,e2; Token t; }
{
  e1=InstanceOfExpression() 
    ( ( t="==" | t="!=" ) e2=InstanceOfExpression() 
      { e1=CallExp.create(symb(t),e1,e2); }
      )*
  { return e1; }
}

Expression InstanceOfExpression() :
{ Expression res; }
{
  res=RelationalExpression() //[ "instanceof" Type() ]
  { return res; }
}

Expression RelationalExpression() :
{ Expression e1,e2; Token t; }
{
  e1=ShiftExpression() 
    ( (t="<"|t=">"|t="<="|t=">=") e2=ShiftExpression() 
      { e1=CallExp.create(symb(t),e1,e2); }
      )*
  { return e1; }
}

Expression ShiftExpression() :
{ Expression e1,e2; Token t,t1=null,t2=null; boolean left=false; }
{
  e1=AdditiveExpression() 
    ( 
     ( t="<" { left=true; } [ t1="<" ] 
     | t=">" [ t1=">" [ t2=">" ]] 
     )
     e2=AdditiveExpression() 
     { 
       String func;
       if(left)
         func = t1==null ? "<" : "<<";
       else
         func = t1==null ? ">" : t2==null ? ">>" : ">>>";
       e1=CallExp.create(symb(func,t),e1,e2); }
      )*
  { return e1; }
}

Expression AdditiveExpression() :
{ Expression e1,e2; Token t; }
{
  e1=MultiplicativeExpression() 
    ( ( t="+" | t="-" ) e2=MultiplicativeExpression() 
      { e1=CallExp.create(symb(t),e1,e2); }
      )*
  { return e1; }
}

Expression MultiplicativeExpression() :
{ Expression e1,e2; Token t; }
{
  e1=UnaryExpression() 
    ( (t="*"|t="/"|t="%") e2=UnaryExpression() 
      { e1=CallExp.create(symb(t),e1,e2); }
    )*
  { return e1; }
}

Expression UnaryExpression() :
{ Expression res; Token t=null; }
{
  (
  ( "+" | t="-" ) res=UnaryExpression() 
    { if(t!=null) res=CallExp.create(symb(t),res); }
|
  res=PreIncrementExpression()
|
  res=PreDecrementExpression()
|
  res=UnaryExpressionNotPlusMinus()
  )
  { return res; }
}

Expression PreIncrementExpression() :
{ Expression res; Token t; }
{
  t="++" res=PrimaryExpression()
  { return new IncrementExp(res, true, true); }
}

Expression PreDecrementExpression() :
{ Expression res; Token t; }
{
  t="--" res=PrimaryExpression()
  { return new IncrementExp(res, true, false); }
}

Expression UnaryExpressionNotPlusMinus() :
{ Expression res; Token t; }
{
  ( t="~" | t="!" ) res=UnaryExpression()
  { return CallExp.create(symb(t),res); }

/*
|
  LOOKAHEAD( CastLookahead() )
  CastExpression()
*/

|
  res=PostfixExpression()
  { return res; }
}

/*
// This production is to determine lookahead only.  The LOOKAHEAD specifications
// below are not used, but they are there just to indicate that we know about
// this.
Expression CastLookahead() :
{ Expression res; }
{
  LOOKAHEAD(2)
  "(" PrimitiveType()
|
  LOOKAHEAD("(" Name() "[")
  "(" Name() "[" "]"
|
  "(" Name() ")" ( "~" | "!" | "(" | <IDENTIFIER> | "this" | "super" | "new" | Literal() )
}
*/

Expression PostfixExpression() :
{ Expression res; Token t; }
{
  res=PrimaryExpression() 
  [ "++" { res=new IncrementExp(res, false, true); }
  | "--" { res=new IncrementExp(res, false, false); }
  ] 
  { return res; }
}

/*
Expression CastExpression() :
{ Expression res; }
{
  LOOKAHEAD("(" PrimitiveType())
  "(" Type() ")" UnaryExpression()
|
  LOOKAHEAD("(" Name())
  "(" Type() ")" UnaryExpressionNotPlusMinus()
}
*/

Expression PrimaryExpression() :
{ Expression res; }
{
  res=PrimaryPrefix() 
    ( LOOKAHEAD(2) res=PrimarySuffix(res) )*
  { return res; }
}

Expression PrimaryPrefix() :
{ Expression res; }
{
(
  res=Literal()

/*
|
  "this"
|
  "super" "." <IDENTIFIER>
*/

|
  // This includes the case "(" Expression() ")"
  // which avoids lookahead
  res=tupleExp()
|
  res=arrayLiteralExp() 
|
  //AllocationExpression()
  res=newExp()
|
  // Nice specific
  res=funExp()

/* What's that ?
|
  LOOKAHEAD( ResultType() "." "class" )
  ResultType() "." "class"
*/

|
  //Name()
  res=identExp()

|
  res = backquotedIdentExp()

)
  { return res; }
}

Expression PrimarySuffix(Expression start) :
{ 
  Expression res;
  Arguments args = null;
}
{

/*
  LOOKAHEAD(2)
  "." "this"
|
  LOOKAHEAD(2)
  "." AllocationExpression()
|
*/

  { Token t; }
  t="[" res=Expression() "]"
  { return CallExp.create(symb("get",t),start,res); }

|
  "." res=identExp()
  [ args = arguments(true) ]
  { 
    if (args == null)
      {
	List l = new LinkedList();
	l.add(new Arguments.Argument(start));
	args = new Arguments(l);
      }
    else
      args.addReceiver(start);
    return new CallExp(res, args, true); 
  }

|
  args = arguments(false)
  { return new CallExp(start, args); }
}

Expression Literal() :
{
  Expression res;
  Token t;
}
{
  (
  "null" { res = NullExp.instance; }
| res=intConstantExp() 
| res=floatConstantExp()
| t=<CHARACTER_LITERAL> 
    { res=ConstantExp.makeChar
      (new LocatedString(t.image.substring(1,t.image.length()-1),
			 new Location(t)));
    }
| res=stringConstantExp()
  )
{ return res; }
}

Arguments.Argument argument():
{
  Expression e;
  LocatedString id = null;
}
{
  [ LOOKAHEAD(ident() ":") id = ident() ":" ]
  e = Expression()
  { return new Arguments.Argument(e, id); }
}

Arguments arguments(boolean leaveRoomForReceiver):
{
  List res = new ArrayList();
  Arguments.Argument a;
}
{
  "("
  { if (leaveRoomForReceiver) res.add(null); }
  [
    a = argument() { res.add(a); }
    ( "," a = argument() { res.add(a); } )*
  ]
  ")"
  { return new Arguments(res); }
}

/*
void AllocationExpression() :
{}
{
  LOOKAHEAD(2)
  "new" PrimitiveType() ArrayDimsAndInits()
|
  "new" Name()
    (
      ArrayDimsAndInits()
    |
      Arguments() [ ClassBody() ]
    )
}
*/

/*
 * The second LOOKAHEAD specification below is to parse to PrimarySuffix
 * if there is an expression between the "[...]".
 */
/*
void ArrayDimsAndInits() :
{}
{
  LOOKAHEAD(2)
  ( LOOKAHEAD(2) "[" Expression() "]" )+ ( LOOKAHEAD(2) "[" "]" )*
|
  ( "[" "]" )+ ArrayInitializer()
}
*/




/*
 * Statement syntax follows.
 */

Statement Statement() :
{ Token first, last; Statement res; }
{
  { first = getToken(1); }
  (
  LOOKAHEAD(2)
  res=LabeledStatement()
|
  res=Block()
|
  res=EmptyStatement()
|
  res=StatementExpression() ";"

/*
|
  res=SwitchStatement()
*/

|
  res=IfStatement()
|
  res=WhileStatement()
|
  res=DoStatement()
|
  res=ForStatement()

/*
|
  res=BreakStatement()
|
  res=ContinueStatement()
*/

|
  res=ReturnStatement()
|
  res=ThrowStatement()
|
  res=TryStatement()

/*
|
  res=SynchronizedStatement()
*/
  )
  { 
    last = getToken(0);
    res.setLocation(new Location(first, last));
    return res; 
  }
}

Statement LabeledStatement() :
{ Statement res; }
{
  <IDENT> ":" res=Statement()
  { return res; }
}

Statement Block() :
{ Token first, last; Statement s; List statements; }
{
  { first = getToken(1); }
  "{" 
  { statements = new LinkedList(); }
  ( s=BlockStatement() { statements.add(s); } )* 
  "}"
  { 
    last = getToken(0);
    Statement res = new Block(statements); 
    res.setLocation(new Location(first, last));
    return res;
  }
}

Statement BlockStatement() :
{ Statement res; }
{
  (
  LOOKAHEAD([ "final" ] monotype() <IDENT>)
  res=LocalVariableDeclaration() ";"
|
  res=Statement()
/*
|
  UnmodifiedClassDeclaration()
*/
  )
  { return res; }
}

Statement LocalVariableDeclaration() :
{
  Monotype t;
  LocatedString id;
  Expression e=null;
}
{
  t=monotype()
  id=ident()
  [ "=" e=Expression() ]
  { return new Block.LocalDeclaration(id,t,e); }
}

Statement EmptyStatement() :
{}
{
  ";" { return null; }
}

Statement StatementExpression() :
/*
 * The last expansion of this production accepts more than the legal
 * Java expansions for StatementExpression.  This expansion does not
 * use PostfixExpression for performance reasons.
 */
{ Expression e1; Token first, last; }
{
  { first = getToken(1); }
  (
  e1=PreIncrementExpression()
|
  e1=PreDecrementExpression()
|
  e1=PrimaryExpression()
  [
    "++" { e1=new IncrementExp(e1, false, true); }
  |
    "--" { e1=new IncrementExp(e1, false, false); }
  |
    { Token op; Expression e2; }
    op=AssignmentOperator() 
    e2=Expression()
    {
      if(op.image.length()!=1)
        e2=CallExp.create(symb(op.image.substring(0, 1),op),e1,e2);

      e1.setLocation(new Location(first, getToken(0)));
      e1=AssignExp.create(e1,e2);
    }
  ]
  )
  {
    last = getToken(0);
    e1.setLocation(new Location(first, last));
    return new ExpressionStmt(e1); 
  }
}

/*
Statement SwitchStatement() :
{ Statement res; }
{
  "switch" "(" Expression() ")" "{"
    ( SwitchLabel() ( BlockStatement() )* )*
  "}"
}

void SwitchLabel() :
{
  "case" Expression() ":"
|
  "default" ":"
}
*/

Statement IfStatement() :
/*
 * The disambiguating algorithm of JavaCC automatically binds dangling
 * else's to the innermost if statement.  The LOOKAHEAD specification
 * is to tell JavaCC that we know what we are doing.
 */
{ Statement s1,s2=null; Expression cond; }
{
  "if" "(" cond=Expression() ")" 
    s1=Statement() [ LOOKAHEAD(1) "else" s2=Statement() ]
  { return new ExpressionStmt
    (new IfExp(cond,new StatementExp(s1),
	       (s2==null ? null : new StatementExp(s2)))); }
}

Statement WhileStatement() :
{ Expression cond; Statement body; }
{
  "while" "(" cond=Expression() ")" body=Statement()
  { return new LoopStmt(cond,body,false); }
}

Statement DoStatement() :
{ Expression cond; Statement body; }
{
  "do" body=Statement() "while" "(" cond=Expression() ")" ";"
  { return new LoopStmt(cond,body,true); }
}

Statement ForStatement() :
{ Statement init=null,update=null,body,loop; Expression cond=null; }
{
  "for" "(" [ init=ForInit() ] ";" 
    [ cond=Expression() ] ";" [ update=StatementExpressionList() ] ")" 
    body=Statement()
  { 
    loop=new LoopStmt(cond,body,update,false);
    if(init==null)
      return loop;

    List l = new LinkedList();
    l.add(init);
    l.add(loop);
    return new Block(l);
  }
}

Statement ForInit() :
{ Statement res; }
{
  (
  LOOKAHEAD( [ "final" ] monotype() <IDENT> )
  res=LocalVariableDeclaration()
|
  res=StatementExpressionList()
  )
  { return res; }
}

Statement StatementExpressionList() :
{ Statement s; List statements=new LinkedList(); }
{
  s=StatementExpression() { statements.add(s); }
  ( "," StatementExpression() { statements.add(s); }
  )*
  { return new Block(statements); }
}

/*
Statement BreakStatement() :
{ Statement res; }
{
  "break" [ <IDENTIFIER> ] ";"
}

Statement ContinueStatement() :
{ Statement res; }
{
  "continue" [ <IDENTIFIER> ] ";"
}
*/

Statement ReturnStatement() :
{ Expression val=null; Token t; }
{
  t="return" [ val=Expression() ] ";"
  {
    Statement res = new ReturnStmt(val); 
    res.setLocation(new Location(t));
    return res;
  }
}

Statement ThrowStatement() :
{ Expression e; }
{
  "throw" e=Expression() ";"
  { return new ThrowStmt(e); }
}

Statement TryStatement() :
/*
 * Semantic check required here to make sure that at least one
 * finally/catch is present.
 */
{ TryStmt res; Statement body, b; 
  TypeIdent tc;
  LocatedString i;
}
{
  "try" body=Block()
  { res = new TryStmt(body); }
  ( "catch" "(" tc=typeConstructorIdent() i=ident() ")" b=Block() 
  { res.addCatch(tc, i, b); }
  )*
  [ "finally" b=Block() { res.setFinally(b); } ]
  { return res; }
}

/*
Statement SynchronizedStatement() :
{ Statement res; }
{
  "synchronized" "(" Expression() ")" Block()
}
*/
