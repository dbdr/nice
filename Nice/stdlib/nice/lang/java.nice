/**************************************************************************/
/*                                N I C E                                 */
/*             A high-level object-oriented research language             */
/*                        (c) Daniel Bonniot 2002                         */
/*                                                                        */
/*  This program is free software; you can redistribute it and/or modify  */
/*  it under the terms of the GNU General Public License as published by  */
/*  the Free Software Foundation; either version 2 of the License, or     */
/*  (at your option) any later version.                                   */
/*                                                                        */
/**************************************************************************/

/**
   This file wraps certain methods from the java standard library.
   This is usefull to give them precise types.
   In particular, for methods that return non-null results,
   or that don't accept null arguments.

   @version $Date$
   @author Daniel Bonniot (Daniel.Bonniot@inria.fr)
 */

package nice.lang;

import java.text.*;
import java.io.*;
import java.lang.reflect.*;

//               PACKAGE: java.lang

// result is non-null

Runtime getRuntime() = native Runtime Runtime.getRuntime();
Process exec(Runtime, String[]) = native Process Runtime.exec(String[]);
Class classForName(String name) = native Class Class.forName(String);
Field[] getFields(Class) = native Field[] Class.getFields();
Method[] getMethods(Class) = native Method[] Class.getMethods();
<Any T, Any U> U get(Field, T) = native Object Field.get(Object);
String getName(Field) = native String Field.getName();
Class getType(Field) = native Class Field.getType();

String concat(String, String) = native String String.concat(String);
StringBuffer append(StringBuffer, ?String) = 
  native StringBuffer StringBuffer.append(String);
StringBuffer append(StringBuffer, char) = 
  native StringBuffer StringBuffer.append(char);
StringBuffer append(StringBuffer, char[] str, int offset, int len) =
  native StringBuffer StringBuffer.append(char[], int, int);
char[] toCharArray(String) = native char[] String.toCharArray();
<T> StringBuffer append(StringBuffer, T) = 
  native StringBuffer StringBuffer.append(Object);
<T> StringBuffer insert(StringBuffer, int, T) = 
  native StringBuffer StringBuffer.insert(int, Object);
String substring(StringBuffer, int) = 
  native String StringBuffer.substring(int);
String substring(StringBuffer, int, int) = 
  native String StringBuffer.substring(int, int);

//               PACKAGE: java.text

DateFormat getDateInstance() = native DateFormat DateFormat.getDateInstance();
DateFormat getDateInstance(int style) = native DateFormat DateFormat.getDateInstance(int);

//               PACKAGE: java.io

<Any T> void print   (PrintStream ps, T object) = 
  native void PrintStream.print  (Object);
<Any T> void println (PrintStream ps, T object) = 
  native void PrintStream.println(Object);
String getAbsolutePath (File) = native String File.getAbsolutePath();

/**
   In Java, System.out and System.err are possibly null.
   In Nice we prevent this to happen, and give them a non-null type.
*/

// prevents to stdout and stderr to be set to null
void setStdout (PrintStream ps) = native void System.setOut(PrintStream);
void setStderr (PrintStream ps) = native void System.setErr(PrintStream);

PrintStream stdout () = native System.out;
PrintStream stderr () = native System.err;

/** Convenience: printing on the standard output. */
<Any T> void print   (T object) = System.out.print  (object);
<Any T> void println (T object) = System.out.println(object);

// Serialization
<Any T> void writeObject(ObjectOutput, T) = native void ObjectOutput.writeObject(Object);
<Any T> T readObject(ObjectInput) = native Object ObjectInput.readObject();

//               PACKAGE: java.util

<T> Iterator<T> iterator(Collection<T>) = 
  native Iterator Collection.iterator();
<T> ListIterator<T> listIterator(Collection<T>) = 
  native ListIterator List.listIterator();
<T> java.util.ListIterator<T> listIterator(java.util.List<T>, int) =
  native java.util.ListIterator java.util.List.listIterator(int);

<T, U | U <: T> boolean addAll(Collection<T>, Collection<U>) =
  native boolean java.util.Collection.addAll(java.util.Collection);
<T, U | U <: T> boolean addAll(List<T>, int, Collection<U>) =
  native boolean java.util.List.addAll(int, java.util.Collection);

<T, U, V | T <: V, U <: V> boolean containsAll(Collection<T>, Collection<U>) =
  native boolean java.util.Collection.containsAll(java.util.Collection);
<T, U, V | T <: V, U <: V> boolean removeAll(Collection<T>, Collection<U>) =
  native boolean java.util.Collection.removeAll(java.util.Collection);
<T, U, V | T <: V, U <: V> boolean retainAll(Collection<T>, Collection<U>) =
  native boolean java.util.Collection.retainAll(java.util.Collection);

<E,T | E <: T> boolean contains(java.util.Collection<E>, T) =
  native boolean java.util.Collection.contains(Object);
<E,T | E <: T> boolean remove(java.util.Collection<E>, T) =
  native boolean java.util.Collection.remove(Object);

<E,T | E <: T> int indexOf(java.util.List<E>, T) =
  native int java.util.List.indexOf(Object);
<E,T | E <: T> int lastIndexOf(java.util.List<E>, T) =
  native int java.util.List.lastIndexOf(Object);
<E,T | E <: T> int lastIndexOf(java.util.Vector<E>, T, int) =
  native int java.util.Vector.lastIndexOf(Object, int);
<E,T | E <: T> boolean removeElement(java.util.Vector<E>, T) =
  native boolean java.util.Vector.removeElement(Object);
<E,T | E <: T> int search(java.util.Stack<E>, T) = 
  native int java.util.Stack.search(Object);

/* For List<int> there is an ambiguity between 
     remove(int) and remove(T) (since T=int).
   Therefore we rename remove(int) into removeAt(int).
*/
<T> T removeAt(java.util.List<T>, int) = 
  native Object java.util.List.remove(int);

//retypings for Maps
<K, K0, V | K <: K0> boolean containsKey(Map<K, V>, K0) = 
  native boolean java.util.Map.containsKey(Object);

// The results can be null even if the value type is non-optional.
<K, K0, V0, V | K <: K0, V <: ?V0> ?V0 remove(java.util.Map<K, V>, K0)=
  native Object java.util.Map.remove(Object);
<K, K0, V0, V | K <: K0, V <: ?V0> ?V0 get(java.util.Map<K, V>, K0)=
  native Object java.util.Map.get(Object);
<K, V0, V | V <: ?V0> ?V0 put(java.util.Map<K, V>, K, V)=
  native Object java.util.Map.put(Object, Object);

<K, K0, V0, V | K0 <: K, V0 <: V> void putAll(java.util.Map<K, V>, java.util.Map<K0, V0>)=
  native void java.util.Map.putAll(java.util.Map);

<K, V, V0 | V <: V0> boolean containsValue(java.util.Map<K, V>, V0) = 
  native boolean java.util.Map.containsValue(Object);
<K, K0, V | K <: K0> java.util.Set<K0> keySet(java.util.Map<K, V>) =
  native java.util.Set java.util.Map.keySet();
<K, V, V0 | V <: V0> java.util.Collection<V0> values(java.util.Map<K, V>) =
  native java.util.Collection java.util.Map.values();
<K, K0, V, V0 | K <: K0, V <: V0> java.util.Set<java.util.Map.Entry<K0, V0>> entrySet(java.util.Map<K, V>) = 
  native java.util.Set java.util.Map.entrySet();
<K, V, V0 | V <: V0> boolean contains(java.util.Hashtable<K,V>, V0) = 
  native boolean java.util.Hashtable.contains(Object);

//rename Dictionary methods causing ambiguity in Hashtable
<K, V> V _put(java.util.Dictionary<K, V>, K, V)=
  native Object java.util.Dictionary.put(Object, Object);
<K, V> int _size(java.util.Dictionary<K, V>)=
  native int java.util.Dictionary.size();
<K, V> boolean _isEmpty(java.util.Dictionary<K, V>)=
  native boolean java.util.Dictionary.isEmpty();

/* StringTokenizer inherits from Enumeration, which makes it 
   wrongly parameterized. We ignore that inheritance.
*/

class StringTokenizer = native java.util.StringTokenizer;
