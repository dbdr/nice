/**************************************************************************/
/*                                N I C E                                 */
/*             A high-level object-oriented research language             */
/*                        (c) Daniel Bonniot 2001                         */
/*                                                                        */
/*  This program is free software; you can redistribute it and/or modify  */
/*  it under the terms of the GNU General Public License as published by  */
/*  the Free Software Foundation; either version 2 of the License, or     */
/*  (at your option) any later version.                                   */
/*                                                                        */
/**************************************************************************/

package bossa.syntax;

/**
   Helper functions.

   @version $Date$
   @author Daniel Bonniot (bonniot@users.sourceforge.net)
 */

?LocatedString identString(?Expression);
identString(e) = null;
identString(IdentExp e) = e.ident;
identString(SymbolExp e) = e.getName();
identString(OverloadedSymbolExp e) = e.ident;

boolean isCallTo(CallExp e, String name) 
{
  ?LocatedString f = identString(e.function);
  return (f != null) && f.toString().equals(name);
}

?MonoSymbol localVariable(Expression);
localVariable(Expression e) = null;
localVariable(SymbolExp e)
{
  let sym = e.getSymbol();
  if (! (sym instanceof bossa.syntax.MonoSymbol))
    return null;

  //don't allow nullness inference on global variables.
  if (sym instanceof GlobalVarDeclaration.GlobalVarSymbol && sym.isAssignable())
    return null;

  // no type inference on captured variables
  if (sym.captured)
    return null;

  return sym;
}
localVariable(AssignExp e) = localVariable(e.to);

mlsub.typing.Monotype makeSure(mlsub.typing.Monotype m) = 
  notNull(bossa.syntax.Monotype.sure(nice.tools.typing.Types.rawType(m)));

mlsub.typing.Monotype makeUnsure(mlsub.typing.Monotype m) = 
  notNull(bossa.syntax.Monotype.maybe(nice.tools.typing.Types.rawType(m)));

mlsub.typing.Monotype ensureMonomorphic(mlsub.typing.Polytype type,
					LocalValue decl)
{
  type.simplify();

  if (type.getConstraint != null)
    {
      // If the type is polymorphic, we treat the type variables as soft:
      // we enter them in the context, so they are not generalized.

      // Make sure we are in a local typing context, so the new type variables
      // are discarded when the typechecking of the current method is over.
      MethodDeclaration.enterLocalContext();

      notNull(type.getConstraint).enter(true);
    }

  return type.getMonotype();
}

/*
   Make sure that the error is attached to a location.
   If not, located it a the given located object (which should be a close 
   container of the entity creating the error).
*/
bossa.util.UserError ensureLocated(bossa.util.UserError e, 
				   bossa.util.Located loc)
{
  if (e.location == null)
    e.location = loc.location();
  return e;
}

?(MonoSymbol, mlsub.typing.Monotype) getInstanceof(CallExp condition)
{
  if (! condition.isCallTo("instanceof") || condition.arguments.size() != 2)
    return null;

  let sym = localVariable(condition.arguments.getExp(0));
  if (sym == null)
    return null;

  Expression arg2 = condition.arguments.getExp(1);
  if (! (arg2 instanceof TypeConstantExp))
    return null;

  ?TypeConstructor tc = arg2.getTC();
  if (tc == null)
    return null;

  if (tc == PrimitiveType.arrayTC)
    return (sym, notNull(arg2.representedType));

  mlsub.typing.Monotype[?] parameters = null;

  if (tc.arity() != 0)
    {
      let originalType = nice.tools.typing.Types.rawType(sym.getMonotype());
      if (originalType instanceof mlsub.typing.MonotypeConstructor)
	parameters = originalType.getTP();
      else
	return null;
    }

  try {
    return (sym, Monotype.sure(new mlsub.typing.MonotypeConstructor(tc, parameters)));
  } catch(BadSizeEx e) {
    return null;
  }
}

void resolveCCThis(Statement stmt, Located thisLoc, NiceClass classe)
{
  void missingThisError()
  {
    User.error(thisLoc, "The last statement must be a call to 'this' constructor");
  }

  Block block = cast(stmt);

  if (block.statements.length == 0)
    missingThisError();

  Statement last = block.last;
  if (last instanceof Block)
  {
    resolveCCThis(last, thisLoc, classe);
    return;
  }
  
  if (! (last instanceof ExpressionStmt))
    missingThisError();

  ExpressionStmt expstmt = cast(last);

  if (! (expstmt.exp instanceof CallExp))
    missingThisError();

  CallExp call = cast(expstmt.exp);

  if (! (call.function instanceof IdentExp))
    missingThisError();

  IdentExp ident = cast(call.function);

  if (! ident.toString().equals("this"))
    missingThisError();

  call.function = createOverloadedSymbolExp(new ArrayList(cast(classe).getConstructorCallSymbols()),
					FormalParameters.thisName);
  call.function.setLocation(ident.location());
}

// For bootstrap
void _printStackTraceWithSourceInfo(Throwable t) =
  printStackTraceWithSourceInfo(t);

/****************************************************************
 * Temporary: this should be solved when AST classes are written 
 * in Nice, with precise types for the fields.
 ****************************************************************/

LocatedString name(VarSymbol) = native VarSymbol.name;
Arguments.Argument[] arguments(Arguments) = native Arguments.arguments;
Arguments Argument(List<Arguments.Argument>) = native new Arguments(List);
Arguments Argument(Arguments.Argument[]) = native new Arguments(Arguments.Argument[]);
mlsub.typing.Polytype getType(Expression) = 
  native mlsub.typing.Polytype Expression.getType();
mlsub.typing.Monotype type(MonoSymbol) = native MonoSymbol.type;
GlobalTypeScope getGlobalTypeScope() = native GlobalTypeScope Node.getGlobalTypeScope();
?gnu.bytecode.ClassType staticClass(Arguments) = native gnu.bytecode.ClassType Arguments.staticClass();
?gnu.bytecode.ClassType staticClass(Expression) = native gnu.bytecode.ClassType Expression.staticClass();
List<VarSymbol> findJavaMethods(?gnu.bytecode.ClassType, String, int) = native List JavaClasses.findJavaMethods(gnu.bytecode.ClassType,java.lang.String,int);
List<VarSymbol> findJavaMethods(?gnu.bytecode.ClassType, String) = native List JavaClasses.findJavaMethods(gnu.bytecode.ClassType,java.lang.String);
TypeParameters TypeParameters(List<Monotype>) = native new bossa.syntax.TypeParameters(List);
?String explainNoMatch(Arguments, List<VarSymbol>) = native String Arguments.explainNoMatch(List);
Map<VarSymbol,mlsub.typing.Polytype> types(Arguments) = native Arguments.types;
<T> String map(String, String, String, T[]) = native String bossa.util.Util.map(String, String, String, Object[]);
<T> String map(String, String, String, Collection<T>) = native String bossa.util.Util.map(String, String, String, Collection);
Stack<bossa.link.Alternative> sortedAlternatives(MethodDeclaration) = native Stack bossa.link.Alternative.sortedAlternatives(MethodDeclaration);
LinkedList<VarSymbol> getConstructors(mlsub.typing.TypeConstructor) = native LinkedList TypeConstructors.getConstructors(mlsub.typing.TypeConstructor);
List<VarSymbol> symbols(EnumDefinition) = native EnumDefinition.symbols;
void addValues(Pattern, List<ConstantExp>) = native void Pattern.addValues(List);
?mlsub.typing.TypeConstructor getRuntimeTC(Pattern) = native mlsub.typing.TypeConstructor Pattern.getRuntimeTC();
boolean matchesValue(Pattern, ConstantExp) = native boolean Pattern.matchesValue(ConstantExp);
?LocatedString getName(Pattern) = native LocatedString Pattern.getName();
?mlsub.typing.lowlevel.Kind getKind(mlsub.typing.lowlevel.Element) = native mlsub.typing.lowlevel.Kind mlsub.typing.lowlevel.Element.getKind();
?gnu.expr.Declaration getDeclaration(Expression) = native gnu.expr.Declaration Expression.getDeclaration();
?FieldAccess getFieldAccessMethod(Expression) = native FieldAccess Expression.getFieldAccessMethod();
?FieldAccess getField(Expression) = native FieldAccess Expression.getField();
?mlsub.typing.Monotype Types_getTypeParameter(mlsub.typing.Polytype, int) = native mlsub.typing.Monotype nice.tools.typing.Types.getTypeParameter(mlsub.typing.Polytype, int);
?mlsub.typing.Monotype Types_getTypeParameter(mlsub.typing.Monotype, int) = native mlsub.typing.Monotype nice.tools.typing.Types.getTypeParameter(mlsub.typing.Monotype, int);
mlsub.typing.Monotype[?] Types_parameters(mlsub.typing.Polytype) = native mlsub.typing.Monotype[] nice.tools.typing.Types.parameters(mlsub.typing.Polytype);
?mlsub.typing.TypeConstructor head(mlsub.typing.Monotype) = native mlsub.typing.TypeConstructor mlsub.typing.Monotype.head();
?ClassDefinition ClassDefinition_get(mlsub.typing.TypeConstructor) = native ClassDefinition ClassDefinition.get(mlsub.typing.TypeConstructor);
?gnu.bytecode.ClassType getSuperclass(gnu.bytecode.ClassType) = native gnu.bytecode.ClassType gnu.bytecode.ClassType.getSuperclass();
int[?] getUsedArguments(Arguments, VarSymbol) = native int[] Arguments.getUsedArguments(VarSymbol);
?mlsub.typing.Constraint getConstraint(mlsub.typing.Polytype) = native mlsub.typing.Constraint mlsub.typing.Polytype.getConstraint();
MonoSymbol[?] getMonoSymbols(FormalParameters) = native MonoSymbol[] FormalParameters.getMonoSymbols();
mlsub.typing.AtomicConstraint[?] AtomicConstraint_substitute(java.util.Map<mlsub.typing.TypeSymbol,mlsub.typing.TypeSymbol>, AtomicConstraint[?]) = native mlsub.typing.AtomicConstraint[] mlsub.typing.AtomicConstraint.substitute(java.util.Map, mlsub.typing.AtomicConstraint[]);
NiceClass classe(Constructor) = native Constructor.classe;
FormalParameters parameters(MethodDeclaration) = native MethodDeclaration.parameters;
?gnu.expr.Expression getInitializer(NiceClass) = native gnu.expr.Expression NiceClass.getInitializer();
void addConstructorCallSymbol(NiceClass, MethodDeclaration.Symbol) = native void NiceClass.addConstructorCallSymbol(MethodDeclaration.Symbol);
gnu.expr.Expression callSuperMethod(NiceClass, gnu.bytecode.Method) = native gnu.expr.Expression NiceClass.callSuperMethod(gnu.bytecode.Method);
Module module(Definition) = native Definition.module;
?Definition importMethod(NiceClass, gnu.bytecode.Method) = native Definition NiceClass.importMethod(gnu.bytecode.Method);
boolean equals(LocatedString, LocatedString) = native boolean LocatedString.equals(LocatedString);
?mlsub.typing.TypeConstructor getSuperClass(ClassDefinition) = native mlsub.typing.TypeConstructor ClassDefinition.getSuperClass();
List<mlsub.typing.Interface> interfaces(ClassDefinition) = native ClassDefinition.interfaces;
List<FormalParameters.Parameter> getParameters(FormalParameters, TypeScope) = native List FormalParameters.getParameters(TypeScope);
mlsub.typing.AtomicConstraint[?] resolvedConstraints(MethodContainer) = native MethodContainer.resolvedConstraints;
mlsub.typing.TypeSymbol[?] getBinders(MethodContainer) = native mlsub.typing.TypeSymbol[] MethodContainer.getBinders();
?Expression value(FormalParameters.Parameter) = native Expression FormalParameters.Parameter.value();
?LinkedList<MethodDeclaration.Symbol> getConstructors(TypeConstructor) = native LinkedList TypeConstructors.getConstructors(TypeConstructor);
?gnu.bytecode.Attribute get(gnu.bytecode.AttrContainer, String) = native gnu.bytecode.Attribute gnu.bytecode.Attribute.get(gnu.bytecode.AttrContainer, String);

// Retypings needed since java types are not strict.
mlsub.typing.Polytype boolPolytype() = native PrimitiveType.boolPolytype;
mlsub.typing.Polytype longPolytype() = native PrimitiveType.longPolytype;
mlsub.typing.Polytype voidPolytype() = native PrimitiveType.voidPolytype;
mlsub.typing.Monotype boolType() = native PrimitiveType.boolType;
mlsub.typing.Monotype intType() = native PrimitiveType.intType;
mlsub.typing.Monotype longType() = native PrimitiveType.longType;
gnu.expr.QuoteExp trueExp() = native gnu.expr.QuoteExp.trueExp;
gnu.expr.QuoteExp voidExp() = native gnu.expr.QuoteExp.voidExp;

// Local Variables:
// nice-xprogram: "../bin/nicec -d ../classes"
// End:
