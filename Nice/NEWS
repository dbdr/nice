nice (0.9.11)

  * maybeNull, a counterpart to notNull, can now be used to inform the compiler
    that a value returned from Java libraries without retyping might be null,
    in order to avoid a warning:

      let prng = SecureRandom.getInstance("ARCFOUR");

      // Test if a bad implementation has returned null instead of an exception
      if(maybeNull(prng) == null) workaround();

  * Nullness analysis of assignments (RFE 681385) is implemented, so that the
    compiler is more clever about when a value cannot be null.
    It is now possible to write:

      Foo func( ?Foo foo ) {
        if( foo == null ) {
          foo = new Foo();
        }
        // Do some operations
        return foo;
      }

    since Nice will detect that foo can't be null after the "foo = new Foo()",
    and will propagate this information outside of "if( foo == null )" checks.
  * Allow value returns in void methods. It's useful when exiting from
    the method in a branch after doing a single operation. For instance,
    instead of:

      void add(int x)
      {
        if (x == 0)
          {
            buffer.append("ZERO\n");
            return;
          }
        ...
      }

    one can now more simply write:

      void add(int x)
      {
        if (x == 0)
          return buffer.append("ZERO\n");
        ...
      }

  * Added instanceof on option types. For instance 'x instanceof ?String'
    is equivalent to 'x == null || x instanceof String'.
  * Unbounded wildcard type parameters are supported (as in Java 5). This
    allows to avoid using type parameters when their value is not important.
    For instance:

      boolean isShort(List<?> l) = l.size() < 10;

  * Added binary integer literals. Examples: '0B1011' '0b1010_0000_0101_1111'.
  * Removed octal integer literals.
  * Automatic message is generated for assertions, containing
    the failed expression and location of the failed assertion
    (which is useful when the code was stripped from debug symbols,
    or printStackTraceWithSourceInfo wasn't used).
  * Forced (always checked) assertions now are available.

      !assert 0==1; // fails always
      ?assert 0==1; // fails if assertions enabled
       assert 0==1; // fails if assertions enabled

  * Some error messages locate more precisely the source of the error.
  * It is now possible to use Nice "interface" method from Java
    (that is, method signatures are preserved in interface bytecode).
  * Generated bytecode is slightly more compact and references less "system"
    Nice classes, so that those do not need to be automatically added to
    generated jars.
  * Exit the JVM with exit code 1 when the main program finishes with an
    uncaught exception.
  * niceunit supports a --jar option to test jars.
  * Bug fixes (negative int hex literals, ...)

 --

nice (0.9.10)

  * Better error messages for wrong constructor calls and method
    implementations with wrong parameter names.
  * Default value of fields can be overridden in subclasses. For instance:
      class A {
        int x = 1;
      }
      class B extends A {
        override x = 5;
      }
    This also works for final fields.
  * Imported methods can be generalized. That is, it is possible to
    define a new method which is more general than an existing one,
    and the existing method will be recognized as a special case of the
    general one. For instance, consider:

      abstract interface Addable<T> { void add(T item); }
      interface java.util.Collection implements Addable;

    Method java.util.Collection.add() is recognized as implementing
    the new add method, which makes Collection a valid Addable class.
  * Java methods and fields with parametric types are given a type with
    UnknownTypes as type parameters instead of being ignored.
  * Number of errors and warning are printed to the console.
  * Improved source information for debuggers.
  * Generated classes are smaller, thanks to smaller debugging information.
  * Niceunit now reports test failures with the source file and line number
    information for the failed assertion.
  * Native compilation with gcj is twice faster.
  * An important part of the Nice compiler has been converted from Java to
    Nice itself! A lot of thanks go to Luc Perrin and Arjan Boeijink for this
    achievement.
  * Bug fixes (disallowed redefinition of parameters, execution order of
    initializers in super classes, visibility checking of java classes,
    cyclic custom constructors, methods and fields in classes with less type
    parameters, 'this' in custom constructors, comparison of possibly null
    values with primitive values, ... )

 -- Fri, 25 Feb 2005 17:13:05 +0100

nice (0.9.9)

  * Assertions about the type of variables are used by the typechecker, so that
    casts are not necessary. For instance:

      Object o = ...;
      // We happen to know by design than the object must be a string
      assert o instanceof String;
      // Here o can be used as a string without cast

    The same construct can be used with '!= null' tests.
  * java.lang.Class is now parametrized by the type it represents.
    In particular, newInstance is now declared in nice.lang with

      <T> T newInstance(Class<T>);

    This make it possible to write type-safe code that uses reflexion,
    in particular when using class literals.
  * Subclasses can have less type parameters than their parent by fixing
    the value of the others. For instance:

      class BitField implements List<boolean> { ... }

  * Improved speed of coverage tests for some methods.
  * Much improved nicedoc tool.
  * Removed the '--strict' compiler option.
  * Underscores are allowed and ignored in literal numbers. example:
      long x = 1_000_123_000_456;
  * The indexing operator supports multiple arguments now. For instance
    'a[x,y]' is syntactic sugar for 'a.get(x,y)'.
  * Lists now support a wide array of slicing and indexing
    operations. There is a new bit of syntax, '@', which indicates
    the index of the last item in a list, which can be used for working
    with indexes relative to the end of the list, instead of the beginning.

    For instance, given a list of ints from 0 to 6 called
    'intList':
	intList[@] is 6,
	intList[@-1] is 5,
	intList[1..2] is the list [1,2].
	intList[1..@-1] is a list of all but the first and last
		elements of ints, i.e., [1,2,3,4,5]
	intList[1..] is a list of all but the first element of intList
	intList[..] is a complete copy of intList
	intList[..@-1] is a list of all but the last element of intList
	intList[int i => i % 2 == 0] is a list of all the even ints
		in intList: [0,2,4,6]
	Several more options are available, an update to the manual will
	reflect this.

 -- Wed, 22 Sep 2004 01:53:29 +0200

nice (0.9.8)

  * Nice methods are now compiled inside classes whenever possible. This does
    not make any difference for Nice programs, but simplifies integration with
    Java tools and usage of Nice code from Java sources.
  * Is is now possible to make a class of an imported package implement
    an interface defined in the current package, with:
      class some.pkg.ClassName implements MyInterface;
  * Type parameters can always be qualified with nullness markers '?' and '!'.
    For instance, a class declaration can be
      class OptionalRef<T>
      {
        // The value might be null
        ?T value;
      }
  * Allow calls to Java methods defined in a Java class that implements
    several Java interfaces declaring that same method, like
    java.io.ObjectOutputStream.flush()
  * Reduced compilation time (about 20%) and memory consumption.
  * Smaller generated bytecode.
  * Fixed native compilation using gcj. It used to block when gcj produced
    too much output.

 -- Tue, 29 Jun 2004 20:53:03 +0200

nice (0.9.7)

  * Methods can be overridden using the override keyword:
      class A {
        A doSomething() { ... }
      }
      class B extends A {
        override B doSomething() { ... }
      }
    An important aspect is that the return type can be more precise than the
    original type (covariance).
    Overriding without the override keyword (a la Java) is accepted but
    generates a warning.
  * When importing a java package, it is possible to specify that its methods
    do not accept null arguments:
      import some.java.pkg.* (!);
    Individual methods can be treated specially by retyping them.
  * The 'Any' keyword is now deprecated.
  * Global constants and global variables are now initialized in a proper order
    when one depends on another, both directly and through the default
    implementation of a method.
  * The Eclipse plugin now works with Eclipse 3.0 M7 (although 2.1 is still the
    preferred version at this point).

 -- Mon,  8 Mar 2004 19:03:15 +0100

nice (0.9.6)

  * It is now possible to create custom constructors:
      class Point { double x; double y; }

      new Point(double angle, double distance)
      {
        this(x: distance * cos(angle), y: distance * sin(angle));
      }
    It is then possible to create a Point with either
    new Point(x: ..., y: ...) or new Point(angle: ..., distance: ...).
  * Additional fields can be defined for enums and enums can implement
    interfaces, for instance:
      enum Coin(int value) implements Currency
	{penny(1), nickel(5), dime(10), quarter(25)}
  * Alternative syntax for calling methods that takes an anonymous function
    with no arguments. For example 'loop(5) { doSomeThing(); }' is a
    shorthand for 'loop(5, () => { doSomeThing(); });'
  * "using" statement, as in C#, defined in nice.lang using (!) the above
    syntax.
  * Expression-local variables: variables that are declared as the argument
    of a method call, and that are visible to the other arguments.
    A typical usage is, still using the above syntax:
      using(PrintStream s = ...) {
        s.println("...");
      }
  * Stricter parsing of expressions used as statements.
  * Improved performance for arrays used as lists.
  * New methods (in package nice.functional) for working with iterators
    and generators.
  * Applications that stop because of an uncaught exception will now
    print a stack trace the include correct Nice source files and line numbers.
    Applications that need to print a stack trace can do so by using
    printStackTraceWithSourceInfo(e) (defined in nice.lang) instead of
    e.printStackTrace(), and similarly for versions that specify a stream
    or writer to print into.
  * A super call can have types to resolve ambiguities. Example of usage:
      foo(BarSub b, s) = super(Bar, String);
  * Fixed the file locations in the RPM package, and added automatic
    registration of the emacs mode for the SuSE Linux distribution.
  * Bug fixes (checking of local variables in a call position, make it possible
    to use new Object() and dispatch on Object again, code generation of
    integer constants, overloading of function symbols, printing of string
    literals with escaped chars, implicit 'this' for functional fields, ... )

 -- Fri, 20 Feb 2004 18:04:18 +0100

nice (0.9.5)

  * Added new syntax for patterns in method implementations.
    'Type param' for 'param@Type' and '#Type param' for 'param#Type
    example usage:
      class Dummy {
	int x;
	equals(Dummy other) = this.x == other.x;
      }
    This syntax should be more consistent and familiar, and is now
    preferred to the old one, which will eventually be deprecated.
  * Object is now recognized as a super-type of every type. This allows
    easier use of Java libraries, creation of heterogeneous collections,
    and type-safe handling of values with unknown types.
  * String concatenation can be performed by mere juxtaposition of string
    literals and simple expressions, which are converted into strings. For
    instance:
      println("x has value "x" and y has value "y);
  * There is now complete support for serialization:
    readObject, writeObject, readResolve and writeReplace methods can be
    written and be recognized by the serialization process.
    A custom serialVersionUID can be set for Nice classes using a final field:
        class X implements java.io.Serializable {
          final long serialVersionUID = 123456789L;
        }
  * Enums are serializable now and have a family() method that returns a list
    of all elements in that enum.
  * Simplified some complex types in error messages.
  * Safe dynamic type inference in presence of anonymous and local functions.
  * Unused local variables will give a warning.
  * Nested multi-line comments are allowed.
  * Empty statements (made of a single ';') have been removed. This avoids the
    risk of an accidental ';' changing the meaning of a statement. Empty
    statements are very rarely needed, and can easily be replaced by '{}'.
  * The Emacs mode is updated to work with recent versions of GNU and XEmacs.
  * Reduced memory usage when repeatedly compiling in the same JVM (eclipse
    plugin, ant, testsuite, ...).
  * The compiler is now more clever about loading imported Java classes
    only if they are actually used. This reduces memory usage and improves
    compilation speed.
  * Bug fixes (accessing static fields of an superclass or interface,
    compilation of polymorphic tuples, captured 'this' in initializer,
    duplication of constructors in bytecode, disappearing contracts during
    recompilation, ... )

 -- Thu, 11 Dec 2003 16:05:18 +0100

nice (0.9.4)

  * The compiler now knows that the statement 'assert false' never terminates.
    Therefore that statement can be used in a branch that is known to be
    unused, without needing to return a dummy value when the method does not
    return void.
  * Added source-level debugging information for recent debuggers (jsr 45).
  * Constraints on class type parameters can be written as a prefix of
    class declarations:
      <Bound T> class MyClass<T> { ... }
    This syntax is required when Bound is an abstract interface.
  * Generate more efficient code for anonymous functions that do not capture
    the environment. This also avoids a memory leak.
  * Retypings of classes and methods that can't be found by the compiler only
    generate a warning now. This makes it possible to add JDK 1.4 specific
    retypings without failing when compiling with an older JDK.
  * Bug fixes (error reporting for certain overloading by expected type,
    recompilation of overloaded methods with the same bytecode types).

 -- Thu, 20 Nov 2003 00:18:02 +0100

nice (0.9.3)

  * Improved type inference by instanceof tests.
  * Added multi line string literals. String that start and end with """
    may take multiple lines and will include the line breaks.
  * Existing interfaces can (like classes) implement abstract interfaces:
      interface packagename.SomeInterface implements AbstractInterface;
  * Bugfixes (various pretty printing issues, type hole in instanceof
    inference, calls to abstract methods, chained assignments with arrays like
    'x = arr[y] = z;', error messages of integer dispatch, reachability of
    labeled breaks, ...)

 -- Sat, 18 Oct 2003 12:01:50 +0200

nice (0.9.2)

  * Removed the concept of function. Now everything is a method, which is more
    flexible.
    The syntax that used to define a function is still valid: it now
    declares a method together with a default implementation. Example:
      class A {
        // Declares a method f, with a default implementation that returns 1.
        int f() = 1;
      }

      class B extends A {
        // Override f for B:
        // When called with an argument of type B, f returns 2.
        f() = 2;
      }
    The same applies for methods outside classes.
  * More dynamic type inference implemented. The type of a local variable is
    made more precise after a successful instanceof:
    A a = ...;
    if (a instanceof B)
      // Here a has type B
  * Classes that implement java.lang.Cloneable now automatically support
    the clone method.
  * The deprecated 'main(args) { ... }' syntax for the main function is not
    supported anymore. Please use instead: 'void main(String[] args) { ... }'
  * Floating point literals are now of type double by default, adding
    'f' or 'F' at the end will make them of type float.
  * Method parameters that are not dispatched on simply get their declared
    type. This avoids some type errors, and simplifies error messages.
  * Some more methods are added to nice.lang.
  * Implemented simple range expressions. 'a..b' is an immutable list of int's
    from a to b (inclusive) where b >= a. Example usage:
      for (i : 1..10) println(i);
  * In local variable declarations like 'var x = exp', the inferred type
    for x is int when 'exp' is of type byte or short. This will avoid
    unexpected behaviour in some cases.
  * Bugfixes (incrementation of byte local variables, require a default value
    for global variables, ...)

 -- Sat, 13 Sep 2003 02:40:46 +0200

nice (0.9.1)

  * Final fields can be overridden in sub-classes with a more precise type
    and a different default value. In particular, this removes the need for
    a cast when reading the field's value from an instance of the sub-class.
      class A
      {
        final List<String> names;
      }
      class B extends A
      {
        override LinkedList<String> names;
      }
    This is only possible for final fields for type safety reasons.
  * A class can now have initializers, which are executed each time an instance
    is created.
      class A
      {
        // Initializer
        {
          // Initialization code goes here.
        }
      }
  * Package-level constants and variables are now automatically initialized
    in the correct order when they directly depend on each other.
  * The type declaration in the enhanced for loop is now optional but only if
    the type is inferable.
      int[] array = [1,2,3,4,5];
      for (elem : array) println(elem);
  * The compiler now warns about non-existing sourcepath entries.
  * Bugfixes (parameter's default value referring to previous parameters, ...)

 -- Sat,  9 Aug 2003 23:19:41 +0200

nice (0.9.0)

  * Implemented dispatch by integer comparison. An example:
    int abs(int n);
    abs(n>=0) = n;
    abs(n<0) = -n;
    The compiler knows that method abs is covered for all int values.
    It's also possible to compare with global constants:
    let int bar = 5;
    String foo(int n);
    foo(n<bar) = "smaller than bar";
    foo(bar) = "equal to bar";
    foo(n>bar) = "larger than bar";
  * Added dispatch on String literals. This can be used as a switch on Strings.
      void foo(String color);
      foo("blue") { ... }
      foo("red") { ... }
      foo(color) { println("unknown color: " + color); }
  * Added dispatch on global constants whose value is a literal. Example:
      let int specialValue = 7;
      void foo(int n);
      foo(n) { /*do something*/ }
      foo(specialValue) { /*do something else*/ }
  * Dispatch on global constants works also for unique references(new objects).
      class Color {}
      let Color Red = new Color();
      let Color Blue = new Color();
      String name(Color color);
      name(color) = "unknown color";
      name(Red) = "red";
      name(Blue) = "blue";
  * Implemented simple enums. The above color example can be simplified to:
      enum Color { Red, Blue, Green }
      String name(Color);
      name(Red) = "red";
      name(Blue) = "blue";
      name(Green) = "green";
    The compiler knows now that the method "name" is completely covered.
  * The names of the arguments of a default implementation of a method must
    be the same as the names in the declaration.
      void foo(int number);
      foo(number) { ... } //correct
      //foo(num) { ... } //not valid
    This is important, so that a typo in a global constant or enum name
    in a method implementation does not lead to a default implementation.
  * Added operator ** to calculate powers of longs, doubles and BigIntegers.
  * The 'char' type is no longer a subtype of int. The integer unicode
    representation of a character c can be obtained by int(c).
  * Interfaces can now implement (finally or not) abstract interfaces.
  * 'true' and 'false' are now keywords, and better code is generated for them.
    The termination properties of loops with literal boolean values are now
    recognized, as in Java.
  * Redefining of local variables in their scope is not allowed anymore.
  * Method bodies with a single statement can be written without brackets.
    example: void foo() = throw new Exception();
  * It is possible to bind the values of tuple arguments to functions:
      String foo((String s, String t)) = s + t;
    It also works for anonymous functions:
      List<(String, int)> tuples = new ArrayList();
      tuples.add(("abc", 1));
      tuples.foreach(((String name, int number)) =>
        println("name: "+name+" number: "+number) );
  * Archives (generated with the -a option) can now be used to distribute
    Nice libraries.
  * In the bytecode, two versions of the instance constructors are created:
    one which lists all the fields, the other one that lists only those
    without default value. This is useful when instantiating Nice classes
    from Java source or by reflexion, especially if a no-arg constructor is
    required for some reason.
  * Bugfixes (Parsing of nested tuples, global constants of type char,
    overloading resolution of method implementations with additional tc's, ...)
  * Improved some error messages.

 -- Fri, 18 Jul 2003 01:40:25 +0200

nice (0.8)

  * Stable version, based on 0.7.9
  * Added operators to compute with java.math.BigInteger (+,-,*,/,%,...).
  * In functional types, '()' is always equivalent to 'void'. Ex: int->()
  * Anonymous functions that never return normally can be used with any
    return type.
  * Bugfixes (some cases of optional parameters, allowing arbitrarily nested
    tuples on the left side of an assignment, recursion for local functions,
    allow method parameter's default values to refer to 'this' when the method
    is declared inside a class, declaration of multiple local variables,
    nested type parameters in method declarations, improved some error messages,
    resolving overloading between fields and global variables, implemented
    nullness inference for local constants).

 -- Wed, 14 May 2003 16:30:15 +0200

nice (0.7.9)

  * Allow implementations of methods declared in Java to dispatch on
    all their arguments. So now we can at last write:
      class A {
        int x;
        equals(that@A) = this.x == that.x;
      }
  * In a method implementation, binding the type parameters should now
    be done in front:
      <T> T foo(T);
      <T> foo(x@String) { T res = x; ... }
    It is also possible to bind the runtime class of a parameter, by adding
    ": name" at the end of the pattern. This is needed in some cases:
      <Collection C, T, U> C<U> bar(C<T>, T->U);
      bar(x, f) { ... }
      <C,T,U> bar(l@List : L, f) // L is the runtime class of l.
      {
        L<U> res = similarEmptyCollection(l);
        res.add(f(l[0]));

        // Now we use the fact the res is a list.
        // Therefore, it would be impossible to declare its type as C<U>.
        res.add(res[0]);

        // By returning res, we need the fact that it is a subtype of C<U>,
        // so we could not declare its type as List<U>.
        return res;
      }
  * Changed the syntax for local variables. The "final" keyword is deprecated
    now for local variables, use "let" instead. In addition to the standard
    "type name = ..." syntax two new forms are allowed:
    let [ type ] name [ = expression ] ;
    var [ type ] name [ = expression ] ;
    At least a type or a default value are required.
    The type can only be left away when the compiler is able to interfere
    the type which is not always possible.
    A non function example to show some aspects the new syntax:
      let int[] arr = [1,2,3,4]; // here type interference doesn't work.
      List<int> list = new ArrayList();
      list.addAll(arr);
      for(let iter = list.iterator(); iter.hasNext();) {
        let String s;
        var i = iter.next();
        if (i % 2 == 0) { s = "even"; }
        else { s = "odd"; }
        println(i.toString()+" is "+s);
      }
  * Added global constants similar to the global variables, the syntax is:
    let type name = somexpression ;
  * Integer values can used as arrays of bits, as in
      if (x[index]) ...
      x[index] = true;
  * Compilation does not fail anymore if some classes on the classpath
    have an invalid bytecode format.
  * Improved error messages for possibly null values in assignments (Daniel),
    and for incorrect calls to constructors (Bryn Keller).
  * Bugfix (overloaded symbols used inside && or || expressions, ...).

 -- Sat, 19 Apr 2003 10:40:02 +0200

nice (0.7.8)

  * Some error messages are more useful.
  * All operators are inlined and some operators (&&, ||, ! and comparisons)
    and if-statements generate better bytecode now.
  * Improved bytecode generation of pre/post-condition.
  * Implemented the enhanced for loop (similar to java 1.5 proposal).
    The loop works on arrays and collections, example:
    int[] arr = [1,2,3,4,5];
    for (int i : arr) print(i);
  * Improved handling of nullness tests, as in:
      x != null && x.dereference()
    and
      x == null || x.dereference()
  * Allow functions returning a value to be used as arguments where
    functions returning void are expected.
  * Allow ?(T[]) syntax for optional arrays, as an alternative to T[?].
  * Allow // comments at the end of a file, without a trailing newline.
    Also report more nicely /* comments that are not closed.
  * Allow nested tuples on the left side of a tuple assignment:
      (String a, (String b, String c)) = ("a", ("b", "c"));
  * Bugfixes (solved problems with case-insensitive filenames, ...).

 -- Tue,  8 Apr 2003 21:03:43 +0200

nice (0.7.7)

  * Methods taking a boolean parameter can now dispatch on the cases
    'true' and 'false':
      boolean not(boolean);
      not(true) = false;
      not(false) = true;
  * Method can also dispatch on integer and character literals, but there is
    always a default case required. An example:
      long fac(long n);
      fac(n@0) = 1;
      fac(n@long) = n*fac(n-1);
    Another example using the shorter syntax:
      int fib(int n);
      fib(1) = 1;
      fib(2) = 1;
      fib(n) = fib(n-2) + fib(n-1);
  * The '@' in '@null' patterns is deprecated, '@' should be omitted.
  * The 'fun' keyword for anonymous functions is deprecated. It can be omitted.
  * New policy for typing calls to Java methods. By default, the typing
    is more convenient, considering arguments as possibly null, and
    results as non-null. The '--strict' compiler option enforces a stricter
    heuristic.
    Additionally, arrays are always considered to have non-null component
    types.
    Final fields are considered non-null.
  * Static native methods are not (wrongly) imported in the global name space
    anymore. One can just use them as in Java, by prefixing with the class
    name:
      String s = Integer.toHexString(100);
    It's now also possible to refer to static methods as anonymous functions:
      String[] s = integerArray.map(Integer.toHexString);
  * Allow the ?(T->U) syntax for optional functional types as an alternative
    to T ?-> U, and void -> Type as an alternative to () -> Type.
  * Added the 'concat' function on arrays, and sort function for lists.
  * Faster compilation for large projects with many classes.
  * Bugfixes (anonymous functions inside functionals with contracts,
    typechecking loop tests, other fixes to reduce the difference between
    what the parser accepts and the compiler can handle, ...).

 -- Wed,  5 Mar 2003 13:30:30 +0100

nice (0.7.6)

  * Implemented optional parameters' default value referring to
    previous parameters, like 'to' in the following example:
      <T> T[] slice(T[] array, int from = 0, int to = array.length - 1);
  * Added syntax for multiple comparisons (thanks to Arjan Boeijink):
      if (0 < i < N) ...
  * Fixed several issues with generic collections.
    In particular, for List<int> there was an ambiguity between
      remove(int) and remove(T) (since T=int).
    Therefore we renamed remove(int) into removeAt(int).
  * Added float(_) and char(_) primitives for value conversion.
  * Allows anonymous functions to be made of one statement without braces:
      (char c => if (Character.isLetter(c)) wordBuffer.append(c))
      (char c => assert c != 'Z')
  * Method type parameters can be constrained to be non null by prefixing
    with the ! character, just like class type parameters.
  * 'this' can now be left implicit even in implementations of methods
    declared externally to a class.
  * Parser support for public-read and private-write fields (experimental).
  * Performance improvement for anonymous functions and for polymorphic
    usage of arrays.
  * Improved references to source lines in the bytecode (stack traces).
  * Bugfixes (using anonymous functions while overriding native methods,
    automatic array conversions in polymorphic code, nested literal primitive
    arrays, mutually dependent packages, ...).
  * For convenience of command-line tools (shells) with automatic completion,
    we allow a directory name instead of the corresponding package name.
    That is, we replace '/' (which is illegal in package names) by '.'.
    It is therefore possible to type 'nicec my/package/'.

 -- Tue, 21 Jan 2003 17:20:36 +0100

nice (0.7.5)

  * Addition of design by contract: assertions, pre- and post-conditions.
  * A class type parameter can now be constrained to be a non-option type,
    by prefixing it with the ! character:
      class Elem<!A> { ... }
  * Addition of the || operator on optional values:
      e1 || e2
    evaluates e1 and returns its value without evaluating e2 if e1 is not null.
    If e1 evaluates to null it returns the value of e2.
    It is equivalent to e1 != null ? e1 : e2, except e1 is not evaluated twice.
    This operator is handy to sequence expression to produce a value:
      find(n@Node, elem) = find(n.left, elem) || find(n.right, elem);
  * New numeric narrowing functions: int(x), short(x) and byte(x),
    equivalent to Java's (int), (short) and (byte).
  * Short anonymous functions made of one assignment now return void. Allows:
      [1,2,3].foreach(int j => i += j);
    instead of
      [1,2,3].foreach(int j => { i += j; });
  * Arrays created with 0 elements have a non-option component type:
      String[] s0 = new String[0];
      ?String[] s1 = new String[1];
    They can still be used with option component type:
      ?String[] s0 = new String[0];
  * Changed suffix notation for multiple-dimension array types, to match
    initialization. Dimensions are listed in order, instead of reverse order.
    For instance,
      String[][?]
    is the type of a non-null array of optional arrays of strings.
  * Changed typing for creation of arrays with multiple dimensions.
    The dimensions that are not initialized are given an option type:
      String[][?] s = new String[1][];
    This accounts for the fact that s[0] == null, thus ensuring type safety.
  * Forbade @null patterns for method arguments that cannot be null.
  * Report duplicate implementations of a method with the same patterns.
  * Bugfixes (compilation of tuples with primitive types using subtyping,
    closures, returning a value inside try/finally or synchronized, ...).
  * Fixed the nicec script on Max OS X, when gcj is not present.

 -- Wed, 20 Nov 2002 13:32:55 +0100

nice (0.7.4)

  * Added support for Generic Java types. This allows in particular to use
    java.util.* collections with parameterized types (e.g. List<String>).
    These replace the previous (very partial) collections from nice.lang.
    Functionals on collections (foreach, map, has, ...) are applicable
    to java.util Collections.
  * Allow class type parameters to be constrained:
      class MyClass<Bound P> { ...}
    This allow MyClass to be instantiated only on subtypes of Bound
    in the constructor and the class methods.
  * Fixed error message for calling new on an interface or Java abstract
    class, and when a class or interface (indirectly) implements itself.
  * Allow the <T> syntax to introduce type variables, in addition to
    <Any T> (that is, any is optional). This is consistent with GJ,
    and the syntax for class type parameters.
  * Improved overloading resolution when used on functions with optional
    arguments.
  * Removed the old syntax <T1, T2> for tuples. Use (T1, T2) instead.
  * Bugfixes (forward reference to constructor in field initializer,
    anonymous functions in field initializer, override of void native method,
    tuples, ...).

 -- Tue,  1 Oct 2002 14:51:21 +0200

nice (0.7.3)

  * Allow subclasses of Java classes to call any of the super-constructors,
    not just the no-arg one. The arguments of the super-constructor used are
    just the first, not-named arguments of the automatic constructor.
  * The 'main(args) { ... }' syntax for the main function is deprecated.
    Please use instead: 'void main(String[] args) { ... }'
  * Improved compilation speed, especially for programs using many classes
    (up to 2x faster).
  * Fixed implicit access to fields of the current class in ambiguous
    situations, and when overriding native methods.
  * Other fixes (issue with recompilation of up-to-date packages, ...)

 -- Wed,  4 Sep 2002 08:04:47 +0200

nice (0.7.2)

  * Implemented synchronized statements.
  * Implemented bitwise complement and "get bit" on long integers.
  * Allow Nice classes and interfaces to implement and extend java interfaces
    without pretending they are classes.
  * Allow to declare that existing classes implement new abstract interfaces.

 -- Fri, 23 Aug 2002 12:51:21 +0200

nice (0.7.1)

  * Fields can be accessed without specifying "this".
  * The default syntax for tuple types is now (T1, ..., Tn)
  * Made "instanceof" work with classes defined in the same package.
  * Enhanced error message for invalid calls to anonymous functions.
  * Correctly infer the return type of all anonymous functions.
  * Generate better code when using anonymous functions.
  * Bugfixes (break statement, anonymous functions used in global variables
              inside complex expressions, polymorphic arrays used
	      across packages, super, ...).

 -- Fri,  2 Aug 2002 09:29:19 +0200

nice (0.7.0)

  * Added the possibility to call "super" from a method implementation.
  * Added support for transient and volatile fields.

 -- Tue, 16 Jul 2002 12:59:47 +0200

nice (0.6)

  * First stable version, based on 0.5.6
  * Fixed an error message for incorrect calls to anonymous functions.

 -- Thu, 11 Jul 2002 10:52:52 +0200

nice (0.5.6)

  * Added the ".class" construct.
  * Completed the "instanceof" construct.
  * Calling new T[size] where T is a type variable now correctly returns
    an array with optional element type. It can be filled with non-null values
    using the 'fill' function, e.g.
        fill(new T[size], int i => f(x[i]))

 -- Sat,  6 Jul 2002 12:44:51 +0200

nice (0.5.5)

  * Merged --classpath and --packagepath options into --classpath.
    This is simpler, and the behaviour is more logical.
  * The compiler is now reentrant. This should not make any difference
    when running from the command-line, but this is important to allow
    tools written in Java or Nice (like the Ant task, the testsuite,
    an IDE) to call the compiler repetitively, without starting a new JVM.
  * Fixed several bugs (export of optional functional types, ...).

 -- Fri, 21 Jun 2002 09:18:20 +0200

nice (0.5.4)

  * Added short syntax for anonymous functions:
      int i => i+1          /* function of one argument */
      (int i, int j) => i+j /* function of several arguments */
  * Renamed `iter` to `foreach`. `iter` is still accepted,
    but will probably be removed sometime in the future.
    Together with the syntax change for anonymous functions,
    this gives a nice and user-friendly syntax for iterations:

      names.foreach(String name => println(name));

  * Anonymous function cannot appear where a statement is expected
    (some expressions can). This is good since an anonymous function which
    is not called cannot have side-effects, and therefore this case was
    meaningless and probably buggy.
  * Fixed inference for possibly null variables in some complex cases.
  * Other bugfixes (valid error message when trying to implement a function).

 -- Daniel Bonniot <daniel@blanche>  Thu, 13 Jun 2002 16:30:27 +0200

nice (0.5.3)

  * Testing a variable against null in a while or for loop condition now
    allows to use it as non-null, until is it assigned a possibly null value.
  * Added many mathematical functions (sin, cos, round, max, min, ...).
    This makes it unnecessary to prefix them with (java.lang.)Math.
  * It is now possible to use "." (current directory) in
    the --classpath argument (this needed a workaround for
    a probable bug in Sun's URLClassLoader, at least in 1.3).
  * Other bugfixes (creating arrays of "exotic" types, using arrays in field
    initializers).

 -- Thu, 30 May 2002 12:57:46 +0200

nice (0.5.2)

  * Calls to constructors now require using the fields' names.
  * Produce a meaningful message when a field is used without using
    an object to load it from.
  * Fixed parsing problem with (x.f)(e) as a statement.
  * Allow classpath to be set for external java classes without
    requiring to include Nice's bootstrap classes.
  * Functions are generated in a class "<packagename>.fun", so that
    they can be called from code written in Java.

 -- Tue,  7 May 2002 15:23:53 +0200

nice (0.5.1)

  * Constructors now take the initial values of the object's fields as
    named arguments. A field declaration (inside a class declaration)
    now accepts an optional value after "=" (like in Java). This value
    is used as the default if the field is not mentioned in a call to
    the constructor. A field with no default value must be mentioned
    in every call to the constructor.
  * Compile properly functions declared inside abstract interfaces.
  * Allow optional parameters to be used across modules.

 -- Mon, 29 Apr 2002 19:07:24 +0200

nice (0.5)

  * Recognise the standard arrow notation for functional types
      int->int  (int,int)->int  (int->int)->int
    The old notation fun(int)(int) is deprecated and will be removed
    before version 1.0
  * Assigning a possibly null value to a variable of non-null type
    now produces an error instead of a warning.
  * Fixes bug that considered that
      int a = 10, b;
    initializes both a and b to 10.
  * Fixed variable initialization analysis for do-while loops.
  * Make the compiler compatible with JDK 1.4
  * Fixed bug on MS-Windows with archive creation because of the
    case-insensitivity of the file system.
  * Fixed creation of archive from up-to-date packages stored in jar.
  * Accept anonymous functions that do nothing.
  * Editor (emacs) mode is now driven by command-line instead of inspecting
    the EMACS environment variable. This works around a bug in emacs 21.2.1
    and might be more portable. Also makes it easier to write a nice-mode
    for other editors without changing the existing code or script.

 -- Thu, 18 Apr 2002 14:44:13 +0200

nice (0.0.020405)

  * Accepts constants:
      final String s1 = "Java style";
      final s3 = "The type of constants can be omitted";
  * More compatibility with Java:
    - checks that all statements are reachable
    - checks that local variables are assigned before use
    - classes can be declared public or private
    - ...
    More than half of the Jacks (java compiler testsuite) tests now pass!
    Most failures come from the difference in the syntax of method declaration.
  * Arrays of void values are forbidden. They most probably originate from
    a bug in the source program.
  * Better handling of inhomogeneous tuples with native types
    (e.g. <int, long>).
  * Better wrapping/unwrapping code for arrays used as Collections.
  * Bugfixes for some polymorphic operations on arrays.
  * Bugfixed the bitshift operators >>, >>> and <<.

 -- Fri,  5 Apr 2002 13:01:17 +0200

nice (0.0.020226)

  * Fixed bug that prevented using "this" in overridden native methods.
  * Better error messages for method calls with wrong number of arguments.
  * Accept methods with no implementation when their domain is empty.
  * Abstract interfaces are fully qualified just like classes and
    correctly list their super-interfaces in the package interface.
    This really makes it possible to use them across packages.
  * Various other bugfixes.

 -- Tue, 26 Feb 2002 16:06:00 +0100

nice (0.0.020205)

  * Allow multiple variables to be defined together, as in:
  	int x = 1, y;
  * Allow variable declaration in tuple affectation:
  	(int x, int y) = f(0);
  * Added 'break' and 'continue' statements.
  * Implemented 'do' loops.
  * Allow overriding of native java methods. It is now possible to
    define a subclass of a java class or interface and override the methods.
  * Changed compilation scheme for method alternatives. This results in
    shorter class files and more intuitive stack traces.

 -- Tue,  5 Feb 2002 13:15:03 +0100

nice (0.0.020105)

  * Allowed to change the type of native class fields.
    This allows in particular to use System.out.println() and such again.
  * Fixed type of if expressions in the presence of non-nullness inference.

 -- Sat,  5 Jan 2002 14:50:37 +0100

nice (0.0.020102)

  * Made nicec smart about when a local variable might be null.
  * Added the 'instanceof' and '~' (bitwise complement) keywords.
  * Do not stop at the first syntax or type error in more situations.
  * Enhanced error messages.
  * Emacs mode: allow to interactively set the compiler's location
    (the string variable 'nice-program').

 -- Wed,  2 Jan 2002 20:31:31 +0100

nice (0.0.011219)

  * Initial Release.

 -- Tue, 18 Dec 2001 23:23:32 +0100
