
package nice.lang;

/****************************************************************
 * Collection
 ****************************************************************/

interface Collection<T>
{
  int size();
  boolean empty();
  void iter(fun(T)());

  alike<T> filter(fun(T)(boolean));
  <Any U> alike<U> map( fun(T)(U) );
}

empty(c@Collection) = c.size() == 0;

/**
   Equivalent definitions outside the interface:
<Any T> int size(Collection<T>);
<Any T> void iter(Collection<T>, fun(T)());

<Collection C, Any T, Any U> C<U> map(C<T>, fun(T)(U));
<Collection C, Any T> C<T> filter(C<T>, fun(T)(boolean));
*/

/** A growable Collection */
interface Container<T> 
  extends Collection<T> 
{
  void add(T);
}

interface Stack<T> extends Container<T>
{
  T pop();
  T top();
  void push(T);
}

add(s@Stack, elem) = s.push(elem);

/** An ordered Collection */
interface Sequence<T> 
  extends Collection<T>
{
  T    get(int);    // alternative syntax: a[i]
  void set(int, T); // alternative syntax: a[i]=v

  <Any U> U foldLeft(fun(U, T)(U), U);
}

iter(l@Sequence, f)
{
  for(int i=0; i<l.size; i=i+1)
    f(l.get(i));
}

foldLeft<T, U>(l@Sequence, f, init)
{
  U res = init;
  l.iter(fun(T elem) => { res = f(init, elem); });
  return init;
}

/*
val fold_left : f:('a -> 'b -> 'a) -> init:'a -> 'b list -> 'a

    List.fold_left f a [b1; ...; bn] is f (... (f (f a b1) b2) ...) bn. 

val fold_right : f:('a -> 'b -> 'b) -> 'a list -> init:'b -> 'b

    List.fold_right f [a1; ...; an] b is f a1 (f a2 (... (f an b) ...)). Not tail-recursive. 
*/
/** A growable ordered Collection. */
interface List<T> extends Sequence<T>, Container<T>, Stack<T>
{
  T remove(int index);
}

// List based stacks

push(l@List, elem) = l.add(elem);
pop(l@List) = l.remove(l.size() - 1);
top(l@List) = l.get(l.size() - 1);

//  filter<C,T>[<L>](l@List : L<T>, test)
//  {
//    L<T> res;
//    res=emptyCollection(l);

//    l.iter(fun(T elem) => if (test(elem)) res.add(elem) );

//   return res;
//  }

/****************************************************************
 * Functional Lists
 ****************************************************************/

abstract class FList<T> 
  implements Sequence 
  finally implements Collection
  {}

final class Nil<T>  extends FList<T> {}
final class Cons<T> extends FList<T> { T head; FList<T> tail; }

<Any T> Cons<T> cons(T, FList<T>);
cons<T>(elem, t)
{
  Cons<T> res = new Cons();
  res.head = elem;
  res.tail = t;

  return res;
}

size(l@Nil ) = 0;
size(l@Cons) = 1+size(l.tail);

get(l@Cons, n) = n == 0 ? head(l) : get(l.tail, n-1);
get<T>(l@Nil, n)
{
  if (true) throw new IndexOutOfBoundsException("Valid indexes: 0 .. " + (l.size - 1));
  return l.get(n);
}

set(l@Cons, n, elem)
{
  if(n == 0) 
    head(l)=elem; 
  else 
    l.tail.set(n-1, elem);
}

set(l@Nil,  n, elem) { throw new Exception(); }

map(l@Nil, f) = new Nil();

map(l@Cons, ff) = cons(ff(l.head), map(l.tail, ff));

filter(l@Nil , test) = l;
filter<C,T>(l@Cons, test)
{
  FList<T> res = filter(l.tail, test);
  return test(l.head) ? cons(l.head, res) : res;
}

/****************************************************************
 * Wrappers for java.util.Collection
 ****************************************************************/

// unsafe !
/*
<Any T> T next(java.util.Iterator) = 
  native Object java.util.Iterator.next();
<Any T> List<T> list(java.util.List);
list<T>(l)
{
  Vector<T> res = makeVector(l.size());

  for(java.util.Iterator i = l.iterator(); i.hasNext();)
    res.add(i.next());

  return res;
}
*/
/****************************************************************
 * LinkedList
 ****************************************************************/

final class JavaList<T> implements List
{
  java.util.List impl;  

  size() = this.impl.size();
  get(index) = cast( this.impl.get(index) );
  set(index, elem) { this.impl.set(index, cast(elem)); }
  add(elem) { this.impl.add(cast(elem)); }
  remove(index) = cast(this.impl.remove(index));
}

/** The returned iterator is always non-null */
java.util.Iterator iterator(java.util.List) =
  native java.util.Iterator java.util.List.iterator();

<Any T> JavaList<T> javaList()
{
  JavaList<T> res = new JavaList();
  res.impl = new java.util.ArrayList();
  return res;
}

<Any T> JavaList<T> javaList(java.util.List impl)
{
  JavaList<T> res = new JavaList();
  res.impl = impl;
  return res;
}

map<C, T, U> (l@JavaList, f)
{
  JavaList<U> res = javaList();
  for(java.util.Iterator i = l.impl.iterator(); i.hasNext(); )
    res.add(f(cast(i.next())));
  return res;
}

filter<C,T>(l@JavaList, test)
{
  JavaList<T> res = javaList();
  for(java.util.Iterator i = l.impl.iterator(); i.hasNext(); )
    {
      T elem = cast(i.next());
      if (test(elem))
	res.add(elem);
    }
  return res;
}


/****************************************************************
 * Vector
 ****************************************************************/

class Vector<T> 
  implements List 
  finally implements Collection
{
  Array<T> elements;
  int length;

  remove<T>(index)
  {
    if (this.length <= index)
      throw new IndexOutOfBoundsException();
    T res = this[index];
    for (int i = index+1; i < this.length; i++)
      this[i - 1] = this[i];
    this.length--;
    // Would avoid possible memory leaks, but difficult to type
    //this[this.length] = null;
    return res;
  }
}

<Any T> Vector<T> makeVector(int);
makeVector<T>(len)
{
  Vector<T> res = new Vector();
  res.elements = new T[len]; 

  return res;
}

size(v@Vector) = v.length;
get(v@Vector, index) = get(v.elements, index);
set(v@Vector, index, element) = v.elements.set(index, element);

map<C,T,U>(v@Vector, f)
{
  Vector<U> res = makeVector(v.length);

  for(int i=0; i<v.length; i=i+1)
    res.elements.set(i, f( v.get(i) ));

  return res;
}

add<T>(v@Vector, element)
{
  if(v.elements==null)
    {
      v.elements = new T[10];
      v.length = 0;
    }

  if (v.length >= 
      v.elements.size)
    v.elements = v.elements.resize(v.length * 2);

  v.elements.set(v.length, element);
  v.length = v.length+1;
}

filter<C,T>(v@Vector, test)
{
  Vector<T> res = new Vector();
  res.length=0;

  v.iter(fun(T elem) => { if(test(elem)) res.add(elem); });

  return res;
}

/****************************************************************
 * Standard operations
 ****************************************************************/

<Any T> T find(Sequence<T>, fun(T)(boolean));
find(s, test)
{
  for(int i=0; i<s.size(); i=i+1)
    if(test(s.get(i)))
      return s.get(i);

  if (true) throw new java.util.NoSuchElementException();
  return s.get(0);
}

boolean or(Sequence<boolean>);
or(s)
{
  for(int i=0; i<s.size(); i=i+1)
    if(s.get(i))
      return true;

  return false;
}

long max(Sequence<long>);
max(s)
{
  long res=0;

  for(int i=0; i<s.size(); i=i+1)
    if(s.get(i)>res)
      res=s.get(i);

  return res;
}

/****************************************************************
 * Printing
 ****************************************************************/

/*
We need overriding of native methods for this
toString(s@Sequence)
{
  if (s.size() == 0)
    return "[]";

  StringBuffer buf = new StringBuffer();
  buf.append("[");
  buf.append(s[0].toString());
  for (int i=1; i<s.size(); i++)
    {
      buf.append(", ");
      buf.append(s[i].toString());
    }
  buf.append("]");
  return buf.toString();
}
*/

print(p@PrintStream, s@Sequence)
{
  if (s.size() == 0)
    {
      p.println("[]");
      return;
    }
  p.print("[");
  p.print(s[0]);
  for (int i=1; i<s.size(); i++)
    p.print(", " + s[i]);
  p.print("]");
}
  
/****************************************************************
 * Map
 ****************************************************************/

interface Map<Key,Element> = native java.util.Map;
class Hashtable<Key,Element> implements Map = native java.util.HashMap;

<Any Key, Any Element> Hashtable<Key, Element> hashtable() = 
  native new java.util.HashMap();

<Any Key, Any Element> Element get(Map<Key, Element>, Key) = 
  native Object java.util.Map.get(Object);

<Any Key, Any Element> Element put(Map<Key, Element>, Key, Element) = 
  native Object java.util.Map.put(Object, Object);
