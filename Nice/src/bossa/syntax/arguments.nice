/**************************************************************************/
/*                                N I C E                                 */
/*             A high-level object-oriented research language             */
/*                        (c) Daniel Bonniot 2004                         */
/*                                                                        */
/*  This program is free software; you can redistribute it and/or modify  */
/*  it under the terms of the GNU General Public License as published by  */
/*  the Free Software Foundation; either version 2 of the License, or     */
/*  (at your option) any later version.                                   */
/*                                                                        */
/**************************************************************************/

package bossa.syntax;

import java.util.*;
import bossa.util.*;

/**
   Arguments of a function call.

 */
public class Arguments
{
  Argument[] arguments;

  /** Hold real parameter, after default parameters
      and parameter reordering has been done.
  */
  Expression[?] computedExpressions = null;

  java.util.Map<VarSymbol, Expression[]> applicationExpressions = new java.util.HashMap();
  // Map actual arguments to formal arguments. Indexes are 1-based.
  java.util.Map<VarSymbol, int[]> usedArguments = new java.util.HashMap();
  
  java.util.Map<VarSymbol,mlsub.typing.Polytype> types = new java.util.HashMap();

  public void addReceiver(Expression value)
  {
    if (arguments[0] != null)
      Internal.error("No room for \"receiver\"");
    
    arguments[0] = new Argument(value: value);
  }

  void add(Expression arg, ?LocatedString name)
  {
    Argument[] newArgs = cast(new Argument[arguments.length + 1]);
    System.arraycopy(arguments, 0, newArgs, 0, arguments.length);
    newArgs[arguments.length] = new Argument(value: arg, name: name);
    arguments = newArgs;
  }

  int size()
  {
    if (computedExpressions != null)
      return notNull(computedExpressions).length;
    else
      return arguments.length;
  }
  
  Argument get(int num)
  {
    return arguments[num];
  }
  
  Expression getExp(int num)
  {
    if (computedExpressions != null)
      return notNull(computedExpressions)[num];
    else
      return arguments[num].value;
  }

  void setExp(int num, Expression value)
  {
    arguments[num].value = value;
  }

  void noOverloading()
  {
    for (int i = arguments.length; --i>=0; )
      arguments[i].value = arguments[i].value.noOverloading();
  }
  
  void computeTypes()
  {
    for (int i = arguments.length; --i>=0; )
      arguments[i].value.getType();
  }
  
  Expression[] inOrder()
  {
    if (arguments.length == 0)
      return [];

    Expression[] res = cast(new Expression[arguments.length]);
    
    for (int i = arguments.length; --i>=0; )
      res[i] = arguments[i].value;

    return res;
  }
  
  ?gnu.bytecode.ClassType staticClass()
  {
    let res = this.getExp(0).staticClass();
    
    if (res != null)
      // the first argument was fake, remove it
      {
	Argument[] newArgs = cast(new Argument[arguments.length - 1]);
	System.arraycopy(arguments, 1, newArgs, 0, newArgs.length);
	arguments = newArgs;
      }
    
    return res;
  }
  
  Expression[?] getExpressions(VarSymbol s) = applicationExpressions.get(s);
  
  int[?] getUsedArguments(VarSymbol s) = usedArguments.get(s);

  /**
     return true if there are arity non-tagged arguments.
  */
  boolean plainApplication(int arity, VarSymbol symbol)
  {
    if (arguments.length != arity)
      return false;

    for (int i = 0; i<arguments.length; i++)
      if (arguments[i].name != null)
	return false;

    applicationExpressions.put(symbol, this.inOrder());
    return true;
  }

  toString() = "(" + Util.map("", ", ", "", arguments) + ")";

  public String toStringInfix()
  {
    StringBuffer res = new StringBuffer("(");
    for (int i = 1; i<arguments.length; i++)
      res.append(arguments[i].toString() + 
		 (i + 1 < arguments.length ? ", " : ""));
    return res.append(")").toString();
  }

  public String printTypes()
  {
    StringBuffer res = new StringBuffer("(");
    for (int i = 0; i<arguments.length; i++)
      res.append((arguments[i].name == null ? "" : notNull(arguments[i].name) + ":") + 
		 arguments[i].value.getType() + 
		 (i + 1 < arguments.length ? ", " : ""));
    return res.append(")").toString();
  }
}

public Arguments createArguments(List<Argument> args)
{
  return new Arguments(arguments: args.toArray());
}

public class Argument
{
  private Expression value;
  ?LocatedString name = null;

  toString() = (name == null ? "" : notNull(name) + ":" ) + value;
}
