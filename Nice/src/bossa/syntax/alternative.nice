/**************************************************************************/
/*                                N I C E                                 */
/*             A high-level object-oriented research language             */
/*                        (c) Daniel Bonniot 2004                         */
/*                                                                        */
/*  This program is free software; you can redistribute it and/or modify  */
/*  it under the terms of the GNU General Public License as published by  */
/*  the Free Software Foundation; either version 2 of the License, or     */
/*  (at your option) any later version.                                   */
/*                                                                        */
/**************************************************************************/

// TODO: this class belongs in bossa.link
package bossa.syntax;

import bossa.util.*;

/**
   An alternative present in the source code.

 */
public class SourceAlternative extends Alternative implements Located
{
  private MethodImplementation implementation;

  location() = implementation.location();

  printLocated() = implementation.location() + ": " + this.toString();

  methodExp() = implementation.getRefExp();
}

public Alternative createSourceAlternative(MethodImplementation implementation)
{
  let res = new SourceAlternative(implementation.getDeclaration().getName().toString(),
	implementation.getPatterns(), implementation: implementation);

  res.add(implementation.getDeclaration().getFullName());

  ?java.util.Iterator<MethodDeclaration> specializedMethods = 
      cast(implementation.getDeclaration().listSpecializedMethods());
  if (specializedMethods != null)
    while(specializedMethods.hasNext())
      res.add(specializedMethods.next().getFullName());

  return res;
}

/**
   An alternative for calling an existing Java method.

 */
class JavaAlternative extends Alternative
{
  MethodDeclaration method;

  methodExp() = method.getCode();
}

public Alternative createJavaAlternative(bossa.syntax.MethodDeclaration method)
{

  Pattern[] patterns = notNull(nice.tools.typing.Types.parameters(method.getType())).
	mapToArray(mlsub.typing.Monotype param => createPattern(null,
		nice.tools.typing.Types.concreteConstructor(param),
         	nice.tools.typing.Types.isSure(param)));

  return new JavaAlternative(method.getName().toString(), patterns,
	method: method);
}

/**
   An alternative imported from a compiled package.

 */
public class ImportedAlternative extends Alternative
{
  private gnu.expr.Expression code;
  private Location loc;

  methodExp() = code;

  location() = loc;
}

/**
 * When read from a bytecode file.
 */
public void readImportedAlternative(gnu.bytecode.ClassType c, gnu.bytecode.Method method, Location location)
{
  ?gnu.bytecode.MiscAttr attr = cast(gnu.bytecode.Attribute.get(method, "definition"));
  if (attr == null)
    // this must be a toplevel function, a constructor, ...
    return;

  String fullName = new String(attr.data);

  registerJavaMethod(fullName);

  attr = cast(gnu.bytecode.Attribute.get(method, "patterns"));
  if (attr == null)
    throw Internal.error("Method " + method.getName() + 
		     " in class " + c.getName() + " has no patterns");
  String rep = new String(attr.data);

  int[]/*ref*/ at = [0];

  ArrayList<Pattern> patterns = new ArrayList(5);

  try {
    ?Pattern p;

    while ((p = bossa.syntax.dispatch.readPattern(rep, at)) != null)
      {
        if (p.getTC() == nice.tools.typing.PrimitiveType.arrayTC)
          /* Special treatment for arrays:
             they are compiled into Object,
             but we want a SpecialArray in the method bytecode type.
          */
          {
            int argnum = patterns.size();
            if (notNull(method.arg_types)[argnum] == gnu.bytecode.Type.pointer_type)
              notNull(method.arg_types)[argnum] = nice.tools.code.SpecialArray.unknownTypeArray();
          }

        patterns.add(p);
      }

    let alt = new ImportedAlternative(method.getName(), patterns.toArray(),
                                code: new gnu.expr.QuoteExp(new gnu.expr.PrimProcedure(method)),
                                loc: location);

    alt.add(nice.tools.util.System.split
              (fullName, MethodDeclaration.methodListSeparator));
  }
  catch(Pattern.Unknown ex) {
    // This can happen if the class exists only in a later version
    // of the JDK. We just ignore this alternative.
  }
}

/**
   If this full name refers to a java method, make sure it participates
   to the link tests and dispatch code generation.
*/
private void registerJavaMethod(String fullName)
{
  if (! fullName.startsWith("JAVA:"))
    return;

  int end = fullName.lastIndexOf(':');
  let methodName = new LocatedString(fullName.substring("JAVA:".length(), end),
	bossa.util.Location.nowhere());

  for (VarSymbol sym : bossa.syntax.Node.getGlobalScope().lookup(methodName))
    {
      if (sym.getMethodDeclaration() == null)
        continue;

      MethodDeclaration md = notNull(sym.getMethodDeclaration());
      if (md.getFullName().equals(fullName))
        {
          md.registerForDispatch();
          return;
        }
    }
}