package nice.lang;

/** 
    Returns the strongly connected components
    of the graph rooted at the first argument,
    which edges are given by the function argument.
 
    The scc are returned in topological order.
    Tarjan's algorithm (linear).
 */
<Any T> List<List<T>> 
  stronglyConnectedComponents(T start, T->List<T> successors)
{
  Ref<int> id = new Ref(value: 0);
  Stack<T> stack = new Stack();
  Map<T,int> mark = new HashMap();

  List<List<T>> res = new ArrayList();
  visit(start,successors,id,stack,mark,res);
  
  return res;
}

<Any T> int visit(T node, T->List<T> successors, 
		  Ref<int> id, Stack<T> stack, Map<T,int> mark, 
		  List<List<T>> res)
{
  value(id)=value(id)+1;

  mark.put(node, value(id));
  stack.push(node);

  int min = id.value;
  successors(node).foreach(T child=>{
    int m;
    if (mark.get(child)==null)// optionOr crashes the compiler here so we fake
      m = visit(child, successors, id, stack, mark, res);
    else 
      m = cast(mark.get(child));

    if(m<min) 
      min=m;
  });

  if(equals(min,mark.get(node)))
    {
      Vector<T> scc = new Vector();
      T element;
      do
	{
	  element = stack.pop();
	  scc.add(element);
	  mark.put(element,MAX_INT());
	}
      while (element != node);
      res.add(scc);
    }
  return min;
}
