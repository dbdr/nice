
package nice.lang;

import java.util.*;

/****************************************************************
 * Collection
 ****************************************************************/

<Any T> void foreach(java.util.Collection<T>, T->void);
// Backward compatibility. `iter` will probably be removed sometime.
<Any T> void iter(java.util.Collection<T> c, T->void f) = c.foreach(f);

<java.util.Collection C, Any T, Any U> C<U> map(C<T>, T->U);
<java.util.Collection C, Any T> C<T> filter(C<T>, T->boolean);

<Any T, Any U> U foldLeft(java.util.List<T> l, (U, T)->U f, U init)
{
  U res = init;
  l.iter(T elem => { res = f(res, elem); });
  return res;
}

<Any T, Any U> U foldRight(java.util.List<T> l, (T, U)->U f, U init) =
  foldRight(l, f, init, 0);

private <Any T, Any U> 
U foldRight(java.util.List<T> l, (T, U)->U f, U init, int from)
{
  if (from < l.size())
    return f(l[from], l.foldRight(f, init, from + 1));
  else
    return init;
}

<Any T> List<T> slice(List<T> list, int from = 0, int to = -1)
{
  if (to == -1) 
    to = list.size() - 1;

  List<T> res = new ArrayList(to - from + 1);
  for (int i = from; i <= to; i++)
    res.add(list[i]);
  return res;
}

/****************************************************************
 * Implementations
 ****************************************************************/

/** 
    Default implementation, using an Iterator.
*/
foreach<T>(c@java.util.Collection, f) 
{
  for (java.util.Iterator<T> i = c.iterator(); i.hasNext();)
    f(i.next());
}

/** 
    A more efficient implementation for lists: doesn't allocate an Iterator.
*/
foreach(l@java.util.List, f)
{
  for (int i = 0; i < l.size; i++)
    f(l.get(i));
}

map(c, f) 
{
  throw new Error("Map not implemented for " + c.getClass());
}

map<C,T,U>(c#ArrayList, f)
{
  ArrayList<U> res = new ArrayList(c.size());
  c.iter(T elem => { res.add(f(elem)); });
  return res;
}

map<C,T,U>(c#java.util.Vector, f)
{
  java.util.Vector<U> res = new java.util.Vector(c.size());
  c.iter(T elem => { res.add(f(elem)); });
  return res;
}

map<C,T,U>(c#java.util.Stack, f)
{
  java.util.Stack<U> res = new java.util.Stack();
  c.iter(T elem => { res.add(f(elem)); });
  return res;
}

filter(c, f) 
{
  throw new Error("Filter not implemented for " + c.getClass());
}

filter<C,T>(c#ArrayList, test)
{
  ArrayList<T> res = new ArrayList(c.size());
  c.iter(fun(T elem) => { if(test(elem)) res.add(elem); });
  return res;
}

filter<C,T>(c#java.util.Vector, test)
{
  java.util.Vector<T> res = new java.util.Vector(c.size());
  c.iter(fun(T elem) => { if(test(elem)) res.add(elem); });
  return res;
}

filter<C,T>(c#java.util.Stack, test)
{
  java.util.Stack<T> res = new java.util.Stack();
  c.iter(fun(T elem) => { if(test(elem)) res.add(elem); });
  return res;
}

/****************************************************************
 * Standard operations
 ****************************************************************/

<Any T> boolean has (java.util.List<T> s, T->boolean test)
{
  for (int i = 0; i < s.size(); i++)
    if (test(s.get(i)))
      return true;

  return false;
}

<Any T> T find (java.util.List<T> s, T->boolean test)
{
  for (int i = 0; i < s.size(); i++)
    if (test(s.get(i)))
      return s.get(i);

  throw new java.util.NoSuchElementException();
}

<Any T> T findLast (java.util.List<T> s, T->boolean test)
{
  for (int i = s.size(); --i >= 0;)
    if (test(s[i]))
      return s[i];

  throw new java.util.NoSuchElementException();
}

<Any T> ?T find (java.util.List<!T> s, !T->boolean test)
{
  for (int i = 0; i < s.size(); i++)
    if (test(s.get(i)))
      return s.get(i);

  return null;
}

<Any T> int findIndex (List<T> s, T->boolean test)
{
  for (int i = 0; i < s.size(); i++)
    if (test(s.get(i)))
      return i;

  throw new java.util.NoSuchElementException();
}

boolean or(java.util.List<boolean> s)
{
  for (int i = 0; i < s.size(); i++)
    if (s.get(i))
      return true;

  return false;
}

long max(java.util.List<long> s)
{
  long res = 0;

  for(int i = 0; i < s.size(); i++)
    if (s.get(i) > res)
      res = s.get(i);

  return res;
}

/****************************************************************
 * Printing
 ****************************************************************/

/*
We need overriding of native methods for this
toString(s@List)
{
  if (s.size() == 0)
    return "[]";

  StringBuffer buf = new StringBuffer();
  buf.append("[");
  buf.append(s[0].toString());
  for (int i=1; i<s.size(); i++)
    {
      buf.append(", ");
      buf.append(s[i].toString());
    }
  buf.append("]");
  return buf.toString();
}
*/

/****************************************************************
 * toArray
 ****************************************************************/

<Any T> T[] toArray(java.util.Collection<T> c)
{
  T[] res = cast(new T[c.size()]);

  int i = 0;
  c.foreach(T elem => res[i++] = elem);
  return res;
}


// We give two versions of put and get, working on Maps with
// null and non-null element types.
// This is purely for the convenience of the Map type declaration:
// it does not really make sense to have a non-null type, 
// as the lookup can always return null if the key is not present.

// The result can be null if the key is not present.
<Any Key, Any Element> ?Element get(Map<Key, !Element>, Key) = 
  native Object java.util.Map.get(Object);
// This function does not overlap with the previous because Map
// is non-variant (it would be unsafe to have Map covariant on Element).
<Any Key, Any Element> ?Element get(Map<Key, ?Element>, Key) = 
  native Object java.util.Map.get(Object);

// Returns the previous value for that key, which may always be null
<Any Key, Any Element> ?Element put(Map<Key, !Element>, Key, ?Element) = 
  native Object java.util.Map.put(Object, Object);
<Any Key, Any Element> ?Element put(Map<Key, ?Element>, Key, ?Element) = 
  native Object java.util.Map.put(Object, Object);


<Any Key, Any Element> boolean containsKey(Map<Key, !Element>, Key) = 
  native boolean java.util.Map.containsKey(Object);
// This function does not overlap with the previous because Map
// is non-variant (it would be unsafe to have Map covariant on Element).
<Any Key, Any Element> boolean containsKey(Map<Key, ?Element>, Key) = 
  native boolean java.util.Map.containsKey(Object);
