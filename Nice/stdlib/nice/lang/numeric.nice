/**************************************************************************/
/*                           B O S S A                                    */
/*        A simple imperative object-oriented research language           */
/*                   (c)  Daniel Bonniot 1999                             */
/*                                                                        */
/*  This program is free software; you can redistribute it and/or modify  */
/*  it under the terms of the GNU General Public License as published by  */
/*  the Free Software Foundation; either version 2 of the License, or     */
/*  (at your option) any later version.                                   */
/*                                                                        */
/**************************************************************************/

// File    : numeric.nice
// Created : Wed Dec 01 15:44:03 1999 by bonniot

/**
   Numerical hierarchy.
   
   Wrapper for {@link gnu.math <code>gnu.math</code>}.
   
   @version $Date$
   @author Daniel Bonniot
*/

package nice.lang;

int MAX_INT() = native java.lang.Integer.MAX_VALUE;

// Comparison
boolean `<`(double, double) = inline nice.tools.code.ComparisonOperators("dLt");
boolean `<`(float, float) = inline nice.tools.code.ComparisonOperators("fLt");
boolean `<`(long, long) = inline nice.tools.code.ComparisonOperators("jLt");
boolean `<`(int, int) = inline nice.tools.code.ComparisonOperators("iLt");

boolean `<=`(double, double) = inline nice.tools.code.ComparisonOperators("dLe");
boolean `<=`(float, float) = inline nice.tools.code.ComparisonOperators("fLe");
boolean `<=`(long, long) = inline nice.tools.code.ComparisonOperators("jLe");
boolean `<=`(int, int) = inline nice.tools.code.ComparisonOperators("iLe");

boolean `>`(double, double) = inline nice.tools.code.ComparisonOperators("dGt");
boolean `>`(float, float) = inline nice.tools.code.ComparisonOperators("fGt");
boolean `>`(long, long) = inline nice.tools.code.ComparisonOperators("jGt");
boolean `>`(int, int) = inline nice.tools.code.ComparisonOperators("iGt");

boolean `>=`(double, double) = inline nice.tools.code.ComparisonOperators("dGe");
boolean `>=`(float, float) = inline nice.tools.code.ComparisonOperators("fGe");
boolean `>=`(float, float) = inline nice.tools.code.ComparisonOperators("jGe");
boolean `>=`(int, int) = inline nice.tools.code.ComparisonOperators("iGe");

// Equality
boolean `==`(double, double) = inline nice.tools.code.ComparisonOperators("dEq");
boolean `==`(float, float) = inline nice.tools.code.ComparisonOperators("fEq");
boolean `==`(long, long) = inline nice.tools.code.ComparisonOperators("jEq");
boolean `==`(int, int) = inline nice.tools.code.ComparisonOperators("iEq");

// Inequality
boolean `!=`(double, double) = inline nice.tools.code.ComparisonOperators("dNe");
boolean `!=`(float, float) = inline nice.tools.code.ComparisonOperators("fNe");
boolean `!=`(long, long) = inline nice.tools.code.ComparisonOperators("jNe");
boolean `!=`(int, int) = inline nice.tools.code.ComparisonOperators("iNe");

// Operators
/* should be accepted, but compiled to NOP
   Only effect = promotion if type < int
double `+`(double) = nop
float `+`(float) = nop
long `+`(long) = nop
int `+`(int) = 
*/

// unary negation
double `-`(double) = inline nice.tools.code.NumericalOperators("dNeg");
float `-`(float) = inline nice.tools.code.NumericalOperators("fNeg");
long `-`(long) = inline nice.tools.code.NumericalOperators("jNeg");
int `-`(int) = inline nice.tools.code.NumericalOperators("iNeg");

// multiplication
double `*`(double, double) = inline nice.tools.code.NumericalOperators("dMul");
float `*`(float, float) = inline nice.tools.code.NumericalOperators("fMul");
long `*`(long, long) = inline nice.tools.code.NumericalOperators("jMul");
int `*`(int, int) = inline nice.tools.code.NumericalOperators("iMul");

// division
double `/`(double, double) = inline nice.tools.code.NumericalOperators("dDiv");
float `/`(float, float) = inline nice.tools.code.NumericalOperators("fDiv");
long `/`(long, long) = inline nice.tools.code.NumericalOperators("jDiv");
int `/`(int, int) = inline nice.tools.code.NumericalOperators("iDiv");

// remainder
double `%`(double, double) = inline nice.tools.code.NumericalOperators("dRem");
float `%`(float, float) = inline nice.tools.code.NumericalOperators("fRem");
long `%`(long, long) = inline nice.tools.code.NumericalOperators("jRem");
int `%`(int, int) = inline nice.tools.code.NumericalOperators("iRem");

// addition
double `+`(double, double) = inline nice.tools.code.NumericalOperators("dAdd");
float `+`(float, float) = inline nice.tools.code.NumericalOperators("fAdd");
long `+`(long, long) = inline nice.tools.code.NumericalOperators("jAdd");
int `+`(int, int) = inline nice.tools.code.NumericalOperators("iAdd");

// substraction
double `-`(double, double) = inline nice.tools.code.NumericalOperators("dSub");
float `-`(float, float) = inline nice.tools.code.NumericalOperators("fSub");
long `-`(long, long) = inline nice.tools.code.NumericalOperators("jSub");
int `-`(int, int) = inline nice.tools.code.NumericalOperators("iSub");

// shift
int  `<<`(int , long) = inline nice.tools.code.NumericalOperators("iShl");
long `<<`(long, long) = inline nice.tools.code.NumericalOperators("jShl");

int  `>>`(int , long) = inline nice.tools.code.NumericalOperators("iShr");
long `>>`(long, long) = inline nice.tools.code.NumericalOperators("jShr");

int  `>>>`(int , long) = inline nice.tools.code.NumericalOperators("iuShr");
long `>>>`(long, long) = inline nice.tools.code.NumericalOperators("juShr");

// bitwise operators
int `&`(int, int) = inline nice.tools.code.NumericalOperators("iAnd");
int `|`(int, int) = inline nice.tools.code.NumericalOperators("iIOr");
int `^`(int, int) = inline nice.tools.code.NumericalOperators("iXOr");

long `&`(long, long) = inline nice.tools.code.NumericalOperators("jAnd");
long `|`(long, long) = inline nice.tools.code.NumericalOperators("jIOr");
long `^`(long, long) = inline nice.tools.code.NumericalOperators("jXOr");
