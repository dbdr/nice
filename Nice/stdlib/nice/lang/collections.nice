/****************************************************************************
 *                                 N I C E                                  *
 *              A high-level object-oriented research language              *
 *                         (c) Daniel Bonniot 2003                          *
 *                                                                          *
 *  This package is free software; you can redistribute it and/or modify    *
 *  it under the terms of the GNU General Public License as published by    *
 *  Free Software Foundation; either version 2 of the License, or (at your  *
 *  option) any later version.                                              *
 *                                                                          *
 *  As a special exception, the copyright holders of this library give you  *
 *  permission to link this library with independent modules to produce an  *
 *  executable, regardless of the license terms of these independent        *
 *  modules, and to copy and distribute the resulting executable under      *
 *  terms of your choice.                                                   *
 ****************************************************************************/

package nice.lang;

import java.util.*;

/****************************************************************
 * Collection
 ****************************************************************/

<T> void foreach(Collection<T> coll, T->void func);
// Backward compatibility. `iter` will probably be removed sometime.
<T> void iter(Collection<T> coll, T->void func) = coll.foreach(func);

<Collection C, T, U> C<U> similarEmptyCollection(C<T>);

<Collection C, T, U> C<U> map(C<T> coll, T->U func);

//<Collection C, T, U | T <: U> C<U> filter(C<T>, T->boolean);
//temporaly using a non polymorpic return because of type inference
<Collection C, T> C<T> filter(C<T>, T->boolean);

/** Return a collection containing all elements for which converter
    returns a non-null value.
    It is possible to retain only elemnts with a subtype of the original
    element type, in which case the returned collection has that 
    element type.
*/
<Collection C, T, U> C<!U> filter(C<T> source, T->?U converter)
{
  C<!U> res = source.similarEmptyCollection();
  for(T elem : source)
    {
      ?U converted = converter(elem);
      if (converted != null)
        res.add(converted);
    }
  return res;
}

/** @deprecated */
<T> void keep(Collection<T> coll, T->boolean test) = coll.retain(test);

/** Modifies c, only keeping the elements for which test returns true. */
<T> void retain(Collection<T> coll, T->boolean test)
{
  Iterator<T> i = coll.iterator();
  while (i.hasNext())
    {
      T element = i.next();
      if (! (test(element)))
	i.remove();
    }
}

/** Modifies c, removing the elements for which test returns true. */
<T> void remove(Collection<T> coll, T->boolean test)
{
  Iterator<T> i = coll.iterator();
  while (i.hasNext())
    {
      T element = i.next();
      if (test(element))
	i.remove();
    }
}

<T, U> U foldLeft(List<T> list, (U, T)->U func, U init)
{
  U res = init;
  for (T elem : list) 
    res = func(res, elem);

  return res;
}

<T, U> U foldRight(List<T> list, (T, U)->U func, U init) =
  foldRight(list, func, init, 0);

private <T, U> 
U foldRight(List<T> list, (T, U)->U func, U init, int from)
{
  if (from < list.size())
    return func(list[from], list.foldRight(func, init, from + 1));
  else
    return init;
}

<T> List<T> slice(List<T> list, int from = 0, int to = -1)
{
  if (to == -1) 
    to = list.size() - 1;

  List<T> res = new ArrayList(to - from + 1);
  for (int i = from; i <= to; i++)
    res.add(list[i]);

  return res;
}

<T> void foreach(Enumeration<T> enumeration, T->void f)
{
  while (enumeration.hasMoreElements())
    f(enumeration.nextElement());
}

/****************************************************************
 * Implementations
 ****************************************************************/

<T> foreach(coll@java.util.Collection, func) 
{
  for (T elem : coll)
    func(elem);
}

<C,T,U> map(coll, func)
{
  C<U> res = coll.similarEmptyCollection();
  for (T elem : coll)
    res.add(func(elem));

  return res;
}

<C,T> filter(coll, test)
{
  C<T> res = coll.similarEmptyCollection();
  for (T elem : coll)
    if (test(elem))
      res.add(elem);

  return res;
}

similarEmptyCollection(c) 
{
  throw new Error("The method similarEmptyCollection is not yet implemented for " + c.getClass());
}

similarEmptyCollection(c#ArrayList) = new ArrayList(c.size());

similarEmptyCollection(c#LinkedList) = new LinkedList();

similarEmptyCollection(c#Vector) = new Vector(c.size());

similarEmptyCollection(c#Stack) = new Stack();

/****************************************************************
 * Sort
 ****************************************************************/

/**
   comparator must return a negative integer, zero, or a positive integer 
   as the first argument is less than, equal to, or greater than the second.
*/
<T> void sort(List<T> list, (T,T) -> int comparator) 
{
  Collections.sort(list, new NiceComparator(comparator: comparator));
}

class NiceComparator<T> implements java.util.Comparator
{
  final (T,T) -> int comparator;

  compare(x, y) = (this.comparator)(x,y);
}

/****************************************************************
 * Standard operations
 ****************************************************************/

/** @deprecated */
<T> boolean has (Collection<T> coll, T->boolean test) = coll.contains(test);

<T> boolean contains (Collection<T> coll, T->boolean test)
{
  for (T elem : coll)
    if (test(elem))
      return true;

  return false;
}

<T, U, V | T <: V, U <: V> boolean containsAny (Collection<T> coll1, Collection<U> coll2)
{
  for (T elem : coll1)
    if (coll2.contains(elem))
      return true;

  return false;
}

<T> int count (Collection<T> coll, T->boolean test)
{
  int res = 0;
  for (T elem : coll)
    if (test(elem)) res++;

  return res;
}

<T> boolean any (Collection<T> coll, T->boolean test)
{
  for (T elem : coll)
    if (test(elem))
      return true;

  return false;
}

<T> boolean all (Collection<T> coll, T->boolean test)
{
  for (T elem : coll)
    if (!test(elem))
      return false;

  return true;
}

<T> boolean none (Collection<T> coll, T->boolean test)
{
  for (T elem : coll)
    if (test(elem))
      return false;

  return true;
}

/** Find the first element that passes the given test.
    @throw java.util.NoSuchElementException if there is no such element.
*/
<T> T find (List<T> list, T->boolean test)
{
  for (T elem : list)
    if (test(elem))
      return elem;

  throw new java.util.NoSuchElementException();
}

/** Find the last element that passes the given test.
    @throw java.util.NoSuchElementException if there is no such element.
*/
<T> T findLast (List<T> list, T->boolean test)
{
  for (int i = list.size(); --i >= 0;)
    if (test(list[i]))
      return list[i];

  throw new java.util.NoSuchElementException();
}

/** Find the first element that passes the given test.
    Returns <code>null</code> if there is no such element.
*/
<Any T> ?T search (java.util.List<!T> list, !T->boolean test)
{
  for (!T elem : list)
    if (test(elem))
      return elem;

  return null;
}

/** Find the last element that passes the given test.
    Returns <code>null</code> if there is no such element.
*/
<T> ?T searchLast (List<!T> s, !T->boolean test)
{
  for (int i = s.size(); --i >= 0;)
    if (test(s[i]))
      return s[i];

  return null;
}

/** @deprecated */
<T> int findIndex (List<T> list, T->boolean test) = list.findIndex(test);

<T> int indexOf (List<T> list, T->boolean test)
{
  for (int i = 0; i < list.size(); i++)
    if (test(list[i]))
      return i;

  throw new NoSuchElementException();
}

boolean or(List<boolean> list)
{
  for (boolean elem : list)
    if (elem)
      return true;

  return false;
}

boolean and(List<boolean> list)
{
  for (boolean elem : list)
    if (!elem)
      return false;

  return true;
}

long max(List<long> list) requires !list.isEmpty()
{
  long res = Long.MIN_VALUE;

  for(long elem : list)
    if (elem > res)
      res = elem;

  return res;
}

long min(List<long> list) requires !list.isEmpty()
{
  long res = Long.MAX_VALUE;

  for(long elem : list)
    if (elem < res)
      res = elem;

  return res;
}

int max(List<int> list) requires !list.isEmpty()
{
  int res = Integer.MIN_VALUE;

  for(int elem : list)
    if (elem > res)
      res = elem;

  return res;
}

int min(List<int> list) requires !list.isEmpty()
{
  int res = Integer.MAX_VALUE;

  for(int elem : list)
    if (elem < res)
      res = elem;

  return res;
}

/** @return the concatenation of the two lists, as a new list. */
<T, T1, T2 | T1 <: T, T2 <: T> List<T> `+`(List<T1> l1, List<T2> l2)
{
  List<T> res = new ArrayList(l1.size + l2.size);
  res.addAll(l1);
  res.addAll(l2);
  return res;
}

<T> void reversefor(List<T> list, T->void func)
{
  let it = list.listIterator(list.size());
  while(it.hasPrevious())
    func(it.previous());
}

<T, U> List<U> reversemap(List<T> list, T->U func)
{
  List<U> res = new ArrayList(list.size);
  let it = list.listIterator(list.size());
  while(it.hasPrevious())
    res.add(func(it.previous()));

  return res;
}

<T,U | T <: U> List<U> flatten(List<List<T>> list)
{
  List<U> res = new ArrayList();
  for (elem : list)
    res.addAll(elem);

  return res;
}

/****************************************************************
 * toArray
 ****************************************************************/

<T, U> U[] mapToArray(List<T> list, T->U func)
{
  U[] res = cast(new U[list.size()]);
  int i = 0;
  for (T elem : list)
    res[i++] = func(elem);
 
  return res;
}

/****************************************************************
 * Set operations
 ****************************************************************/

<T, U, V | U <: T, V <: T> Set<T> union(Set<U> set1, Set<V> set2)
{
  let Set<T> res = new HashSet(set1);
  res.addAll(set2);
  return res;
}

<T, U, V | U <: T, V <: T> Set<T> intersection(Set<U> set1, Set<V> set2)
{
  Set<T> res = new HashSet();
  if (set1.size() > set2.size())
    {
      for (V elem : set2)
        if (set1.contains(elem))
	  res.add(elem);
    }  
  else
    {
      for (U elem : set1)
        if (set2.contains(elem))
	  res.add(elem);
    }

  return res;
}

<T, U, V | U <: T, V <: T> Set<T> disjunction(Set<U> set1, Set<V> set2)
{
  Set<T> res = new HashSet();
  for (U elem : set1)
    if (! set2.contains(elem))
      res.add(elem);

  for (V elem : set2)
    if (! set1.contains(elem))
      res.add(elem);

  return res;
}

<T, U, V, W | U <: T, V <: W, W <: U> Set<T> difference(Set<U> set1, Set<V> set2)
{
  Set<T> res = new HashSet();
  for (U elem : set1)
    if (! set2.contains(elem))
      res.add(elem);

  return res;
}
