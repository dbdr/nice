
package nice.lang;

/****************************************************************
 * Collection
 ****************************************************************/

interface Collection<T>
{
  int size();
  void iter(fun(T)());

  alike<T> filter(fun(T)(boolean));
  //<Any U> alike<U> map( fun(T)(U) );
}

<Collection C, Any T, Any U1> C<U1> map(C<T>, fun(T)(U1));

//<Collection C, Any T> C<T> filter(C<T>, fun(T)(boolean));


/** A growable Collection */
interface Container<T> 
  extends Collection<T> 
{
  void add(T);
}


/** An ordered Collection */
interface Sequence<T> 
  extends Collection<T>
{
  T    get(int);    // alternative syntax: a[i]
  void set(int, T); // alternative syntax: a[i]=v

  <Any U> U foldLeft(fun(U, T)(U), U);
}

iter(l@Sequence, f)
{
  for(int i=0; i<l.size; i=i+1)
    f(l.get(i));
}

foldLeft<T, U>(l@Sequence, f, init)
{
  U res = init;
  l.iter(fun(T elem) => { res = f(init, elem); });
  return init;
}

/*
val fold_left : f:('a -> 'b -> 'a) -> init:'a -> 'b list -> 'a

    List.fold_left f a [b1; ...; bn] is f (... (f (f a b1) b2) ...) bn. 

val fold_right : f:('a -> 'b -> 'b) -> 'a list -> init:'b -> 'b

    List.fold_right f [a1; ...; an] b is f a1 (f a2 (... (f an b) ...)). Not tail-recursive. 
*/
/** A growable ordered Collection. */
interface List<T> 
  extends Sequence<T>, Container<T>
  {}

//  filter<C,T>[<L>](l@List : L<T>, test)
//  {
//    L<T> res;
//    res=emptyCollection(l);

//    l.iter(fun(T elem) => if (test(elem)) res.add(elem) );

//   return res;
//  }

/****************************************************************
 * Linked Lists
 ****************************************************************/

abstract class LinkedList<T3> 
  implements Sequence 
  //finally implements Collection
  {}

final class Nil<T>  extends LinkedList<T> {}
final class Cons<T> extends LinkedList<T> { T head; LinkedList<T> tail; }

<Any T> Cons<T> cons(T, LinkedList<T>);
cons<T>(elem, t)
{
  Cons<T> res = new Cons();
  res.head = elem;
  res.tail = t;

  return res;
}

size(l@Nil ) = 0;
size(l@Cons) = 1+size(l.tail);

get(l@Cons, n) = n == 0 ? head(l) : get(l.tail, n-1);
get<T>(l@Nil, n) = null;

set(l@Cons, n, elem)
{
  if(n == 0) 
    head(l)=elem; 
  else 
    l.tail.set(n-1, elem);
}

set(l@Nil,  n, elem) { /* error */ }

map(l@Nil, f) = new Nil();

map(l@Cons, ff) = cons(ff(l.head), map(l.tail, ff));

filter(l@Nil , test) = new Nil();
filter<C,T>(l@Cons, test)
{
  LinkedList<T> res = filter(l.tail,test);
  return test(l.head) ? cons(l.head, res) : res;
}

/****************************************************************
 * Vector
 ****************************************************************/

class Vector<T> 
  implements List 
  finally implements Collection
{
  Array<T> elements;
  int length;
}

<Any T> Vector<T> makeVector(int);
makeVector<T>(len)
{
  Vector<T> res = new Vector();

  res.elements = new T[len]; 

  res.length = 0;
  return res;
}

<Any T> Vector<T> makeVector(int, T);
makeVector<T>(len, sample)
{
  return makeVector(len);
/*
  Vector<T> res = new Vector();
  res.elements = newArray(len, sample);
  res.length = 0;
  return res;
*/
}

size(v@Vector) = v.length;

map<C,T,U>(v@Vector, f)
{
  Vector<U> res = makeVector(v.length);

  for(int i=0; i<v.length; i=i+1)
    res.elements.set(i, f( v.get(i) ));

  return res;
}

get(v@Vector, index) = get(v.elements, index);
set(v@Vector, index, element) = v.elements.set(index, element);

add<T>(v@Vector, element)
{
  if(v.elements==null)
    {
      v.elements = new T[10];
      v.length = 0;
    }

  if (v.length >= 
      v.elements.size)
    v.elements = v.elements.resize(v.length * 2);

  v.elements.set(v.length, element);
  v.length = v.length+1;
}

filter<C,T>(v@Vector, test)
{
  Vector<T> res = new Vector();
  res.length=0;

  v.iter(fun(T elem) => { if(test(elem)) res.add(elem); });

  return res;
}

/****************************************************************
 * Wrappers for java.util.Collection
 ****************************************************************/

// unsafe !
<Any T> T next(java.util.Iterator) = 
  native Object java.util.Iterator.next();

<Any T> List<T> list(java.util.List);
list<T>(l)
{
  Vector<T> res = makeVector(l.size());

  for(java.util.Iterator i = l.iterator(); i.hasNext();)
    res.add(i.next());

  return res;
}

/****************************************************************
 * Stack
 ****************************************************************/

class Stack<T> extends Vector<T>
{
  boolean empty();
  T pop();
  void push(T);
}

empty(s) = s.size==0;

pop<T>(s)
{
  s.length=s.length-1;
  T res = s.elements.get(s.length);
  // enables garbage collection of the object
  s.elements.set(s.length,null);

  return res;
}

push(stack, element)
{
  stack.add(element);
}

/****************************************************************
 * Standard operations
 ****************************************************************/

<Any T> T find(Sequence<T>, fun(T)(boolean));
find(s, test)
{
  for(int i=0; i<s.size(); i=i+1)
    if(test(s.get(i)))
      return s.get(i);

  return null;
}

boolean or(Sequence<boolean>);
or(s)
{
  for(int i=0; i<s.size(); i=i+1)
    if(s.get(i))
      return true;

  return false;
}

long max(Sequence<long>);
max(s)
{
  long res=0;

  for(int i=0; i<s.size(); i=i+1)
    if(s.get(i)>res)
      res=s.get(i);

  return res;
}

/****************************************************************
 * Printing
 ****************************************************************/

/*
We need overriding of native methods for this
toString(s@Sequence)
{
  if (s.size() == 0)
    return "[]";

  StringBuffer buf = new StringBuffer();
  buf.append("[");
  buf.append(s[0].toString());
  for (int i=1; i<s.size(); i++)
    {
      buf.append(", ");
      buf.append(s[i].toString());
    }
  buf.append("]");
  return buf.toString();
}
*/

print(p@PrintStream, s@Sequence)
{
  if (s.size() == 0)
    {
      p.println("[]");
      return;
    }
  p.print("[");
  p.print(s.get(0));
  for (int i=1; i<s.size(); i++)
    p.print(", " + s.get(i));
  p.print("]");
}
  
/****************************************************************
 * Map
 ****************************************************************/

interface Map<Key,Element> = native java.util.Map;
class HashMap<Key,Element> implements Map = native java.util.HashMap;

<Any Key, Any Element> HashMap<Key, Element> newHashMap() = 
  native new java.util.HashMap();

<Any Key, Any Element> Element get(Map<Key, Element>, Key) = 
  native Object java.util.Map.get(Object);

<Any Key, Any Element> Element put(Map<Key, Element>, Key, Element) = 
  native Object java.util.Map.put(Object, Object);

