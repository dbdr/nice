
package nice.lang;

import java.util.*;

/****************************************************************
 * Collection
 ****************************************************************/

<Any T> void foreach(java.util.Collection<T>, T->void);
// Backward compatibility. `iter` will probably be removed sometime.
<Any T> void iter(java.util.Collection<T> c, T->void f) = c.foreach(f);

<java.util.Collection C, T, U> C<U> similarEmptyCollection(C<T>);

<java.util.Collection C, Any T, Any U> C<U> map(C<T>, T->U);

// A more precise type for filter would be:
// <Collection C, T, U | T <: U> C<U> filter(C<T>, T -> boolean);
// This would allow List<A> lA = lB.filter(...) where B is a subclass of A.

<java.util.Collection C, Any T> C<T> filter(C<T>, T->boolean);

/** Return a collection containing all elements for which converter
    returns a non-null value.
    It is possible to retain only elemnts with a subtype of the original
    element type, in which case the returned collection has that 
    element type.
*/
<Collection C, T, U> C<!U> filter(C<T> source, T->?U converter)
{
  C<!U> res = source.similarEmptyCollection();
  source.foreach(T elem => {
    ?U converted = converter(elem);
    if (converted != null)
      res.add(converted);
  });
  return res;
}


/** Modifies c, only keeping the elements for which test returns true. */
<T> void keep  (Collection<T> c, T->boolean test)
{
  Iterator<T> i = c.iterator();
  while (i.hasNext())
    {
      T element = i.next();
      if (! (test(element)))
	i.remove();
    }
}

/** Modifies c, removing the elements for which test returns true. */
<T> void remove(Collection<T> c, T->boolean test)
{
  Iterator<T> i = c.iterator();
  while (i.hasNext())
    {
      T element = i.next();
      if (test(element))
	i.remove();
    }
}


<Any T, Any U> U foldLeft(java.util.List<T> l, (U, T)->U f, U init)
{
  U res = init;
  l.foreach(T elem => { res = f(res, elem); });
  return res;
}

<Any T, Any U> U foldRight(java.util.List<T> l, (T, U)->U f, U init) =
  foldRight(l, f, init, 0);

private <Any T, Any U> 
U foldRight(java.util.List<T> l, (T, U)->U f, U init, int from)
{
  if (from < l.size())
    return f(l[from], l.foldRight(f, init, from + 1));
  else
    return init;
}

<Any T> List<T> slice(List<T> list, int from = 0, int to = -1)
{
  if (to == -1) 
    to = list.size() - 1;

  List<T> res = new ArrayList(to - from + 1);
  for (int i = from; i <= to; i++)
    res.add(list[i]);
  return res;
}

/****************************************************************
 * Implementations
 ****************************************************************/

/** 
    Default implementation, using an Iterator.
*/
foreach<T>(c@java.util.Collection, f) 
{
  for (java.util.Iterator<T> i = c.iterator(); i.hasNext();)
    f(i.next());
}

/** 
    A more efficient implementation for lists: doesn't allocate an Iterator.
*/
foreach(l@java.util.List, f)
{
  for (int i = 0; i < l.size; i++)
    f(l.get(i));
}

map<C,T,U>(c, f)
{
  C<U> res = c.similarEmptyCollection();
  c.foreach(T elem => { res.add(f(elem)); });
  return res;
}

filter<C,T>(c, test)
{
  C<T> res = c.similarEmptyCollection();
  c.foreach(T elem => { if(test(elem)) res.add(elem); });
  return res;
}

similarEmptyCollection(c) 
{
  throw new Error("The method similarEmptyCollection is not yet implemented for " + c.getClass());
}

similarEmptyCollection<C,T,U>(c#ArrayList)
{
  ArrayList<U> res = new ArrayList(c.size());
  return res;
}

similarEmptyCollection<C,T,U>(c#LinkedList)
{
  LinkedList<U> res = new LinkedList();
  return res;
}

similarEmptyCollection<C,T,U>(c#java.util.Vector)
{
  java.util.Vector<U> res = new java.util.Vector(c.size());
  return res;
}

similarEmptyCollection<C,T,U>(c#java.util.Stack)
{
  java.util.Stack<U> res = new java.util.Stack();
  return res;
}

/****************************************************************
 * Standard operations
 ****************************************************************/

<Any T> boolean has (java.util.List<T> s, T->boolean test)
{
  for (int i = 0; i < s.size(); i++)
    if (test(s.get(i)))
      return true;

  return false;
}

<Any T> T find (java.util.List<T> s, T->boolean test)
{
  for (int i = 0; i < s.size(); i++)
    if (test(s.get(i)))
      return s.get(i);

  throw new java.util.NoSuchElementException();
}

<Any T> T findLast (java.util.List<T> s, T->boolean test)
{
  for (int i = s.size(); --i >= 0;)
    if (test(s[i]))
      return s[i];

  throw new java.util.NoSuchElementException();
}

<Any T> ?T find (java.util.List<!T> s, !T->boolean test)
{
  for (int i = 0; i < s.size(); i++)
    if (test(s.get(i)))
      return s.get(i);

  return null;
}

<Any T> int findIndex (List<T> s, T->boolean test)
{
  for (int i = 0; i < s.size(); i++)
    if (test(s.get(i)))
      return i;

  throw new java.util.NoSuchElementException();
}

boolean or(java.util.List<boolean> s)
{
  for (int i = 0; i < s.size(); i++)
    if (s.get(i))
      return true;

  return false;
}

long max(java.util.List<long> s)
{
  long res = 0;

  for(int i = 0; i < s.size(); i++)
    if (s.get(i) > res)
      res = s.get(i);

  return res;
}

/****************************************************************
 * Printing
 ****************************************************************/

/*
We need overriding of native methods for this
toString(s@List)
{
  if (s.size() == 0)
    return "[]";

  StringBuffer buf = new StringBuffer();
  buf.append("[");
  buf.append(s[0].toString());
  for (int i=1; i<s.size(); i++)
    {
      buf.append(", ");
      buf.append(s[i].toString());
    }
  buf.append("]");
  return buf.toString();
}
*/

/****************************************************************
 * toArray
 ****************************************************************/

<Any T> T[] toArray(java.util.Collection<T> c)
{
  T[] res = cast(new T[c.size()]);

  int i = 0;
  c.foreach(T elem => res[i++] = elem);
  return res;
}
