/// FAIL
 /// Comment: super can only occur inside methods.
 /// Toplevel
void f() 
{ /*/// FAIL HERE */ super; }

/// GLOBAL
class A {}
class B extends A {}

/// PASS
 /// Toplevel
void m(A);
m(x@A) {}
m(x@B) { super; }

/// PASS
 /// COMMENT super can appear before the super-implementation.
 /// Toplevel
void m(A);
m(x@B) { super; }
m(x@A) {}

/// PASS
 /// Toplevel
void m(A);
m(x#A) {}
m(x@B) { super; }

/// PASS
/// Comment: checks that super is really called.
 m(new B());
 /// Toplevel
void m(A);
m(x@A) { throw new RuntimeException(); }
m(x@B) 
{ 
  try {
    super;
    throw new Error();
  }
  catch (RuntimeException e) {
  }
}

/// FAIL
/// Comment: Ambiguous call to super
  /// Toplevel
void m(A, A);
m(a, a) {}
m(a@A, b@B) {}
m(b@B, a@A) {}
m(b@B, b@B) { /*/// FAIL HERE */ super; } 

/// PASS
 /// Comment: Calling a Java super method.
 new MyThread().run();
 /// Toplevel
class MyThread extends Thread
{
  run() 
  { 
    super; 
  }
}

/// PASS
 /// COMMENT: A super that returns a value.
 assert(m(new B()).equals("A->B"));
 /// Toplevel
String m(A);

m(a@A) = "A";
m(b@B) = super + "->B";

/// PASS
 assert(new B().toString().endsWith("@A@B"));
 /// Toplevel
toString(a@A) = super + "@A";
toString(b@B) = super + "@B";

/// FAIL
 B b = m(new B());
 /// Toplevel
<A T> T m(T);

m(a#A) = new A();
m(b@B) = super;

/// FAIL
 B b = m(new B());
 /// Toplevel
<A T> T m(T);

m(a#A) = new A();
m(b#B) = super;

/// FAIL
 /// Toplevel
<Any T> T myclone(T) = native Object Object.clone();

myclone(a#A) = new A();
myclone(b#B) = super;

/// FAIL
 /// Toplevel
<Any T> T myclone(T) = native Object Object.clone();

class C extends java.text.DecimalFormat {}

myclone(c#C) = super;

/// FAIL
 /// Toplevel
<Any T> T myclone(T) = native Object Object.clone();

myclone(a#A) = super;

/// PASS
  /// COMMENT super defined in an imported package.
  /// package a
  /// Toplevel
void m(A);
m(a@A) {}

  /// package b import a
  /// Toplevel
m(b@B) { super; }

/// PASS
  /// COMMENT super defined in an imported package, with mutual import.
  /// package a import b
  /// Toplevel
void m(A);
m(@A) { if (false) m(new A()); }

  /// package b import a
  /// Toplevel
m(@B) { super; }

/// PASS
  /// COMMENT super defined in an imported package, with mutual import.
  /// package a import b
  /// Toplevel
m(@B) { super; }

  /// package b import a
  /// Toplevel
void m(A);
m(@A) { if (false) m(new A()); }

/// PASS
  /// COMMENT super defined in an imported package for a java method.
  /// package a
  /// Toplevel
class C
{
  toString() = "C";
}

  /// package b import a
  assert new D().toString().equals("CD");
  /// Toplevel
class D extends C
{
  toString() = super + "D";
}

/// FAIL
  /// COMMENT super defined in an imported package for a java method.
  /// package a
  /// Toplevel
abstract class C {}
abstract class D extends C {}

equals(x@C, y@D) = true;
equals(x@D, y@C) = true;


  /// package b import a
  /// Toplevel
abstract class E extends D
{
  equals(x@D) = /*/// FAIL HERE */ super; // This is ambiguous.
}

/// PASS
  assert (new C().foo() == 1);
  /// Toplevel
class A {
  int foo();
  foo() = 0;
}

class B extends A {
  foo() = 1;
}

class C extends B{
  foo() = super;
}

/// PASS
  /// Toplevel
abstract class A<B> extends AbstractSet<B> { }

add(a@A, b) = super;

/// PASS
  /// Toplevel
class B {
 Vector<A<B>> v = new Vector( 1 );
}

abstract class A<T> extends AbstractSet<T> { T x; }

add(a@A, b) = false;
add(a@A, b@B) = super;

/// PASS
  new Bar().isEmpty();
  /// Toplevel
class Bar<T> extends AbstractList<T>
{
  isEmpty() = super;

  size() = 0;
  get(i) = cast(null);
}

/// PASS
  /// Toplevel
abstract class A {}
class B extends A {}

class M {  
  int f(A);
  f(b@B) = super;
  f(a)   = 1;
}
