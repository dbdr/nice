/**************************************************************************/
/*                           B O S S A                                    */
/*        A simple imperative object-oriented research language           */
/*                   (c)  Daniel Bonniot 1999                             */
/*                                                                        */
/*  This program is free software; you can redistribute it and/or modify  */
/*  it under the terms of the GNU General Public License as published by  */
/*  the Free Software Foundation; either version 2 of the License, or     */
/*  (at your option) any later version.                                   */
/*                                                                        */
/**************************************************************************/

// File    : stdlib.bossa
// Created : Thu Jul 08 16:20:19 1999 by bonniot
//$Modified: Tue Nov 16 20:34:23 1999 by bonniot $
// Description : Prolog file, included before all bossa file

//variable <Any T> T null;

//final class void {}

// Booleans
abstract class Boolean {}
class True  extends Boolean {}
class False extends Boolean {}

variable True  true =new True();
variable False false=new False();

Boolean not(Boolean);
not(b@True)  {
  return new False();
}
not(b@False) = new True();

Boolean and(Boolean,Boolean);
and(b1@True,b2@True) = new True();
and(b1,b2)           = new False();

Boolean or(Boolean,Boolean);
or(b1@False,b2@False) = new False();
or(b1,b2)             = new True();

// builtin control structures
// "if(cond) t else e endif" 
// is rewritten *by the parser* into abstract syntax for 
// "_if(cond,fun()=>{return t;},fun()=>{return e;})"

// T _if <Any T> (Boolean,fun()(T),fun()(T));

// _if(cond@True,t,e) = t();

//  _if(cond@False,t,e) = e();

//  void _while(fun()(Boolean),fun()());
//  _while(test,body)
//  {
//    if(not(test()))
//      return;
//    body();
//    _while(test,body);
//  }

//  // Clone
//  //interface Cloneable;

//  //T clone{Cloneable T}(T);

//Comparable
//It is a type class !
interface Comparable;

//  Boolean equals</*Comparable*/ Any T>(T,T);

// Numeric
interface Num extends Comparable;
N add <Num N> (N,N);
//T sub <Num T> (T,T);

interface Ordinal;
//T succ <Ordinal T> (T);

class Float implements Num {}
class Integer extends Float 
  abstracts Num 
  abstracts Ordinal 
{}

//add(x@Integer,y@Integer)
//{ return new Integer(); }

add(x#Float,y#Float) = x;

add(x@Float,y@Integer) = x;

add(x@Integer,y@Float)
{ return new Integer(); }

//succ(x@Integer) = x+1;

//  Boolean lt(Integer, Integer); // strict (<)
//  Boolean leq(Integer, Integer);// non-strict (<=)

//  // Strings and characters
//  class Char {}

//  class String implements Comparable {}

//  Char get(String,Integer);
//  Integer length(String);
//  String concat(String,String);

// Builtin class Array
class Array<T>{}

//  T get<Any T>(Array<T>, Integer);

//  void set<Any T>(Array<T>, Integer, T);

//  Integer capacity<Any T>(Array<T>);

//  void resize<Any R>(Array<R>, Integer);

//  // List
//  interface Container<T>;
//  interface List<T> extends Container;

//  list<B> map <Any A, Any B, List list>(fun(A)(B),list<A>);
//  T fold_left <Any T, Any U, List list>(fun(T,U)(T),T,list<U>);
//  U fold_right<Any T, Any U, List list>(fun(T,U)(U),list<T>);

//  // Main function, called with command line arguments in an array
java.lang.Integer main(Array<java.lang.String>);
