
package nice.lang;

/****************************************************************
 * Collection
 ****************************************************************/

interface Collection<T>
{
  int size();
  boolean empty();
  void foreach(T->void);
  // Backward compatibility. `iter` will probably be removed sometime.
  void iter(T->void f) = this.foreach(f);

  alike<T> filter(T->boolean);
  <Any U> alike<U> map(T->U);
}

empty(c@Collection) = c.size() == 0;

/**
   Equivalent definitions outside the interface:
<Any T> int size(Collection<T>);
<Any T> void foreach(Collection<T>, T->void);

<Collection C, Any T, Any U> C<U> map(C<T>, T->U);
<Collection C, Any T> C<T> filter(C<T>, T->boolean);
*/

/** A growable Collection */
interface Container<T> 
  extends Collection<T> 
{
  void add(T);
}

interface Stack<T> extends Container<T>
{
  T pop();
  T top();
  void push(T);
}

add(s@Stack, elem) = s.push(elem);

/** An ordered Collection */
interface Sequence<T> 
  extends Collection<T>
{
  T    get(int);    // alternative syntax: a[i]
  void set(int, T); // alternative syntax: a[i]=v

  <Any U> U foldLeft((U, T)->U, U);
}

foreach(l@Sequence, f)
{
  for(int i=0; i<l.size; i++)
    f(l.get(i));
}

foldLeft<T, U>(l@Sequence, f, init)
{
  U res = init;
  l.iter(fun(T elem) => { res = f(init, elem); });
  return init;
}

/*
val fold_left : f:('a -> 'b -> 'a) -> init:'a -> 'b list -> 'a

    List.fold_left f a [b1; ...; bn] is f (... (f (f a b1) b2) ...) bn. 

val fold_right : f:('a -> 'b -> 'b) -> 'a list -> init:'b -> 'b

    List.fold_right f [a1; ...; an] b is f a1 (f a2 (... (f an b) ...)). Not tail-recursive. 
*/
/** A growable ordered Collection. */
interface List<T> extends Sequence<T>, Container<T>, Stack<T>
{
  T remove(int index);
}

// List based stacks

push(l@List, elem) = l.add(elem);
pop(l@List) = l.remove(l.size() - 1);
top(l@List) = l.get(l.size() - 1);

//  filter<C,T>[<L>](l@List : L<T>, test)
//  {
//    L<T> res;
//    res=emptyCollection(l);

//    l.foreach(T elem => if (test(elem)) res.add(elem));

//   return res;
//  }

/****************************************************************
 * Functional Lists
 ****************************************************************/

abstract class FList<T> 
  implements Sequence <T> 
  finally implements Collection<T>
  {}

final class Nil<T>  extends FList<T> {}
final class Cons<T> extends FList<T> { T head; FList<T> tail; }

size(l@Nil ) = 0;
size(l@Cons) = 1+size(l.tail);

get(l@Cons, n) = n == 0 ? head(l) : get(l.tail, n-1);
get<T>(l@Nil, n)
{
  throw new IndexOutOfBoundsException("Valid indexes: 0 .. " + (l.size - 1));
}

set(l@Cons, n, elem)
{
  if(n == 0) 
    head(l)=elem; 
  else 
    l.tail.set(n-1, elem);
}

set(l@Nil,  n, elem) { throw new Exception(); }

map(l@Nil, f) = new Nil();

map(l@Cons, ff) = new Cons(head: ff(l.head), tail: map(l.tail, ff));

filter(l@Nil , test) = l;
filter<C,T>(l@Cons, test)
{
  FList<T> res = filter(l.tail, test);
  return test(l.head) ? new Cons(head: l.head, tail: res) : res;
}

/****************************************************************
 * LinkedList
 ****************************************************************/

final class JavaList<T> implements List<T>
{
  java.util.List impl;  

  size() = this.impl.size();
  get(index) = cast( this.impl.get(index) );
  set(index, elem) { this.impl.set(index, cast(elem)); }
  add(elem) { this.impl.add(cast(elem)); }
  remove(index) = cast(this.impl.remove(index));
}

/** The returned iterator is always non-null */
java.util.Iterator iterator(java.util.Collection) =
  native java.util.Iterator java.util.Collection.iterator();


map<C, T, U> (l@JavaList, f)
{
  java.util.ArrayList res = new java.util.ArrayList(l.size());
  for (java.util.Iterator i = l.impl.iterator(); i.hasNext(); )
    res.add(object(f(cast(i.next()))));
  return new JavaList(impl: res);
}

filter<C,T>(l@JavaList, test)
{
  java.util.ArrayList res = new java.util.ArrayList(l.size());
  for(java.util.Iterator i = l.impl.iterator(); i.hasNext(); )
    {
      T elem = cast(i.next());
      if (test(elem))
	res.add(object(elem));
    }
  return new JavaList(impl: res);
}


/****************************************************************
 * Vector
 ****************************************************************/

class Vector<T> 
  implements List<T> 
  finally implements Collection<T>
{
  T[] elements;
  int length;

  remove<T>(index)
  {
    if (this.length <= index)
      throw new IndexOutOfBoundsException();
    T res = this[index];
    for (int i = index+1; i < this.length; i++)
      this[i - 1] = this[i];
    this.length--;
    // Would avoid possible memory leaks, but difficult to type
    //this[this.length] = null;
    return res;
  }
}

<Any T> Vector<T> makeVector(int len) = 
  new Vector(elements:cast(new T[len]), length:0); 

size(v@Vector) = v.length;
get(v@Vector, index) = get(v.elements, index);
set(v@Vector, index, element) = v.elements.set(index, element);

map<C,T,U>(v@Vector, f)
{
  Vector<U> res = makeVector(v.length);

  for(int i=0; i<v.length; i++)
    res.elements.set(i, f( v.get(i) ));

  return res;
}

add<T>(v@Vector, element)
{
  if(v.elements==null)
    {
      v.elements = cast(new T[10]);
      v.length = 0;
    }

  if (v.length >= 
      v.elements.size)
    v.elements = v.elements.resize(v.length * 2);

  v.elements.set(v.length, element);
  v.length = v.length+1;
}

filter<C,T>(v@Vector, test)
{
  Vector<T> res = makeVector(v.size);

  v.iter(fun(T elem) => { if(test(elem)) res.add(elem); });

  return res;
}

/****************************************************************
 * Standard operations
 ****************************************************************/

<Any T> boolean has (Sequence<T> s, T->boolean test)
{
  for (int i = 0; i < s.size(); i++)
    if (test(s.get(i)))
      return true;

  return false;
}

<Any T> T find (Sequence<T> s, T->boolean test)
{
  for (int i = 0; i < s.size(); i++)
    if (test(s.get(i)))
      return s.get(i);

  throw new java.util.NoSuchElementException();
}

<Any T> T findLast (Sequence<T> s, T->boolean test)
{
  for (int i = s.size(); --i >= 0;)
    if (test(s[i]))
      return s[i];

  throw new java.util.NoSuchElementException();
}

<Any T> ?T find (Sequence<!T> s, !T->boolean test)
{
  for (int i = 0; i < s.size(); i++)
    if (test(s.get(i)))
      return s.get(i);

  return null;
}

boolean or(Sequence<boolean>);
or(s)
{
  for(int i=0; i<s.size(); i++)
    if(s.get(i))
      return true;

  return false;
}

long max(Sequence<long>);
max(s)
{
  long res=0;

  for(int i=0; i<s.size(); i++)
    if(s.get(i)>res)
      res=s.get(i);

  return res;
}

/****************************************************************
 * Printing
 ****************************************************************/

/*
We need overriding of native methods for this
toString(s@Sequence)
{
  if (s.size() == 0)
    return "[]";

  StringBuffer buf = new StringBuffer();
  buf.append("[");
  buf.append(s[0].toString());
  for (int i=1; i<s.size(); i++)
    {
      buf.append(", ");
      buf.append(s[i].toString());
    }
  buf.append("]");
  return buf.toString();
}
*/

/****************************************************************
 * toArray
 ****************************************************************/

<Any T> T[] toArray(Collection<T> c)
{
  T[] res = cast(new T[c.size()]);

  int i = 0;
  c.foreach(T elem => res[i++] = elem);
  return res;
}


/****************************************************************
 * Map
 ****************************************************************/

interface Map<Key,Element> = native java.util.Map;
class Hashtable<Key,Element> implements Map<Key, Element> = 
  native java.util.HashMap;
class WeakHashtable<Key,Element> implements Map<Key, Element> = 
  native java.util.WeakHashMap;

<Any Key, Any Element> Hashtable<Key, Element> hashtable() = 
  native new java.util.HashMap();
<Any Key, Any Element> WeakHashtable<Key, Element> weakHashtable() = 
  native new java.util.WeakHashMap();

// We give two versions of put and get, working on Maps with
// null and non-null element types.
// This is purely for the convenience of the Map type declaration:
// it does not really make sense to have a non-null type, 
// as the lookup can always return null if the key is not present.

// The result can be null if the key is not present.
<Any Key, Any Element> ?Element get(Map<Key, !Element>, Key) = 
  native Object java.util.Map.get(Object);
// This function does not overlap with the previous because Map
// is non-variant (it would be unsafe to have Map covariant on Element).
<Any Key, Any Element> ?Element get(Map<Key, ?Element>, Key) = 
  native Object java.util.Map.get(Object);

// Returns the previous value for that key, which may always be null
<Any Key, Any Element> ?Element put(Map<Key, !Element>, Key, ?Element) = 
  native Object java.util.Map.put(Object, Object);
<Any Key, Any Element> ?Element put(Map<Key, ?Element>, Key, ?Element) = 
  native Object java.util.Map.put(Object, Object);

<Any Key, Any Element> boolean containsKey(Map<Key, Element>, Key) = 
  native boolean java.util.Map.containsKey(Object);

<Any Key, Any Element> int size(Map<Key, Element>) = 
  native int java.util.Map.size();

<Any Key, Any Element> java.util.Set keySet(Map<Key, Element>) = 
  native java.util.Set java.util.Map.keySet();

<Any Key, Any Element> void forKeys(Map<Key, Element> map, Key->void it) {
  for (java.util.Iterator i = map.keySet().iterator(); i.hasNext(); ) {
    it(cast(i.next()));
  }
}
