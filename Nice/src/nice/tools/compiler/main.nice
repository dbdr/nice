/**************************************************************************/
/*                                N I C E                                 */
/*             A high-level object-oriented research language             */
/*                        (c) Daniel Bonniot 2000                         */
/*                                                                        */
/*  This program is free software; you can redistribute it and/or modify  */
/*  it under the terms of the GNU General Public License as published by  */
/*  the Free Software Foundation; either version 2 of the License, or     */
/*  (at your option) any later version.                                   */
/*                                                                        */
/**************************************************************************/

package nice.tools.compiler;

/**
   Nice compiler main program.

   Exit code table:
   0 : Normal exit (compilation sucessful, version message)
   1 : Abnormal termination (bug in the compiler)
   2 : Error reported (file missing, type error, ...)
   3 : Warning reported

   Changes to this table should be reflected in function 
   <code>nice-compilation-exit</code> in emacs mode file 
   <tt>nice-mode.el</tt>.

   @version $Date$
   @author Daniel Bonniot (d.bonniot@mail.dotcom.fr)
 */

import mlsub.compilation;
import nice.getopt;
import bossa.modules;

main(args)
{
  Throwable uncaughtException = null;
  boolean memInfo = false;

  try{

  boolean recompileCL = false;
  boolean recAll = false;
  boolean doLink = true;
  boolean staticLink = false;

  Sequence<Option> opts;
  opts = 
  [
   option('r', "recompile",
	  "Force recompilation of package",
	  "none/command-line/all",
	  fun()=>{ recompileCL=true; },
	  fun(String arg)=>
          {
	    if ("all".equals(arg))
	      recAll=true;
	    else if ("command-line".equals(arg))
	      recompileCL=true;
	    else if ("none".equals(arg))
	      {
		recompileCL=false;
		recAll=false;
	      }
	    else println("Unkown argument to \'recompile\': " + arg);
	  }),

   option('R', "recompileAll",
	  "Force recompilation of all dependant packages",
	  fun()=>{ recAll = true; }),

   option('c', "compile",
	  "Compile packages, do not link them",
	  fun()=>{ doLink=false; }),

   option('?', "classpath",
	  "Set path for searching external classes",
	  ": separated list of directories and jar archives",
	  fun() => nice.tools.code.Types.setClasspath(null),
	  fun(String path) => nice.tools.code.Types.setClasspath(path)),

   option('s', "static",
	  "Store compiled packages in the jar file",
	  fun()=>{ staticLink=true; }),

   option('?', "dynamic",
	  "Store compiled packages in their directory (default)",
	  fun()=>{ staticLink=false; }),

   option('h', "help", "Print help message and exit",
	  fun()=>
            {
	      println(printOptions(opts));
	      System.exit(1);
	    }),

   option('?', "version",
	  "Print version info and exit",
	  fun()=>version()),

   option('?', "usage",
	  "Print usage information and exit",
	  fun()=>usage()),

   option('?', "memory",
	  "Print memory usage information after compilation",
	  fun()=>{ memInfo = true; })
  ];

  Sequence<String> rest = parse("nicec", args, opts);
  if (rest.size() != 1 || rest[0].length() == 0)
    {
      if (rest.size() > 1)
	println("Supply only one package on the command line.\n" +
		"nicec will automatically find dependancies.");
      usage();
    }
  String packageName = rest[0];

  Compilation compilation = 
    make(packageName, doLink, recompileCL, recAll, staticLink);

  make(compilation);
  
  }
  catch(bossa.util.UserError e){
    nice.tools.compiler.OutputMessages.error(e.getMessage());
  }
  catch(ExceptionInInitializerError e){
    uncaughtException = e.getException();
  }
  catch(Throwable e){
    uncaughtException = e;
  }

  if(uncaughtException != null)
    {
      System.out.println
      ("\nAn exception has occured in the compiler\n" +
       "Please fill-in a bug report at the following webpage:\n" +
       "http://sourceforge.net/tracker/?func=add&group_id=12788&atid=112788" +
       "\n\nException: " + uncaughtException.toString() +
       "\n\nStack trace:\n");
      uncaughtException.printStackTrace();
      System.exit(1);
    }
  
  if (memInfo) printMemoryUsage();

  OutputMessages.exit();
}

void usage();
usage()
{
  println("Usage: nicec [options] [package]");
  println("Type \"nicec --help\" for a list of options");
  System.exit(0);
}

void version();
version()
{
  println("Nice compiler beta version (" + buildDate + ")");
  println("Copyright (C) 2001 Daniel Bonniot");
  println("Visit the Nice homepage: http://nice.sourceforge.net");
  System.exit(0);
}

String prettyBytes(long);
prettyBytes(bytes)
{
  long K = 1024;
  if (bytes < 10 * K)
    return ""+bytes+" B";
  else if (bytes < 100 * K)
    return ""+(bytes/K) + "." + ((bytes % K)/100) + " KB";
  else if (bytes < 10*K*K)
    return ""+(bytes/K) + " KB";
  else if (bytes < 100*K*K)
    return ""+(bytes/(K*K)) + "." + ((bytes % (K*K))/(100*K)) + " MB";
  else if (bytes < 10*K*K*K)
    return ""+(bytes/(K*K)) + " MB";
  else 
    return ""+(bytes/(K*K*K)) + " GB";
}

void printMemoryUsage();
printMemoryUsage()
{
  Runtime r = Runtime.getRuntime();
  r.gc();
  long mem = r.totalMemory();
  println("Memory allocated: " + prettyBytes(mem) + 
	  ", used: " + prettyBytes(r.totalMemory()-r.freeMemory()));
}
