/**************************************************************************/
/*                                N I C E                                 */
/*             A high-level object-oriented research language             */
/*                        (c) Daniel Bonniot 2000                         */
/*                                                                        */
/*  This program is free software; you can redistribute it and/or modify  */
/*  it under the terms of the GNU General Public License as published by  */
/*  the Free Software Foundation; either version 2 of the License, or     */
/*  (at your option) any later version.                                   */
/*                                                                        */
/**************************************************************************/

/*
   Type checking.
*/

package bossa.syntax;

import mlsub.typing.*;

// Interface

void typecheck(Statement);
void typecheck(Expression);

/****************************************************************
 * Expressions
 ****************************************************************/

typecheck(@null(Expression)) {}

/**
   Checks that right can be assigned to a variable of type left.
   Returns a new expression to be used instead of right,
   since overloading resolution is done on the expected type.
*/
Expression checkAssignment(mlsub.typing.Polytype left, Expression right);
checkAssignment(left, right)
{
  Expression val = right.resolveOverloading(left);
  typecheck(val);
  Typing.leq(val.getType(), left);
  return val;
}

typecheck(e@AssignExp)
{
  e.to = e.to.noOverloading();
  typecheck(e.to);
  if(!e.to.isAssignable())
    bossa.util.User.error(e, "" + e.to + " cannot be assigned a value");
  
  try{
    e.value = checkAssignment(e.to.getType(), e.value);
  }
  catch(TypingEx t){
    throw assignmentError(e, 
			  e.to.toString(), e.to.getType().toString(), e.value);
  }
}

void typecheckExps(Expression[]);
typecheckExps(exps)
{
  for (int i = 0; i < exps.length; i++)
    typecheck(exps[i]);
}

void typecheck(Arguments);
typecheck(args@Arguments)
{
  for (int i = 0; i < args.arguments.length; i++)
    typecheck(args.getExp(i));
}

typecheck(e@CallExp)
{
  // forces computation of the type if not done.
  mlsub.typing.Polytype t = e.getType();
    
  // Prepare the bytecode type for EnsureTypeProc
  if (t.getConstraint() != mlsub.typing.Constraint.True)
    try{
      Typing.enter();
      try{
	mlsub.typing.Constraint.assert(t.getConstraint());
	nice.tools.code.Types.setBytecodeType(t.getMonotype());
      }
      finally{
	Typing.leave();
      }
    }
  catch(TypingEx e){
  }

  typecheck(e.function);
  e.arguments.typecheck();
}

typecheck(e@FunExp)
{
  Function saved = Node.getCurrentFunction();
  Node.setCurrentFunction(e);
  typecheck(e.body);
  Node.setCurrentFunction(saved);
}

typecheck(e@IdentExp)
{
  throw new Error("typecheck in IdentExp");
}

typecheck(e@IfExp)
{
  e.condition.resolveOverloading(ConstantExp.boolPolytype);
  typecheck(e.condition);
  typecheck(e.thenExp);
  typecheck(e.elseExp);
}

typecheck(e@IncrementExp)
{
  typecheck(e.variable);
}

typecheck(e@LiteralArrayExp)
{
  typecheckExps(e.elements);
}

typecheck(e@NewArrayExp)
{
  typecheckExps(e.knownDimensions);
  for (int i=0; i<e.knownDimensions.length; i++)
    try{
      Typing.leq(e.knownDimensions[i].getType(),
			      ConstantExp.intPolytype);
    }
    catch(TypingEx ex){
      bossa.util.User.error(e.knownDimensions[i],
			    ""+e.knownDimensions[i] + " should be an integer");
    }
}

typecheck(e@NewExp)
{
  // force computation of type
  e.getType();
  e.arguments.typecheck();
}

typecheck(e@StatementExp)
{
  typecheck(e.statement);
}

typecheck(e@TupleExp)
{
  typecheckExps(e.expressions);
}

typecheck(e@ClassExp) {}
typecheck(c@ConstantExp){}
typecheck(e@NullExp) {}
typecheck(e@OverloadedSymbolExp) {}
typecheck(e@PackageExp) {}
typecheck(e@SymbolExp) {}

/****************************************************************
 * Statements
 ****************************************************************/

typecheck(@null(Statement)) {}

typecheck(b@Block)
{
  javaList(b.locals).iter(fun(Block$LocalDeclaration d)=> typecheck(d));
  b.statements.iter(fun(Statement s)=> typecheck(s));
}

typecheck(decl@Block$LocalDeclaration)
{
  if (decl.value == null)
    return;

  MonoSymbol target = decl.left;

  try{
    decl.value = checkAssignment(target.getType(), decl.value);
  }
  catch(TypingEx t){
    throw assignmentError(target, target.name.toString(), 
			  target.getMonotype().toString(), decl.value);
  }
}

typecheck(s@ExpressionStmt)
{
  typecheck(s.exp);
}

typecheck(l@LoopStmt)
{
  typecheck(l.whileExp);
  typecheck(l.loopBody);
  typecheck(l.iterationStatements);
}

typecheck(r@ReturnStmt)
{
  r.includingFunction = Node.currentFunction;

  if (r.value != null)
    {
      r.value = r.value.noOverloading();
      typecheck(r.value);
    }
  
  mlsub.typing.Monotype declaredRetType = r.includingFunction.getReturnType();
  if (declaredRetType == null)
    return;
    
  try{
    Typing.leq(r.returnType(), declaredRetType);
  }
  catch(TypingEx e){
    bossa.util.User.error(r,
	       "returned type is " + r.returnType() +
	       "\nbut this funtion must return a " + declaredRetType,
	       ": "+e);
  }
}

typecheck(t@ThrowStmt)
{
  typecheck(t.exn);

  try{
    Typing.leq(t.exn.getType(), ConstantExp.throwableType());
  }
  catch(TypingEx e){
    bossa.util.User.error(t.exn, "" + t.exn + " is not throwable", e);
  }
}

typecheck(t@TryStmt)
{
  typecheck(t.body);
  javaList(t.catches).iter(fun(TryStmt$Catch c)=> typecheck(c.body));
  typecheck(t.finallyBody);
}

// Local Variables:
// nice-xprogram: "NICEJAR=$HOME/Nice/stdlib nicec --classpath=\"$HOME/Nice/stdlib:$HOME/Nice/classes:/$HOME/Nice/src\""
// End:
