
package bossa.syntax;

import java.util.List;
/*
  This file is only useful to bootstrap the compiler,
  since bossa.syntax is implemented both in Java and Nice,
  while we need mutual recursion between the two.

  This class must have the interface of the Nice part of the package.
*/

public class dispatch
{
  public static void resetAlternatives() {}

  public static void testCoverage(bossa.modules.Package module) {}

  public static void resetDispatchTest() {}

  public static void readImportedAlternative(gnu.bytecode.ClassType c, gnu.bytecode.Method method, bossa.util.Location location, Module module) {}

  static TypeScope createGlobalTypeScope()
  { return null; }

  public static void resetConstructorsMap() {}

  public static void resetJavaClasses() {}

  public static VarScope createGlobalVarScope(int dummy, nice.tools.visibility.Scope scope)
  { return null; }

  public static void resetTypeDefinitionMappings() {}

  public static mlsub.typing.Constraint getTypeDefResolvedConstraint(mlsub.typing.TypeConstructor tc)
  { return null; }
  
  public static mlsub.typing.Monotype[] getTypeDefTypeParameters(mlsub.typing.TypeConstructor tc)
  { return null; }

  public static AST createAST(bossa.modules.Package module, List defs)
  { return null; }

  public static LocatedString NiceClass_getName(Object nc)
  { return null; }

  public static gnu.expr.ClassExp NiceClass_createClassExp(Object nc)
  { return null; }

  public static Definition NiceClass_importMethod(Object nc, gnu.bytecode.Method method)
  { return null; }

  public static void _printStackTraceWithSourceInfo(Throwable t) {}

  public static java.util.List findJavaMethods(gnu.bytecode.ClassType c, String s) { return null; }
}
