
package bossa.syntax;

import java.util.List;
/*
  This file is only useful to bootstrap the compiler,
  since bossa.syntax is implemented both in Java and Nice,
  while we need mutual recursion between the two.

  This class must have the interface of the Nice part of the package.
*/

public class dispatch
{
  public static void resetAlternatives() {}

  public static void testCoverage(bossa.modules.Package module) {}

  public static void resetDispatchTest() {}

  public static void readImportedAlternative(gnu.bytecode.ClassType c, gnu.bytecode.Method method, bossa.util.Location location) {}

  static TypeScope createGlobalTypeScope()
  { return null; }

  public static void resetConstructorsMap() {}

  static boolean instantiableTC(mlsub.typing.TypeConstructor tc)
  { return false; }

  public static void loadJavaMethods(String name) {}
  
  public static mlsub.typing.TypeConstructor lookupJavaClass(String className, bossa.util.Location loc)
  { return null; }
  
  public static void resetJavaClasses() {}

  static VarScope createGlobalVarScope()
  { return null; }

  public static Monotype createTypeIdent(LocatedString name)
  { return null;}

  public static Expression createIdentExp(LocatedString i)
  { return null; }

  public static Expression createCallExp(Expression function, Expression param1)
  { return null; }

  public static Expression createCallExp(Expression function, Expression param1, Expression param2)
  { return null; }

  public static VarSymbol createMethodSymbol(MethodDeclaration declaration, LocatedString name, Constraint constraint, Monotype returnType)
  { return null; }
  
  public static VarSymbol createMethodSymbol(MethodDeclaration declaration, LocatedString name, mlsub.typing.Polytype type)
  { return null; }

  public static gnu.bytecode.Method getImplementationAbove(MethodDeclaration decl, gnu.bytecode.ClassType firstArg)
  { return null; }

  static Expression analyse(Expression e, VarScope v, TypeScope t) 
  { return null; }

  static Expression analyse(Expression e, Info i) 
  { return null; }

  static void typecheck(Expression e) {}

  public static void resetTypeDefinitionMappings() {}

  public static TypeDefinition getTypeDefinition(mlsub.typing.TypeConstructor tc)
  { return null; }
  
  public static mlsub.typing.Monotype getTypeWithTC(mlsub.typing.TypeConstructor tc, mlsub.typing.Monotype[] sourceParams )
  { return null; }

  public static AST createAST(Module module, List defs)
  { return null; }

  public static void _printStackTraceWithSourceInfo(Throwable t) {}
}

class Info {}
