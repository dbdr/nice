/**************************************************************************/
/*                                N I C E                                 */
/*             A high-level object-oriented research language             */
/*                        (c) Daniel Bonniot 2002                         */
/*                                                                        */
/*  This program is free software; you can redistribute it and/or modify  */
/*  it under the terms of the GNU General Public License as published by  */
/*  the Free Software Foundation; either version 2 of the License, or     */
/*  (at your option) any later version.                                   */
/*                                                                        */
/**************************************************************************/

package nice.tools.compiler;

/**
   Nice compiler main program.

   Exit code table:
   0 : Normal exit (compilation sucessful, version message)
   1 : Abnormal termination (bug in the compiler)
   2 : Error reported (file missing, type error, ...)
   3 : Warning reported

   Changes to this table should be reflected in function 
   <code>nice-compilation-exit</code> in emacs mode file 
   <tt>nice-mode.el</tt>.

   @version $Date$
   @author Daniel Bonniot (bonniot@users.sourceforge.net)
 */

import mlsub.compilation;
import nice.getopt;
import nice.doc;
import bossa.modules;

/**
   @return a status code describing if the compilation was successful.
     The codes are found in OutputMessages (OK, WARNING, ERROR, BUG).
*/
int compile(String[] args)
{
  ?Throwable uncaughtException = null;
  boolean memInfo = false;
  String mainPackage;
  ?String nativeProgram = null;
  ?String nativeCompiler = null;
  ?String classpath = null;

  try{

  OutputMessages.start();

  Compilation compilation = new Compilation();

  Program prg = new Program
    (name: "nicec", longName: "The Nice Compiler",
     shortDescription: "compiler for the Nice programming language",
     author: "Daniel Bonniot <bonniot@users.sourceforge.net>, <Daniel.Bonniot@inria.fr>",
     seeAlso: "http://nice.sourceforge.net        the Nice Home Page\n",
     manualSection: "1",
     arguments: "package", options: cast(null));
  prg.options = 
  [
   option("sourcepath",
	  "Search path for source packages\nPATH is a list of directories and .jar archives",
	  "path",
	  fun(String path) => { compilation.sourcePath = path; }),

   option(letter: 'd', "destination",
	  "Destination directory for compiled packages",
	  "dir",
	  fun(String dir)=>{ compilation.destinationDir = dir; }),

   option("classpath",
	  "Search path for compiled packages and libraries\nPATH is a list of directories and .jar archives",
	  "path",
	  fun(String path) =>{ compilation.packagePath = path; }),


   option(letter: 'a', "jar",
	  "Compile to archive\nYou can then run the program with 'java -jar FILE'",
	  "file",
	  fun(String output) => { compilation.output = output; }),

   option(letter: 'o', "output",
	  "Generate native executable",
	  "file",
	  fun(String output) => { 
	    compilation.output = output + ".jar"; 
	    nativeProgram = output;
	  }),


   option(letter: 'r', "recompile",
	  "Force recompilation of package",
	  fun() => { compilation.recompileCommandLine = true; }),

   option(letter: 'R', "recompile-all",
	  "Force recompilation of all dependant packages",
	  fun() => { compilation.recompileAll = true; }),

   option(letter: 'c', "compile",
	  "Compile packages but do not link them",
	  fun() => { compilation.skipLink = true; }),


   // PRIVATE OPTIONS

   // This options is usefull for compiling the compiler itself. 
   // Should not be advertised since it should not be usefull otherwise
   option("exclude-runtime", 
	  "Avoid inclusion of the runtime in the archive", 
	  fun() => { compilation.excludeRuntime = true; }),
   option("runtime", 
	  "Location of nice.jar", 
	  "file",
	  fun(String file) => { compilation.runtimeFile = file; }),
   option("native-compiler", 
	  "Location of the native compiler binary (gcj)", 
	  "file",
	  fun(String file) => { nativeCompiler = file; }),


   option(letter: 'h', "help", "Print help message and exit",
	  fun()=> help(prg)),

   option("editor", "Tell nicec that it is called by an editor.",
	  fun()=> { bossa.util.Location.editorMode = true; }),

   option("man", "Print man page to stdout",
	  fun()=> man(prg)),

   option("version",
	  "Print version info and exit",
	  fun()=>version()),

   option("usage",
	  "Print usage information and exit",
	  fun()=>usage(prg)),

   option("memory",
	  "Print memory usage information after compilation",
	  fun()=>{ memInfo = true; })
  ];

  Sequence<String> rest = parse(prg, args);
  if (rest.size() != 1 || rest[0].length() == 0)
    {
      if (rest.size() > 1)
	println("Supply only one package on the command line.\n" +
		"nicec will automatically find dependancies.");
      usage(prg, OutputMessages.ERROR);
    }
  mainPackage = rest[0];

  compilation.setMainPackage(mainPackage);
  make(compilation);

  if (nativeProgram != null)
    produceNativeProgram(nativeCompiler, mainPackage, nativeProgram);
  }
  catch(OutputMessages.Exit e) {
    // Compilation was interrupted.
    return e.statusCode;
  }
  catch(bossa.util.UserError e){
    bossa.util.Internal.warning("user error only caught in main"); 
    nice.tools.compiler.OutputMessages.error(e.getMessage());
  }
  catch(ExceptionInInitializerError e){
    uncaughtException = e.getException();
  }
  catch(Throwable e){
    uncaughtException = e;
  }

  if (uncaughtException != null)
    {
      Throwable exn = uncaughtException;

      OutputMessages.bug
      ("\nAn exception has occured in the compiler\n" +
       "Please fill-in a bug report at the following webpage:\n" +
       "http://sourceforge.net/tracker/?func=add&group_id=12788&atid=112788" +
       "\n\nException: " + exn.toString() +
       "\n\nStack trace:\n");
      exn.printStackTrace();
    }

  if (memInfo) printMemoryUsage();

  return OutputMessages.getStatusCode();
}

main(args)
{
  int status = compile(args);

  // A non-zero code is interpreted as error, e.g. by make.
  // We do not want that if there are just warnings.
  // When called from an editor it does not matter, as it should be able to interpret warnings.
  if (! bossa.util.Location.editorMode && status == OutputMessages.WARNING)
    status = OutputMessages.OK;

  System.exit(status);
}

void version()
{
  println("Nice compiler version " + versionNumber + " (build " + buildDate + ")");
  println("Copyright (C) 2002 Daniel Bonniot");
  println("Visit the Nice homepage: http://nice.sourceforge.net");
  System.exit(0);
}

String prettyBytes(long bytes)
{
  long K = 1024;
  if (bytes < 10 * K)
    return ""+bytes+" B";
  else if (bytes < 100 * K)
    return ""+(bytes/K) + "." + ((bytes % K)/100) + " KB";
  else if (bytes < 10*K*K)
    return ""+(bytes/K) + " KB";
  else if (bytes < 100*K*K)
    return ""+(bytes/(K*K)) + "." + ((bytes % (K*K))/(100*K)) + " MB";
  else if (bytes < 10*K*K*K)
    return ""+(bytes/(K*K)) + " MB";
  else 
    return ""+(bytes/(K*K*K)) + " GB";
}

void printMemoryUsage()
{
  Runtime r = getRuntime();
  r.gc();
  long total = r.totalMemory();
  long free  = r.freeMemory();
  println("Memory allocated: " + prettyBytes(total) + 
	  ", used: " + prettyBytes(total - free));
}

// Local Variables:
// nice-xprogram: "nicec -d \"$HOME/Nice/classes\" --sourcepath=\"$HOME/Nice/src\" --classpath=\"$HOME/Nice/classes\""
// End:
