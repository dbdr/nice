<?xml version="1.0" standalone="no"?>
<!DOCTYPE book PUBLIC '-//OASIS//DTD DocBook XML V4.1.2//EN' 		     
'http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd' [ 
<!ENTITY nice "Nice">
<!ENTITY java "Java">
]>

<book>
  <bookinfo>
    <title>The Nice user's manual</title>
    <author><firstname>Daniel</firstname><surname>Bonniot</surname></author>
    <copyright><year>2002</year><holder>Daniel Bonniot</holder></copyright>
  </bookinfo>
  <preface><title>Foreword</title>
    <para>
      This manual describes the Nice programming language.
      It is currently under redaction, which means that many aspects of 
      the language are absent from it, or that some sections are mostly empty.
      During this time, it is recommended to read also the 
      <ulink url="http://nice.sf.net/language.html">Nice tutorial</ulink>, 
      which contains lots of additional information.
      Both documents currently assume some knowledge of Java, or at least
      of an object oriented language.
    </para>
  </preface>

  <chapter><title>Philosophy</title>
    <para>
      <blockquote>
	<attribution>Alan J. Perlis</attribution>
	<para>
	  A language that doesn't affect the way you think about programming, 
	  is not worth knowing.
	</para>
      </blockquote>

      The Nice programming language is a new object-oriented programming 
      language based on Java. 
      It incorporates features from functional programming, 
      and puts into practice state-of-the-art results from academic research. 
      This results in more expressivity, modularity and safety.
    </para>

    <variablelist>
      <varlistentry><term>Safety</term>
	<listitem>
	  <para>
	    Nice detects more errors during compilation than existing 
	    object-oriented languages (null pointer accesses, 
	    casts exceptions).
	    This means that programs written in Nice never throw the infamous
	    <literal>NullPointerException</literal> nor 
	    <literal>ClassCastException</literal>.
	    This aspect is developed in more details in 
	    <ulink url="http://nice.sf.net/safety.html">this article</ulink>.
	  </para>
	</listitem>
      </varlistentry>

      <varlistentry><term>Modularity</term><listitem><para>
	    In object-oriented languages, it is possible to add a new class 
	    to an existing class hierarchy. 
	    In Nice, it is also possible to add <emphasis>methods</emphasis> to 
	    existing classes without modifying their source file. 
	    This is a special case of <emphasis>multi-methods</emphasis>.
	  </para>
	</listitem>
      </varlistentry>

      <varlistentry><term>Expressivity</term><listitem><para>
	    Many repetitive programming tasks can be
	    avoided by using Nice's advanced features. 
	    Ever got bored
	    of writing tons of loops, casts, overloaded methods with default
	    values, ... ?
	  </para>
	</listitem>
      </varlistentry>
    </variablelist>

  </chapter>

  <chapter><title>Packages</title>
    <para>
    </para>
  </chapter>

  <chapter><title>Classes</title>
    <section><title>Declaring a class</title>
      <para>
      </para>
    </section>

    <section><title>Fields</title>
      <para>
	The main component of a class is the list of its fields.
	A field is a variable that is attached to each instance of
	the class. It has a type, a name, and optionally a default 
	initial value.
	The syntax for field declaration is:
	<programlisting>
	  <type>Type</type> fieldName<optional> = initialValue</optional>;
	</programlisting>
	If no default value is given, then every call to the constructor
	must specify the value for this field.
	If it is given, a call to the constructor call still override
	it with a different value, in which case the default value is
	not computed (this fact is only important if it has side effects).
      </para>
    </section>

    <section id="constructor"><title>Constructors</title>
      <para>
	There is no way to define a constructor in Nice. The reason is that
	in languages that support them, most constructors just take 
	as parameters the initial values for the fields and assign them
	to the new object. This simple but tedious task has to be done
	by the programmer for each class definition.
	In Nice, such a constructor is generated automatically by the compiler.
	It is called the automatic constructor. 
	It takes the names of the fields as named arguments, 
	and those who have an initial value are optional.
	The constructor is called <literal>new</literal> followed by
	the name of the class to create.
      </para>

      <example><title>Class definition and creations using the automatic constructor</title>
	<programlisting lang="nice">
class Car
{
  String brand;
  String model;
  int numberOfWheels = 4;
  int numberOfDrivingWheels = 2;
}

void test()
{
  Car renault5 = new Car(brand: "Renault", model: "Cinq");
  Car jeep = new Car(brand: "Jeep", model: "Some jeep", numberOfDrivingWheels: 4);
}</programlisting>
      </example>
      
      <para>
	It is required to include the names of the fields in the call
	to the constructor. 
	This is important for two reasons.
	First, it is easy to understand what the arguments represent, without looking at the
	class definition.
	Second, it does not require some arbitrary ordering of the fields
	<footnote>
	  <para>
	    A problem happens in Java when the order of the parameters 
	    of a constructor should be changed.
	    This requires modifying all the call sites, which is at best tedious
	    and error-prone, at worse impossible (when writing a library used by others).
	    When the order is changed and some caller are not modified,
	    the following happens:
	    if the exchanged parameters have incompatible types, 
	    the compilation of the caller will fail; 
	    otherwise the code might even compile and produce
	    wrong results at runtime. 
	    There is no simple way to solve this issue in Java.
	    Using names in the call to the constructor in Nice is the solution.
	  </para>
	</footnote>. Because the names of the fields are used, they can be given
	in any order.
      </para>

      <para>
	If a behaviour different than that of the automatic constructor is 
	needed, it is possible to define
	a creation <link linkend="function">function</link> that can perform 
	the task, calling the constructor to create the object and 
	initialize the fields.
	This function should by convention be called <literal>create</literal>
	suffixed by the name of the class to create.
      </para>
    </section>

    <section><title>Parametric classes</title>
      <para>
      </para>
    </section>

    <section><title>Functions and methods</title>
      <para>
      </para>
    </section>
  </chapter>

  <chapter id="function"><title>Functions</title>
    <section><title>Declaration</title>
      <para>
      </para>
    </section>

    <section id="namedParameters"><title>Named parameters</title>
      <para>
	When calling a function (or a <link linkend="method">method</link>)
	it is possible to specify the name of a parameter, followed by
	<literal>:</literal> before the value given to that parameter.
	Named parameters can be given in any order.
	This is useful when writting the call, because one does not
	need to remember the order of the arguments, but only their names.
	When reading the code, it is much easier to understand
	what each parameter is, provided the name was well chosen.
	
	<example>
	  <title>Using named parameters</title>
	  <programlisting lang="nice">
void copy(File from, File to) { ... }
...
copy(from: f1, to: f2);
copy(to: f3, from: f4);</programlisting>
	</example>
	
	Of course it is still possible to omit the names of the parameters,
	in which case the arguments must be given in the order of the 
	declaration.
      </para>
    </section>

    <section id="optionalParameters"><title>Optional parameters</title>
      <para>
	Many functions have some parameters that are used most of the time
	with the same value. In Nice, a parameter can be given a default
	value. It can then be omitted when calling the function and the
	default value is used. 

	<example>
	  <title>Using named and optional parameters</title>
	  <programlisting lang="nice">
void copy(File from, File to, int bufferSize = 1000) { ... }
...
copy(from: f1, to: f2); // with a buffer size of 1000
copy(from: f1, to: f2, bufferSize: 4000);</programlisting>
	</example>

	In the function definition, the optional parameters should be 
	listed after the required parameters. This is needed to allow 
	calls that do not name the arguments and want to use the default
	values for the optional parameters.
      </para>
    </section>
  </chapter>

  <chapter id="method"><title>Methods</title>
    <section><title>Declaring methods</title>
      <para>
      </para>
    </section>
    <section><title>Implementing methods</title>
      <para>
      </para>
    </section>
    <section><title>Optional parameters</title>
      <para>
	Methods, like functions, can have optional parameters.
	They are declared in the method declaration, using the
	<link linkend="optionalParameters">same syntax as in the case 
	  of functions</link>.
	Method implementations must still binds all parameters,
	including the optional ones, and can dispatch on them.
      </para>
    </section>
  </chapter>

  <chapter><title>Expressions</title>
    <section><title>Tuples</title>
      <para>
      </para>
    </section>

    <section><title>Anonymous functions</title>
      <para>
      </para>
    </section>
  </chapter>

  <chapter><title>Interfacing with Java</title>
    <section><title>Using Java from Nice</title>
      <para>
      </para>
    </section>

    <section><title>Using Nice from Java</title>
      <para>
        It is possible to use libraries developed in Nice in a 
	Java program.
	Before anything, make sure that the classes generated by nicec
	can be found on your classpath when you compile the Java program
	with javac.
      </para>

      <section><title>Calling a function</title>
	<para>
	  You can call a <link linkend="function">function</link> 
	  <literal>f</literal>
	  defined in a nice package <literal>pkg</literal> 
	  by naming it <literal>pkg.fun.f</literal> in the Java program.
	</para>
      </section>

      <section><title>Calling a method</title>
	<para>
	  You can call a <link linkend="method">method</link>
	   <literal>m</literal>
	  defined in a nice package <literal>pkg</literal> 
	  by naming it <literal>pkg.dispatch.m</literal> in the Java program.
	  It does not matter in what package(s) <literal>m</literal> 
	  is implemented: 
	  <literal>pkg</literal> must simply be the package where the method 
	  was declared.
	</para>
      </section>

      <section id="constructorFromJava"><title>Calling a constructor</title>
	<para>
	To instantiate in Java a class defined in Nice, do as usual:
	call its constructor, using the <literal>new</literal> keyword.
	Nice classes have one <link linkend="constructor">automatically 
	generated constructor</link>, 
	with one parameter for each field of the class, 
	including those inherited from Nice super-classes.
	</para>
      </section>

      <section><title>Complete example</title>
      <para>
      <example><title>Using Nice from Java</title>
	<para>
	Let's see an example that illustrates all these features.
	Suppose you Nice library looks like this:
	<programlisting lang="nice">
package my.nice.pkg;

class Person
{
  String name;

  // A method:
  String display();
  display() = "Person: " + name;
}

class Worker extends Person
{
  int salary;

  display() = "Worker: " + name + " salary: " + salary;

  // A function:
  boolean isRich() = salary > 500;
}

	</programlisting>

	Then your Java program can create new persons and workers:
	<programlisting lang="java">
package main.java.pkg;

import my.nice.pkg.*;

public class Main
{
  public static void main(String[] args)
  {
    Person p = new Person("John");
    Worker w = new Worker("Julia", 1000);

    println(my.nice.pkg.dispatch.display(p));
    println(my.nice.pkg.dispatch.display(w));
    if (my.nice.pkg.fun.isRich(w))
      println("A well paid worker!");
  }
}
        </programlisting>
	</para>
      </example>
      </para></section>

      <section><title>Optional parameters</title>
	<para>
	  Nice allows function and method parameters to be 
	  <link linkend="optionalParameters">optional</link>.
	  Since this feature is not available in Java, you have to 
	  provide the value of all parameters, regardless of their
	  optionality.
	  The same applies for class fields with initializers:
	  they are ignored in the Java program, and must be given a value
	  in the call to the constructor.
        </para>
      </section>

      <section><title>Other aspects</title>
	<para>
	Fields of Nice classes are accessed normally from Java programs.
	It is possible to declare a Java subclass of a Java class.
	The constructor will need to call the 
	<link linkend="constructorFromJava">parent constructor</link>.
	It is not possible to override a Nice multi-methods in a Java
	program.
	</para>
      </section>

    </section>
  </chapter>

  <chapter><title>Types</title>
    <para>
    </para>
  </chapter>

</book>

<!--
  Local Variables:
  sgml-validate-command: "xmllint -noout -valid %s %s"
  End:
 -->
