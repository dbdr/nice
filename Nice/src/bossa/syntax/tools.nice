/**************************************************************************/
/*                                N I C E                                 */
/*             A high-level object-oriented research language             */
/*                        (c) Daniel Bonniot 2001                         */
/*                                                                        */
/*  This program is free software; you can redistribute it and/or modify  */
/*  it under the terms of the GNU General Public License as published by  */
/*  the Free Software Foundation; either version 2 of the License, or     */
/*  (at your option) any later version.                                   */
/*                                                                        */
/**************************************************************************/

package bossa.syntax;

/**
   Helper functions.

 */

?LocatedString identString(?Expression);
identString(e) = null;
identString(IdentExp e) = e.ident;
identString(SymbolExp e) = e.getName();
identString(OverloadedSymbolExp e) = e.ident;

boolean isCallTo(CallExp e, String name) 
{
  ?LocatedString f = identString(e.function);
  return (f != null) && f.toString().equals(name);
}

?MonoSymbol localVariable(Expression);
localVariable(Expression e) = null;
localVariable(SymbolExp e)
{
  let sym = e.symbol;
  if (! (sym instanceof bossa.syntax.MonoSymbol))
    return null;

  //don't allow nullness inference on global variables.
  if (sym instanceof GlobalVarSymbol && sym.isAssignable())
    return null;

  // no type inference on captured variables
  if (sym.captured)
    return null;

  return sym;
}
localVariable(AssignExp e) = localVariable(e.to);

mlsub.typing.Monotype makeSure(mlsub.typing.Monotype m) = 
  notNull(bossa.syntax.Monotype.sure(nice.tools.typing.Types.rawType(m)));

mlsub.typing.Monotype makeUnsure(mlsub.typing.Monotype m) = 
  notNull(bossa.syntax.Monotype.maybe(nice.tools.typing.Types.rawType(m)));

mlsub.typing.Monotype ensureMonomorphic(mlsub.typing.Polytype type,
					LocalValue decl)
{
  type.simplify();

  if (type.getConstraint != null)
    {
      // If the type is polymorphic, we treat the type variables as soft:
      // we enter them in the context, so they are not generalized.

      // Make sure we are in a local typing context, so the new type variables
      // are discarded when the typechecking of the current method is over.
      enterLocalContext();

      notNull(type.getConstraint).enter(true);
    }

  return type.getMonotype();
}

/*
   Make sure that the error is attached to a location.
   If not, located it a the given located object (which should be a close 
   container of the entity creating the error).
*/
bossa.util.UserError ensureLocated(bossa.util.UserError e, 
				   bossa.util.Located loc)
{
  if (e.location == null)
    e.location = loc.location();
  return e;
}

?(MonoSymbol, mlsub.typing.Monotype) getInstanceof(CallExp condition)
{
  if (! condition.isCallTo("instanceof") || condition.arguments.size() != 2)
    return null;

  let sym = localVariable(condition.arguments.getExp(0));
  if (sym == null)
    return null;

  Expression arg2 = condition.arguments.getExp(1);
  if (! (arg2 instanceof TypeConstantExp))
    return null;

  ?TypeConstructor tc = arg2.getTC();
  if (tc == null)
    return null;

  if (tc == nice.tools.typing.PrimitiveType.arrayTC)
    return (sym, notNull(arg2.representedType));

  mlsub.typing.Monotype[?] parameters = null;

  if (tc.arity() != 0)
    {
      let originalType = nice.tools.typing.Types.rawType(sym.getMonotype());
      if (originalType instanceof mlsub.typing.MonotypeConstructor)
	parameters = originalType.getTP();
      else
	return null;
    }

  try {
    return (sym, Monotype.sure(new mlsub.typing.MonotypeConstructor(tc, parameters)));
  } catch(BadSizeEx e) {
    return null;
  }
}

void resolveCCThis(Statement stmt, Located thisLoc, NiceClass classe)
{
  void missingThisError()
  {
    User.error(thisLoc, "The last statement must be a call to 'this' constructor");
  }

  Block block = cast(stmt);

  if (block.statements.length == 0)
    missingThisError();

  Statement last = block.last;
  if (last instanceof Block)
  {
    resolveCCThis(last, thisLoc, classe);
    return;
  }
  
  if (! (last instanceof ExpressionStmt))
    missingThisError();

  ExpressionStmt expstmt = cast(last);

  if (! (expstmt.exp instanceof CallExp))
    missingThisError();

  CallExp call = cast(expstmt.exp);

  if (! (call.function instanceof IdentExp))
    missingThisError();

  IdentExp ident = cast(call.function);

  if (! ident.toString().equals("this"))
    missingThisError();

  call.function = createOverloadedSymbolExp(new ArrayList(cast(classe).getConstructorCallSymbols()),
					thisName);
  call.function.setLocation(ident.location());
}

/**
   A mapping from type names to type symbols.

*/
public class TypeMaper implements TypeMap
{
  nice.tools.ast.SymbolTable<mlsub.typing.TypeSymbol> inner;
  TypeScope global;
  
  lookup(LocatedString name) = this.lookup(name.toString(), name.location());

  lookup(String name) = this.lookup(name, null);

  public ?mlsub.typing.TypeSymbol lookup(String name, ?bossa.util.Location loc)
  {
    return inner.get(name) || global.lookup(name, loc);
  }
}

// For bootstrap
void _printStackTraceWithSourceInfo(Throwable t) =
  printStackTraceWithSourceInfo(t);

/****************************************************************
 * Temporary: this should be solved when AST classes are written 
 * in Nice, with precise types for the fields.
 ****************************************************************/

LocatedString name(VarSymbol) = native VarSymbol.name;
Arguments.Argument[] arguments(Arguments) = native Arguments.arguments;
Arguments Argument(List<Arguments.Argument>) = native new Arguments(List);
Arguments Argument(Arguments.Argument[]) = native new Arguments(Arguments.Argument[]);
mlsub.typing.Polytype getType(Expression) = 
  native mlsub.typing.Polytype Expression.getType();
mlsub.typing.Monotype type(MonoSymbol) = native MonoSymbol.type;
GlobalTypeScope getGlobalTypeScope() = native GlobalTypeScope Node.getGlobalTypeScope();
?gnu.bytecode.ClassType staticClass(Arguments) = native gnu.bytecode.ClassType Arguments.staticClass();
?gnu.bytecode.ClassType staticClass(Expression) = native gnu.bytecode.ClassType Expression.staticClass();
Map<VarSymbol,mlsub.typing.Polytype> types(Arguments) = native Arguments.types;
<T> String map(String, String, String, T[]) = native String bossa.util.Util.map(String, String, String, Object[]);
<T> String map(String, String, String, ?Collection<T>) = native String bossa.util.Util.map(String, String, String, Collection);
?mlsub.typing.lowlevel.Kind getKind(mlsub.typing.lowlevel.Element) = native mlsub.typing.lowlevel.Kind mlsub.typing.lowlevel.Element.getKind();
?gnu.expr.Declaration getDeclaration(Expression) = native gnu.expr.Declaration Expression.getDeclaration();
?Object getFieldAccessMethod(Expression) = native Object Expression.getFieldAccessMethod();
?Object getField(Expression) = native Object Expression.getField();
?Object getFieldAccessMethod(VarSymbol) = native Object VarSymbol.getFieldAccessMethod();
?mlsub.typing.Monotype Types_getTypeParameter(mlsub.typing.Polytype, int) = native mlsub.typing.Monotype nice.tools.typing.Types.getTypeParameter(mlsub.typing.Polytype, int);
?mlsub.typing.Monotype Types_getTypeParameter(mlsub.typing.Monotype, int) = native mlsub.typing.Monotype nice.tools.typing.Types.getTypeParameter(mlsub.typing.Monotype, int);
mlsub.typing.Monotype[?] Types_parameters(mlsub.typing.Polytype) = native mlsub.typing.Monotype[] nice.tools.typing.Types.parameters(mlsub.typing.Polytype);
?mlsub.typing.TypeConstructor head(mlsub.typing.Monotype) = native mlsub.typing.TypeConstructor mlsub.typing.Monotype.head();
?gnu.bytecode.ClassType getSuperclass(gnu.bytecode.ClassType) = native gnu.bytecode.ClassType gnu.bytecode.ClassType.getSuperclass();
int[?] getUsedArguments(Arguments, VarSymbol) = native int[] Arguments.getUsedArguments(VarSymbol);
?mlsub.typing.Constraint getConstraint(mlsub.typing.Polytype) = native mlsub.typing.Constraint mlsub.typing.Polytype.getConstraint();
mlsub.typing.AtomicConstraint[?] AtomicConstraint_substitute(java.util.Map<mlsub.typing.TypeSymbol,mlsub.typing.TypeSymbol>, AtomicConstraint[?]) = native mlsub.typing.AtomicConstraint[] mlsub.typing.AtomicConstraint.substitute(java.util.Map, mlsub.typing.AtomicConstraint[]);
?gnu.expr.Expression getInitializer(NiceClass) = native gnu.expr.Expression NiceClass.getInitializer();
void addConstructorCallSymbol(NiceClass, VarSymbol) = native void NiceClass.addConstructorCallSymbol(VarSymbol);
gnu.expr.Expression callSuperMethod(NiceClass, gnu.bytecode.Method) = native gnu.expr.Expression NiceClass.callSuperMethod(gnu.bytecode.Method);
Module module(Definition) = native Definition.module;
?Definition importMethod(NiceClass, gnu.bytecode.Method) = native Definition NiceClass.importMethod(gnu.bytecode.Method);
boolean equals(LocatedString, LocatedString) = native boolean LocatedString.equals(LocatedString);
mlsub.typing.AtomicConstraint[?] resolvedConstraints(MethodContainer) = native MethodContainer.resolvedConstraints;
mlsub.typing.TypeSymbol[?] getBinders(MethodContainer) = native mlsub.typing.TypeSymbol[] MethodContainer.getBinders();
?gnu.bytecode.Attribute get(gnu.bytecode.AttrContainer, String) = native gnu.bytecode.Attribute gnu.bytecode.Attribute.get(gnu.bytecode.AttrContainer, String);
void printInterface(Definition, java.io.PrintWriter) = native void Definition.printInterface(java.io.PrintWriter);
?gnu.expr.Declaration getDeclaration(VarSymbol) = native gnu.expr.Declaration VarSymbol.getDeclaration();
void printInterface(ClassImplementation, java.io.PrintWriter) = native void ClassImplementation.printInterface(java.io.PrintWriter);
?Variance makeVariance(List<int>) = native Variance MethodContainer.makeVariance(List);
List<AtomicConstraint> getAtoms(Constraint) = native List Constraint.getAtoms();
?mlsub.typing.Interface getAssociatedInterface(TypeDefinition) = native mlsub.typing.Interface TypeDefinition.getAssociatedInterface();
?mlsub.typing.Polytype getConstrainedType(TypeDefinition) = native mlsub.typing.Polytype TypeDefinition.getConstrainedType();
mlsub.typing.Monotype[?] resolve(TypeMap, Monotype[?]) = native mlsub.typing.Monotype[] Monotype.resolve(TypeMap, Monotype[]);
MethodContainer.Constraint MethodContainer$Constraint(TypeSymbol[], List<AtomicConstraint>, ?mlsub.typing.Monotype[], Location)
  = native new MethodContainer.Constraint(TypeSymbol[], List, mlsub.typing.Monotype[], Location);
?gnu.bytecode.Type TypeImport_lookup(LocatedString) = native gnu.bytecode.Type nice.tools.code.TypeImport.lookup(LocatedString);
List<Node> children(Node) = native Node.children;
LocatedString name(Definition) = native Definition.name;
void addMappingsLS(TypeScope, Collection<LocatedString>, TypeSymbol[]) = native void TypeScope.addMappingsLS(Collection, TypeSymbol[]);
gnu.expr.CopyArgument CopyArgument(Stack<gnu.bytecode.Variable>) = native new gnu.expr.CopyArgument(Stack);
MethodContainer MethodContainer(LocatedString, int, MethodContainer.Constraint, List<?boolean>) = native new MethodContainer(LocatedString, int, MethodContainer.Constraint, List);
AST AST(List<Definition>, int) = native new AST(List, int);
?String getParentFor(AtomicConstraint, mlsub.typing.TypeConstructor) = native String AtomicConstraint.getParentFor(mlsub.typing.TypeConstructor);
mlsub.typing.AtomicConstraint resolve(AtomicConstraint, TypeScope) = native mlsub.typing.AtomicConstraint AtomicConstraint.resolve(TypeScope);
bossa.syntax.Monotype substitute(bossa.syntax.Monotype,Map<String,bossa.syntax.Monotype>) = native bossa.syntax.Monotype bossa.syntax.Monotype.substitute(Map);
List<bossa.syntax.Monotype> substitute(Map<String,bossa.syntax.Monotype>,Collection<bossa.syntax.Monotype>) = native List bossa.syntax.Monotype.substitute(Map,Collection);
boolean containsAlike(List<bossa.syntax.Monotype>) = native boolean bossa.syntax.Monotype.containsAlike(List);
mlsub.typing.Monotype[] rawResolve(TypeMap,Collection<bossa.syntax.Monotype>) = native mlsub.typing.Monotype[] bossa.syntax.Monotype.rawResolve(TypeMap, Collection);
boolean containsAlike(Monotype[]) = native boolean Monotype.containsAlike(Monotype[]);
bossa.syntax.Monotype[] substitute(Map<String,bossa.syntax.Monotype>,bossa.syntax.Monotype[]) = native bossa.syntax.Monotype[] bossa.syntax.Monotype.substitute(Map,bossa.syntax.Monotype[]);
?mlsub.typing.TypeSymbol lookup(TypeMap, LocatedString) = native mlsub.typing.TypeSymbol TypeMap.lookup(LocatedString);
?mlsub.typing.TypeSymbol lookup(TypeMap, String) = native mlsub.typing.TypeSymbol TypeMap.lookup(String);
Monotype[] Monotype_toArray(?List<Monotype>) = native Monotype[] Monotype.toArray(List);
List<VarSymbol> lookup(VarScope, LocatedString) = native List VarScope.lookup(LocatedString);
Map<gnu.bytecode.Type,mlsub.typing.TypeConstructor> javaTypeConstructors(bossa.modules.Compilation ) = native bossa.modules.Compilation.javaTypeConstructors;
bossa.syntax.Constraint newConstraint(List<TypeSymbol>, List<AtomicConstraint>) = native new Constraint(List, List);
void addAtoms(Constraint, List<AtomicConstraint>) = native void Constraint.addAtoms(List);
Map<VarSymbol, int[]> usedArguments(Arguments) = native Arguments.usedArguments;
Map<VarSymbol, Expression[]> applicationExpressions(Arguments) = native Arguments.applicationExpressions;

// Retypings needed since java types are not strict.
mlsub.typing.Polytype boolPolytype() = native nice.tools.typing.PrimitiveType.boolPolytype;
mlsub.typing.Polytype longPolytype() = native nice.tools.typing.PrimitiveType.longPolytype;
mlsub.typing.Polytype voidPolytype() = native nice.tools.typing.PrimitiveType.voidPolytype;
mlsub.typing.Monotype boolType() = native nice.tools.typing.PrimitiveType.boolType;
mlsub.typing.Monotype intType() = native nice.tools.typing.PrimitiveType.intType;
mlsub.typing.Monotype longType() = native nice.tools.typing.PrimitiveType.longType;
gnu.expr.QuoteExp trueExp() = native gnu.expr.QuoteExp.trueExp;
gnu.expr.QuoteExp voidExp() = native gnu.expr.QuoteExp.voidExp;

// Local Variables:
// nice-xprogram: "../bin/nicec -d ../classes"
// End:
