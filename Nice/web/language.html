<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="Author" content="Daniel Bonniot">
   <meta name="GENERATOR" content="Mozilla/4.7 [en] (WinNT; I) [Netscape]">
   <title>The Nice programming language</title>
   <link rel=stylesheet href="style.css">
</head>
<body text="#000000" bgcolor="#FFFFFF" link="#0000EF" vlink="#51188E" alink="#FF0000">

<center>
<h1>
The <font face="Comic Sans MS">Nice</font> programming language</h1></center>

<blockquote>This page is intended to provide a gentle introduction to the
Nice programming language. The goal is to help you write your first Nice
programs. It does not describe every feature of the language, nor gives
it a complete description of the powerfull type system.
<br>&nbsp;
<h2>
Requirements</h2>
For simplicity and conciseness, this tutorial presents Nice as an extension
of the Java programming language. You should therefore be familiar with
Java. If not, you could read about it, for example <a href="http://web2.java.sun.com/docs/books/tutorial/">Javasoft's
tutorial</a>.
<br>&nbsp;
<h2>
Declaring classes and methods</h2>
Classes and methods can be declared as in Java:
<p><tt>class Person</tt>
<br><tt>{</tt>
<br><tt>&nbsp; String name;</tt>
<br><tt>&nbsp; int age;</tt>
<p><tt>&nbsp; String display();</tt>
<br><tt>}</tt>
<p><tt>class Worker extends Person</tt>
<br><tt>{</tt>
<br><tt>&nbsp; int salary;</tt>
<br><tt>}</tt>
<p>Note that <tt>String display(); </tt><b>declares</b> a method, that
is informs that this method exists. Now we have to <b>define</b> it, that
is tell what code is to be executed, depending on the runtime type of the
person (in this short example either <tt>Person</tt> or <tt>Worker</tt>).
<br>&nbsp;
<h2>
Defining methods</h2>
Method definitions are place outside of classes. Their order does not matter
at all. The definitions of a single method may even occur in several files
(this is not a flaw, it's an important feature that allows modularity).
<p>So after the two above class definitions, we define to <b>alternatives</b>
for method <tt>display </tt>:
<p><tt>display(p@Person)</tt>
<br><tt>{</tt>
<br><tt>&nbsp; return p.name + " (age=" + p.age + ")";</tt>
<br><tt>}</tt>
<p><tt>display(p@Worker)</tt>
<br><tt>{</tt>
<br><tt>&nbsp; return p.name + " (age+" + p.age + ", salary=" + p.salary
+ ")";</tt>
<br><tt>}</tt>
<br>&nbsp;
<h2>
Parametric classes</h2>
Classes and interfaces can have type parameters. For example, the <tt>Collection</tt>
interface is parametrized by the type of its elements:
<p><tt>interface Collection&lt;T></tt>
<br><tt>{</tt>
<br><tt>&nbsp; ...</tt>
<br><tt>}</tt>
<p>If a class (resp. interface) has type parameters, then all its sub-classes
(resp. sub-interfaces and implementing classes) must have the same type
parameters.
<p><tt>class LinkedList&lt;T> implements Collection&lt;T></tt>
<br><tt>{</tt>
<br><tt>&nbsp; T head;</tt>
<br><tt>&nbsp; LinkedList&lt;T> tail;</tt>
<br><tt>}</tt>
<p>A consequence of this rule is that there is no class (like <tt>Object</tt>
in Java) that is an ancestor of all classes. There could not be, since
all classes do not have the same number of type parameters.
<br>However, it is possible to express that a method takes arguments of
any type. For instance the equals method is declared in Nice:
<br><tt>&lt;Any T> boolean equals(T, T);</tt>
<p>One can read this as "for Any type T, the method equals takes two objects
of type T, and returns a boolean".
<p>Thanks to the usual subsumption rule, this type makes it possible to
call equals with arguments of different type, as long as they are compatible
(have a common super type). For instance, it's legal to use equals to compare
expressions of type <tt>Collection&lt;int></tt> and <tt>LinkedList&lt;int></tt>,
while it is not with types <tt>Collection&lt;String></tt> and <tt>String</tt>.
<p>This approach is more sensible than Java's one, where the laters would
be allowed and would always return false (not even raising a runtime error),
while it is very likely a bug to compare a collection of strings to a string.
<p>Note that it is also possible to define a function that takes two unrelated
and unconstrained types. So it would be possible to define equals to have
the same typing behaviour it has in Java:
<br><tt>&lt;Any T, Any U> boolean equals(T, U);</tt>
<p>A more sensible example is the pair creation function:
<br><tt>class Pair&lt;T, U> { ... }</tt>
<p><tt>&lt;Any T, Any U> Pair&lt;T, U> pair(T, U);</tt>
<br>&nbsp;
<h2>
Multiple dispatch</h2>
In Nice, the choice of the method alternative is made at run-time, based
on <b>all</b> parameters (in java, only the first, implicit parameter is
used to choose the alternative).
<p>Let's take the example of the equals method, that tests if any two objects
are equal.
<br>&nbsp;
<br>&nbsp;
<center><table BORDER WIDTH="90%" BGCOLOR="#CCCCCC" >
<tr>
<td>
<center>Java</center>
</td>

<td>
<center>Nice</center>
</td>
</tr>

<tr>
<td>
<blockquote>
<pre>
class Object
{
  boolean equals(Object that)
  {
    return this == that;
  }
}

class Person extends Object 
{
  String name;
  int age;

  boolean equals(Object that)
  {
    <font color="#FF0000">if(!(that instanceof Person))</font>
<font color="#FF0000">      return false;</font>
    return name.equals((<font color="#FF0000">(Person)</font> that).name)
       &amp;&amp; age==(<font color="#FF0000">(Person)</font> that).age;
  }
}
</pre>
</blockquote>
</td>

<td>
<blockquote>
<pre>
&lt;<FONT COLOR="#b7860b">Any</FONT> T&gt; <FONT COLOR="#b7860b">boolean</FONT> equals(T, T); 

<FONT COLOR="#cd0000">equals</FONT>(o1, o2) = o1==o2; 

<FONT COLOR="#0000ee">class</FONT> <FONT COLOR="#cd0000">Person</FONT> 
{ 
  <FONT COLOR="#b7860b">String</FONT> name; 
  <FONT COLOR="#b7860b">int</FONT> age; 
} 

<FONT COLOR="#cd0000">equals</FONT>(p1<FONT COLOR="#0000ee">@</FONT><FONT COLOR="#b7860b">Person</FONT>, p2<FONT COLOR="#0000ee">@</FONT><FONT COLOR="#b7860b">Person</FONT>) =  
  p1.name.equals(p2.name) &amp;&amp; 
  p1.age==p2.age; 
</pre>
</blockquote>
</td>
</tr>
</table></center>

<p>In the Nice version, the last <tt>equals</tt> alternative will be executed
when both parameters are instance of class Person. So the type of the second
argument is also known, and no manual instanceof and no cast are necessary
(red parts of the java code). This job is sort of automatically done by
the compiler for you. The code looks cleaner, is simpler to understand,
and it is automatically guaranteed that no runtime exception will occur
(this simple java code would not break either, but you have to think about
it, and it becomes extremely difficult in large projects).
<h2>
Precise types</h2>
Java's type system is too simple to express many usefull types. For instance,
let's suppose we want to declare the method map on Collections. Map applies
a function to each element of the collection, and returns a new collection
holding the results. That is:
<br>map(f, [e1, ..., en]) = [f(e1), ..., f(en)];
<br>&nbsp;
<br>&nbsp;
<center><table BORDER WIDTH="100%" BGCOLOR="#CCCCCC" >
<tr>
<td>
<center>Java + higher order functions</center>
</td>

<td>
<center>Nice</center>
</td>
</tr>

<tr>
<td>interface Collection
<br>{
<br>&nbsp; Collection filter(fun(Object)(boolean) f);
<br>}
<p>interface List extends Collection { ... }
<p>boolean f(Object o) {&nbsp; ... }
<p>void main(String[] args)
<br>{
<br>&nbsp; List l1;
<br>&nbsp; ...
<br>&nbsp; List l2 = <font color="#FF0000">(List)</font> l1.filter(f);
<br>}</td>

<td>interface Collection&lt;T>
<br>{
<br>&nbsp; alike&lt;T> filter(fun(T)(boolean) f);
<br>}
<p>interface List&lt;T> extends Collection&lt;T> { ... }
<p>boolean f(int);
<p>main(args)
<br>{
<br>&nbsp; List&lt;int> l1;
<br>&nbsp; ...
<br>&nbsp; List l2 = l1.filter(f);
<br>}</td>
</tr>
</table></center>

<p>In the nice version, the alike keyword is a type that means "the same
type as the implicit receiver argument".
<p>Note that there is not special treatment for the alike construct in
the core type system. Alike is syntactic sugar for a more general concept:
polymorphic constrained types.
<p>The clone example might be more familiar to Java users. In Java, the
clone method, defined in class Object, has a Object return type. In fact,
one would like to express that the clone method returns an object of the
same type as its argument. This is possible in Nice, and it allows for
cast-less use of clone.
<br>&nbsp;
<center><table BORDER WIDTH="100%" BGCOLOR="#CCCCCC" >
<tr>
<td>
<center>Java</center>
</td>

<td>
<center>Nice</center>
</td>
</tr>

<tr>
<td>class Object
<br>{
<br>&nbsp; Object clone();
<br>}
<p>void main(String[] args)
<br>{
<br>&nbsp; java.util.Date d1;
<br>&nbsp; ...
<br>&nbsp; java.util.Date d2 = <font color="#FF0000">(Date)</font> d1.clone();
<br>}</td>

<td>&lt;Any T> T clone(T);
<p>main(args)
<br>{
<br>&nbsp; java.util.Date d1;
<br>&nbsp; ...
<br>&nbsp; java.util.Date d2 = d2.clone();
<br>}</td>
</tr>
</table></center>

<h2>
Instructions and expressions</h2>
The code of a method alternative, that goes between <tt>{</tt> and <tt>}</tt>,
can be virtually any legal Java code.
<br>Here is a list of the differences:
<center>
<p><b>Missing constructs</b></center>

<ul>
<li>
<b>No casts</b>. We claim that our powerfull type system makes it possible
to avoid nearly every cast used in other object-oriented languages (say
95% of them!). For the 5% remaining, it is possible to write methods that
do the same job, except you have to explicitely write what happends if
the "cast" fails, which is a nice property.</li>

<li>
<b>Visibility modifiers</b> (<tt>public, private</tt>) are accepted for
class members, but are currently ignored.</li>
</ul>

<center><b>Additional constructs</b></center>

<ul>
<li>
<b>Closures</b> (functions written inside expressions). The expression
<tt>fun(T1
p1, T2 p2)=>e</tt> is the two parameters function that returns
<tt>e</tt>.
The return type of the function is computed, so you don't have to write
it. Parameters <tt>p1</tt> and <tt>p2 </tt>can of course occur in <tt>e</tt>.
Outside variables can also safely occur in e, in which case their <b>reference</b>
is captured (not their value). An alternate syntax is <tt>fun(T1 p1, T2
p2)=>{ inst1; ...; instn; }</tt>. Every execution of the body should lead
to a return statement. The return type of the function is the lowest common
type of the returned expressions.</li>

<li>
<b>Functional arguments</b>. A function or a method can have functional
arguments. The concrete syntax for functional type <i>(T1, T2, ..., Tn)
-> T</i> is <tt>fun(T1, T2, ..., Tn)(T)</tt>.</li>

<li>
<b>Functional-like syntax for method definitions</b>. One can write <tt>f(x@P)
= e; </tt>as an equivalent form for <tt>f(x@p) { return e; }</tt>. This
is very handy when defining methods that return simple values, depending
on the type of the argument -- that is doing <i>pattern-matching</i>.</li>
</ul>
</blockquote>

<blockquote>&nbsp;
<h2>
Interfacing with Java</h2>
It is possible to use java classes and methods from Nice programs. This
is a great advantage, since it gives access to the gigantic and evergrowing
set of Java libraries.
<p>One can just use java classes in types, and call java methods in Nice
code. It is not necessary to explicitely import classes or methods. An
import statement can be used if one does not want to reapeat a package
name.
<p><tt>import java.io.*;</tt>
<p><tt>{</tt>
<br><tt>&nbsp; String s;</tt>
<br><tt>&nbsp; ...</tt>
<br><tt>&nbsp; java.io.Writer w = new FileWriter(s);</tt>
<br><tt>&nbsp; w.write("Hello world");</tt>
<br><tt>&nbsp; w.close();</tt>
<br><tt>}</tt>
<br>&nbsp;
<p>However, one might want to explicitely import methods to give them a
more precise type (to benefit from paramteric types for instance). Here
is a more sophisticated example for the <tt>java.util.Map</tt> interface:
<p><tt>interface Map&lt;Key,Element> = native java.util.Map;</tt>
<p><tt>&lt;Any Key, Any Element> Element get(Map&lt;Key,Element>, Key)
=</tt>
<br><tt>&nbsp; native Object java.util.Map.get(Object);</tt>
<br>&nbsp;
<p>Calling Nice code from Java is also possible, but is not so straightforward
because the generated methods get mangled names, and because of the different
dispatch mecanism. This could be worked on if necessary.
<br>&nbsp;
<h2>
<font color="#000000">What else?</font></h2>
<font color="#000000">Many features are missing in this tutorial: abstract
interfaces, general constraints, final implementation, ...</font>
<h2>
<font color="#000000">General information about Nice : the <a href="index.html">Nice
home page</a></font></h2>
&nbsp;</blockquote>

</body>
</html>
