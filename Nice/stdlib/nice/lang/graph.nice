package nice.lang;

import gnu.math.*;

/** 
    Returns the strongly connected components
    of the graph rooted at the first argument,
    which edges are given by the function argument.
 
    The scc are returned in topological order.
    Tarjan's algorithm (linear).
 */
<Any T> List<List<T>> stronglyConnectedComponents(T start, 
						  T->List<T> successors)
{
  Ref<int> id = new Ref(0);
  Stack<T> stack = makeVector(5);
  Map<T,int> mark = hashtable();

  List<List<T>> res = makeVector(5);
  visit(start,successors,id,stack,mark,res);
  
  return res;
}

<Any T> int visit(T node, T->List<T> successors, 
		  Ref<int> id, Stack<T> stack, Map<T,int> mark, 
		  List<List<T>> res)
{
  value(id)=value(id)+1;

  mark.put(node, value(id));
  stack.push(node);

  int min = id.value;
  successors(node).iter(fun(T child)=>{
    int m;
    try{
      m = notNull(mark.get(child));
    }
    catch(NullPointerException e){
      m = visit(child, successors, id, stack, mark, res);
    }
    
    if(m<min) 
      min=m;
  });

  if(equals(min,mark.get(node)))
    {
      Vector<T> scc = makeVector(5);
      // XXX: element does not need to be initialized. Remove when stable compiler allow this
      T element = stack.top();
      do
	{
	  element = stack.pop();
	  scc.add(element);
	  mark.put(element,MAX_INT());
	}
      while (element != node);
      res.add(scc);
    }
  return min;
}
