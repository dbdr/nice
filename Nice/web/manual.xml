<?xml version="1.0" standalone="no"?>
<!DOCTYPE book PUBLIC '-//OASIS//DTD DocBook XML V4.1.2//EN' 		     
'http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd' [ 
<!ENTITY nice "Nice">
<!ENTITY java "Java">
<!ENTITY NULL "<literal>null</literal>">
<!ENTITY LT "<literal>&lt;</literal>">
<!ENTITY GT "<literal>&gt;</literal>">
<!ENTITY LBRACE "<literal>{</literal>">
<!ENTITY RBRACE "<literal>}</literal>">
]>

<book>
  <bookinfo>
    <title>The Nice user's manual</title>
    <author><firstname>Daniel</firstname><surname>Bonniot</surname></author>
    <copyright><year>2003</year><holder>Daniel Bonniot</holder></copyright>
  </bookinfo>
  <preface><title>Foreword</title>
    <para>
      This manual describes the Nice programming language.
      It is currently under redaction, which means that many aspects of 
      the language are absent from it, or that some sections are mostly empty.
      During this time, it is recommended to read also the 
      <ulink url="http://nice.sf.net/language.html">Nice tutorial</ulink>, 
      which contains lots of additional information.
      Both documents currently assume some knowledge of Java, or at least
      of an object oriented language.
    </para>

    <para>
      The authors of this manual are Bryn Keller and Daniel Bonniot.
    </para>
  </preface>

  <chapter><title>Philosophy</title>
    <para>
      <blockquote>
	<attribution>Alan J. Perlis</attribution>
	<para>
	  A language that doesn't affect the way you think about programming, 
	  is not worth knowing.
	</para>
      </blockquote>

      The Nice programming language is a new object-oriented programming 
      language based on Java. 
      It incorporates features from functional programming, 
      and puts into practice state-of-the-art results from academic research. 
      This results in more expressivity, modularity and safety.
    </para>

    <variablelist>
      <varlistentry><term>Safety</term>
	<listitem>
	  <para>
	    Nice detects more errors during compilation than existing 
	    object-oriented languages (null pointer accesses, 
	    casts exceptions).
	    This means that programs written in Nice never throw the infamous
	    <literal>NullPointerException</literal> nor 
	    <literal>ClassCastException</literal>.
	    This aspect is developed in more details in 
	    <ulink url="http://nice.sf.net/safety.html">this article</ulink>.
	  </para>
	</listitem>
      </varlistentry>

      <varlistentry><term>Modularity</term><listitem><para>
	    In object-oriented languages, it is possible to add a new class 
	    to an existing class hierarchy. 
	    In Nice, it is also possible to add <emphasis>methods</emphasis> to 
	    existing classes without modifying their source file. 
	    This is a special case of <emphasis>multi-methods</emphasis>.
	  </para>
	</listitem>
      </varlistentry>

      <varlistentry><term>Expressivity</term><listitem><para>
	    Many repetitive programming tasks can be
	    avoided by using Nice's advanced features. 
	    Ever got bored
	    of writing tons of loops, casts, overloaded methods with default
	    values, ... ?
	  </para>
	</listitem>
      </varlistentry>
    </variablelist>

  </chapter>

  <chapter id = "packages" ><title>Packages</title>
    <para>
     A <firstterm>package</firstterm> is a group of related classes, functions,
     methods, and variables. You can declare that all the code in a particular
     <literal>.nice</literal> file belongs to a certain package with the 
     declaration:
    </para>
    <para>
      <literal>package</literal> package-name<literal>;</literal>
    </para>
    <para>
     To make use of all the public entities from another Nice package,
     use the <literal>import</literal> statement:
    </para>
    <para>
      <literal>import</literal> package-name<literal>;</literal>
    </para>
    <para>
      Note that this is somewhat different from Java packages.
      In Java, a class can be used independantly of its declaring package.
      In Nice methods can be declared outside classes, so importing
      the whole package is important to know the methods available for a
      given class.
      This probably implies that Nice projects should be designed with
      smaller, self-contained packages that Java projects.
    </para>
    <para>
      Therefore, only whole packages can be imported.
      It is not possible to import a single class.
      Likewise, there is no need to 
      include a <literal>.*</literal> after the package name as in Java. 
      In fact, using <literal>.*</literal> indicates that you wish to import 
      the contents of a Java package rather than a Nice package. 
      See the section on <link linkend="importJava">Java imports</link> 
      for details.
    </para>
  </chapter>

  <chapter><title>Classes</title>
    <section><title>Declaring a class</title>
      <para>
      </para>
    </section>

    <section><title>Fields</title>
      <para>
	The main component of a class is the list of its fields.
	A field is a variable that is attached to each instance of
	the class. It has a type, a name, and optionally a default 
	initial value.
	The syntax for field declaration is:
	<programlisting>
	  <type>Type</type> fieldName<optional> = initialValue</optional>;
	</programlisting>
	If no default value is given, then every call to the constructor
	must specify the value for this field.
	If it is given, a call to the constructor call still override
	it with a different value, in which case the default value is
	not computed (this fact is only important if it has side effects).
      </para>
    </section>

    <section id="constructor"><title>Constructors</title>
      <para>
	There is no way to define a constructor in Nice. The reason is that
	in languages that support them, most constructors just take 
	as parameters the initial values for the fields and assign them
	to the new object. This simple but tedious task has to be done
	by the programmer for each class definition.
	In Nice, such a constructor is generated automatically by the compiler.
	It is called the automatic constructor. 
	It takes the names of the fields as named arguments, 
	and those who have an initial value are optional.
	The constructor is called <literal>new</literal> followed by
	the name of the class to create.
      </para>

      <example><title>Class definition and creations using the automatic constructor</title>
	<programlisting lang="nice">
class Car
{
  String brand;
  String model;
  int numberOfWheels = 4;
  int numberOfDrivingWheels = 2;
}

void test()
{
  Car renault5 = new Car(brand: "Renault", model: "Cinq");
  Car jeep = new Car(brand: "Jeep", model: "Some jeep", numberOfDrivingWheels: 4);
}</programlisting>
      </example>
      
      <para>
	It is required to include the names of the fields in the call
	to the constructor. 
	This is important for two reasons.
	First, it is easy to understand what the arguments represent, without looking at the
	class definition.
	Second, it does not require some arbitrary ordering of the fields
	<footnote>
	  <para>
	    A problem happens in Java when the order of the parameters 
	    of a constructor should be changed.
	    This requires modifying all the call sites, which is at best tedious
	    and error-prone, at worse impossible (when writing a library used by others).
	    When the order is changed and some caller are not modified,
	    the following happens:
	    if the exchanged parameters have incompatible types, 
	    the compilation of the caller will fail; 
	    otherwise the code might even compile and produce
	    wrong results at runtime. 
	    There is no simple way to solve this issue in Java.
	    Using names in the call to the constructor in Nice is the solution.
	  </para>
	</footnote>. Because the names of the fields are used, they can be given
	in any order.
      </para>

      <para>
	If a behaviour different than that of the automatic constructor is 
	needed, it is possible to define
	a creation <link linkend="function">function</link> that can perform 
	the task, calling the constructor to create the object and 
	initialize the fields.
	This function should by convention be called <literal>create</literal>
	suffixed by the name of the class to create.
      </para>
    </section>

    <section><title>Parametric classes</title>
      <para>
        A powerful feature of Nice is the ability to define 
        <firstterm>parametric classes</firstterm>.
        Parametric classes are like templates in C++, or similar constructs in
        various functional languages. Programming with parametric classes is
        sometimes called <firstterm>generic programming</firstterm>.
      </para>      
      <para>
        A parametric (or parameterized) class is simply a class which has a 
        parameter. In this case the parameter is a <emphasis>type</emphasis>
        rather than a value. You can consider a parametric class as a family
        of related classes, all of which have the same behavior and structure
        except for the part that is parameterized. A common case where this
        is useful is in data structures.
      </para>
  <example><title>Simple Java Collection</title>
	<programlisting lang="java">
class Stack
{
  List contents = new LinkedList();
  void push(Object o) 
  {
    contents.add(o);
  }
  
  //... omitted methods

  public static void main(String[] args)
  {
    Stack st = new Stack();
    st.push("Test");
    Integer num = (Integer)st.pop(); // Runtime error
  }
}
</programlisting>
      </example>
      <para>
        There is a big type safety problem here.
        We pushed a String on to the stack, and then tried to pop it off into
        an Integer, resulting in an exception at runtime. Parametric classes
        can solve this problem.
      </para>
  <example><title>Simple Nice Collection</title>
	<programlisting lang="nice"><![CDATA[
class Stack<T>
{
  List<T> contents = new LinkedList();
  void push(T t) 
  {
    contents.add(t);
  }
  
  //... omitted methods

}

void main(String[] args)
{
  Stack<String> st = new Stack();
  st.push("Test");
  Integer num = st.pop(); // Compile time error!
}
]]></programlisting>
      </example>
      <para>
        In the Nice version, we've parameterized <classname>Stack</classname> by 
        a type <type>T</type>. Essentially, <classname>Stack&lt;T&gt;</classname> 
        is a recipe for the compiler that tells it how to create a Stack that 
        works for any given type. So now the compiler knows that we only mean 
        for Strings to go into our stack, and it reports an error when we
        write code that expects an Integer to come out of our 
        <classname>Stack&lt;String&gt;</classname>. 
      </para>
    </section>

    <section><title>Functions and methods</title>
      <para>
        Nice makes a simple distinction between functions and methods:
        Methods can be overridden and specialized, and functions cannot. A 
        function is just a reusable piece of code, much like a procedure
        in a language like Pascal or C, whereas a method may use different
        code depending on the types of its arguments, like methods in most
        object-oriented languages. We use the term <firstterm>functionals</firstterm>
        when we want to refer to both functions and methods without making
        a distinction.
      </para>
      <para>        
        Functions and methods in Nice have some important differences from
        other languages you may be used to - they are <firstterm>first class</firstterm>,
        which means they can be passed as arguments to other functionals, or
        used as return values from functionals.
      </para>
    </section>
  </chapter>

  <chapter id="function"><title>Functions</title>
    <section><title>Declaration</title>
      <para>
       Functions are declared like this:
      </para>

      <para>
       <literal>[type-parameters] return-type 
        function-name([parameters]) &LBRACE; body &RBRACE;</literal>
      </para>

      <para>
       Where <literal>[parameters]</literal> and 
       <literal>[type-parameters]</literal> are optional. There is a also
       a special case for functions whose body consists of a single expression:
      </para>

      <para>
       <literal>[type-parameters] return-type function-name([parameters]) 
        = expression;</literal>
      </para>

      
    </section>

    <section id="namedParameters"><title>Named parameters</title>
      <para>
	When <link linkend="call">calling</link> a function 
	(or a <link linkend="method">method</link>)
	it is possible to specify the name of a parameter, followed by
	<literal>:</literal> before the value given to that parameter.
	Named parameters can be given in any order.
	This is useful when writting the call, because one does not
	need to remember the order of the arguments, but only their names.
	When reading the code, it is much easier to understand
	what each parameter is, provided the name was well chosen.
	
	<example>
	  <title>Using named parameters</title>
	  <programlisting lang="nice">
void copy(File from, File to) { ... }
...
copy(from: f1, to: f2);
copy(to: f3, from: f4);</programlisting>
	</example>
	
	It is of course still possible to omit the names of the parameters,
	in which case the arguments must be given in the order of the 
	declaration.
      </para>
    </section>

    <section id="optionalParameters"><title>Optional parameters</title>
      <para>
	Many functions have some parameters that are used most of the time
	with the same value. In Nice, a parameter can be given a default
	value. It can then be omitted when calling the function and the
	default value is used. 

	<example>
	  <title>Using named and optional parameters</title>
	  <programlisting lang="nice">
void copy(File from, File to, int bufferSize = 1000) { ... }
...
copy(from: f1, to: f2); // with a buffer size of 1000
copy(from: f1, to: f2, bufferSize: 4000);</programlisting>
	</example>

	In the function definition, the optional parameters should be 
	listed after the required parameters. This is needed to allow 
	calls that do not name the arguments and want to use the default
	values for the optional parameters.
      </para>
      <para>
       Note that the optional values of parameters can be based on other
       parameters, for example:
      </para>
      <para>
       <literal> T[] slice(T[] array, int from = 0, 
       int to = array.length - 1);</literal>.
      </para>
    </section>
  </chapter>

  <chapter id="method"><title>Methods</title>
    <section><title>Declaring methods</title>
      <para>
        Method declaration takes the following form:
      </para>

      <para>
        <literal>[type-parameters] return-type 
        method-name([parameters]);</literal>
      </para>

      <para>
        The syntax is very similar to that for functions, but no body is 
        provided. Note that in Nice, methods can be defined within the
        body of a class definition, or outside of it - both are identical
        for the compiler's purposes.
      </para>
    </section>
    <section><title>Implementing methods</title>
      <para>
        In comparison to their declarations, method implementations are
        quite terse:
      </para>

      <para>
        method-name([arguments]) &LBRACE; body &RBRACE;
      </para>

      <para>Like functions, there is another form for single expressions:</para>

      <para>
        method-name([arguments]) = expression;
      </para>

      <para>
        The <literal>[arguments]</literal> consist of names, and optionally
        types, of the form
      </para>

      <para>
        <literal>name</literal>
      </para>

      <para>or</para>

      <para>
        <literal>name@type</literal>
      </para>

      <para>
        The <literal>@type</literal> is used to specialize the method on that 
        argument. An example should make the difference clear. Also note the
        use of both the block- and expression-style methods.
      </para>

      <example>
        <title>Method Implementation</title>
        <programlisting lang="nice">
class Vehicle {}
class Motorcycle extends Vehicle {}
class Car extends Vehicle {}

//Declare method
int numberOfWheels(Vehicle vehicle);

//Default implementation
numberOfWheels(vehicle) 
{
    throw new Exception("Unknown number of wheels!");
}

//Specialize for Cars
numberOfWheels(car@Car)
{ 
    return 4;
}

//Specialize for Motorcycles
numberOfWheels(mc@Motorcycle) = 2;

        </programlisting>
      </example>

      <para id="exactMatching">
       It is also possible to specialize a method on the 
       <emphasis>exact</emphasis> type of the argument. Then the method will
       apply to arguments which match the type exactly, and 
       <emphasis>not</emphasis> to an argument which is a subtype of the type
       specified. The syntax for exact matching is:
      </para>
      <para>
       name<literal>#</literal>type
      </para>
      <para>     
       When specializing a method with type parameters, it is not necessary 
       or possible to restate the type parameters in the method implementation. 
       However, if you need access to the type parameters as in the example
       below, use the syntax:
      </para>
      <para>
       <literal>method-name&LT;type-parameters&GT; (...) &LBRACE; body &RBRACE;
       </literal>
      </para>
      <example>
       <title>Using Type Parameters in Method Implementations</title>
       <programlisting lang="nice"><![CDATA[

//Method definition
<T> T lastItem(Collection<T> coll);


/*
This version won't compile because the T type isn't in scope:

lastItem(coll)
{
  Iterator<T> it = coll.iterator();
  //...
}
*/

/*
This one won't compile because Iterator needs a type argument:

lastItem(coll)
{
  Iterator it = coll.iterator();
  //...
}
*/

//This one will work correctly
lastItem<T>(coll)
{
  Iterator<T> = coll.iterator();
  //...
}
  
]]>
       </programlisting>
      </example>
        <para>
         Note that it is not possible to dispatch a method call on an array 
         type, nor to specialize a method on the subtype of a type parameter. 
         This means that methods of the form:
        </para>
        <para>
         <literal><![CDATA[foo(string@Collection<String>){}]]></literal>
        </para>
        <para>or</para>
        <para>
         <literal><![CDATA[foo(array@String[]){}]]></literal>
        </para>
        <para>
         are not valid. You should use respectively the specializers
	 <literal>@Collection</literal> and 
	 <literal>@Array</literal> instead.
        </para>        
       
    </section>
    <section><title>Optional parameters</title>
      <para>
	Methods, like functions, can have optional parameters.
	They are declared in the method declaration, using the
	<link linkend="optionalParameters">same syntax as in the case 
	  of functions</link>.
	Method implementations must still bind all parameters,
	including the optional ones, and can dispatch on them.
      </para>
    </section>
  </chapter>

  <chapter id="contracts"><title>Assertions and contracts</title>
    <section><title>Syntax</title>
      <para>
        The syntax for assertions is the same as in Java (since 1.4).
        Assertions are statements of the following form:
	<literal>assert &lt;boolean expression&gt; : &lt;error message&gt;</literal>.
        The &lt;error message&gt; is optional.
      </para>
      <para>
        Preconditions are introduced with the <literal>requires</literal>
	keyword, and postconditions with the <literal>ensures</literal>
	keyword. If there are several conditions in either section,
	they must be separated by commas. 
	For convenience, an optional trailing comma is accepted.
      </para>
      <para>
        In a method returning a value, the special variable name
	<literal>result</literal> can be used to refer to the result value
	of the method in the postcondition. 
	The <literal>old</literal> to refer to values before the 
	execution of the method is not supported yet.
      </para>
      <para>
	For example, we can define the contract of the add method
	of a <literal>Buffer</literal> interface.
	It is guaranteed that <literal>isEmpty</literal> returns true
	if, and only if, <literal>size</literal> returns <literal>0</literal>.
	The <literal>add</literal> method can be called only when the buffer
	is not full. It is guaranteed to make the buffer non-empty, and
	to increase the size by one.

	<example>
	<title>Contracts</title>
	<programlisting lang="nice"><![CDATA[
interface Buffer<Elem>
{
  int size();

  boolean isFull();
  boolean isEmpty() ensures result == (size() == 0);

  void add(Elem element)
    requires
         !isfull() : "not full"          // A comma here is optional
    ensures
         !isEmpty() : "not empty",       // Note the comma
         size() == old(size()) + 1 : "count inc";
}]]></programlisting>
      </example>
      
      </para>
    </section>

    <section><title>Enabling assertions and contract checking</title>
      <para>
        By default, assertions and contracts are not used at runtime.
	They are discarded by the just-in-time compiler, and should
	cause no slow-down.
	They can be turned on when starting the JVM.
      </para>

      <section><title>JDK 1.4 and later</title>
        <para>
	  The mechanism is the same as for Java assertions. 
	  Checking can be enabled at runtime with 
	  <literal>java -ea ...</literal>.
	</para>
      </section>

      <section><title>JDK 1.1, 1.2 and 1.3</title>
        <para>
          Contrarily to Java, Nice produces programs with assertions that can 
	  be run on earlier JDKs. Therefore there is no problem to distribute 
	  Nice programs using assertions anc contracts. Since java will not 
	  know the <literal>-ea</literal> command line option, they are 
	  disabled by default. You can enable them with 
	  <literal>java -Dassertions=true ...</literal>.
	</para>
      </section>
    </section>

  </chapter>

  <chapter><title>Statements</title>
    <section id="packageVars"><title>Package variables</title>
     <para>
      Since Nice uses <link linkend="packages">packages</link> as its largest
      conceptual unit, variable declarations may appear outside class
      definitions, and are useful in the same way that static variables in
      Java are. Here is the syntax:
     </para>
     <para>
      <literal>var</literal> type-name variable-name [= initializer]
      <literal>;</literal>
     </para>
    </section>
    <section id="localFunctions"><title>Local functions</title>
      <para>
	Local functions are similar to toplevel functions, 
        except that they are defined inside another function or method,
        and therefore only usable in that scope.
	They can refer to local variables from their context.
      </para>

      <example><title>Local function</title>
	<programlisting lang="nice">
Window createMyWindow()
{
  Window w = new Window();
  
  void addMyButton(String text)
  {
    w.addButton(new Button(text));
  }

  addMyButton("One");
  addMyButton("Two");
  addMyButton("Three");
}</programlisting>
      </example>

    </section>

  </chapter>

  <chapter><title>Expressions</title>
    <section id="call"><title>Function calls</title>
      <para>
        A call is usually of the form <literal>f(e1, ..., en)</literal>.
	<literal>f</literal> can be a function name, a method name, or
	more generally any expression which has a functional type
	(for instance, a local parameter).
	<literal>e1, ..., en</literal> is the list of arguments to the 
	function. Arguments can optionally be 
	<link linkend="namedParameters">named</link>.
      </para>

      <para>
        In many object-oriented languages, methods are called with the
	syntax <literal>e1.f(e2, ..., en)</literal>. This syntax is also 
	accepted in Nice, and is completely equivalent to the previous one.
	In particular, <literal>e.f</literal> can be used to retrieve the value
	of the field <literal>f</literal> in the object <literal>e</literal>
	<footnote>
	  <para>
	    A consequence of these rules is that if the field 
	    <literal>f</literal> contains a function, it must be called with
	    <literal>(e.f)(e1, ..., en)</literal>.
	  </para>
	</footnote>.
      </para>

      <para>
        It is possible that a name refers to several unrelated functions.
	In that case, the types (and if applicable names)
	of the arguments are used to try to disambiguate which function
	must be called. If only one function is applicable, it is called.
	Moreoever, if several functions are applicable, but one has a more
	restricted domain than all the others, it is chosen
	<footnote>
	  <para>
	    For instance, suppose two functions 
	    <literal><![CDATA[<T> void foo(Collection<T>)]]></literal> and 
	    <literal><![CDATA[<T> void foo(List<T>)]]></literal> are declared, 
	    and <literal>aList</literal> is an expression of static type 
	    <literal>List</literal>.
	    The expression <literal>foo(aList)</literal> will result in
	    calling the second <literal>foo</literal> function, 
	    because <literal>List</literal>
	    is a subclass of <literal>Collection</literal>.
	  </para>
	</footnote>.
	Otherwise, the compiler reports an ambiguity error.
      </para>
    </section>

    <section><title>Tuples</title>
      <para>
       A tuple is a groupment of several values in a single expression.
       For instance, <literal>("Hello", 2*3, x.toString())</literal> 
       is a tuple whose elements are the string <literal>"Hello"</literal>,
       the number <literal>6</literal> and the string representation of 
       <literal>x</literal>. 
       The type of a tuple is a <emphasis>tuple type</emphasis>, 
       whose elements are the types of the corresponding values.
       The type of our example tuple is 
       <literal>(String, int, String)</literal>. 
      </para>

      <para>
       A tuple can be of any length. In english, a tuple of two elements
       is called a couple. For an arbitrary number n, a tuple of n
       elements is called a n-tuple.
      </para>

      <para>
       Tuple types are covariant, so a couple of <literal>int</literal>s 
       can be used where a couple of <literal>long</literal>s is expected.
      </para>

      <para>
       A funny feature is that swapping two variables can be done without a 
       temporary variable, using tuples: <literal>(x, y) = (y, x)</literal>.
       An important use of tuples is to allow a function or a method 
       to return several values. <xref linkend="tupleEx" /> defines
       and uses the function <literal>minMax</literal>, which takes 
       two integers, and returns the smallest first, the biggest second.
      </para>

      <example id="tupleEx">
	<title>Function returning several values using a tuple</title>
	<programlisting lang="nice"><![CDATA[
(int, int) minMax(int x, int y) = x < y ? (x, y) : (y, x);

void printTuple((int, int) tuple)
{
  /** Declare two local variables, and assign to each the corresponding value
      in the tuple.
  */
  (int x, int y) = tuple;

  println("(" + x + ", " + y + ")");
}

void main(String[] args)
{
  printTuple(minMax(14, 17));
  printTuple(minMax(42, 41));
}
}]]></programlisting>
      </example>

    </section>

    <section id="anonymousFunctions"><title>Anonymous functions</title>
      <para>
       Since Nice allows functions and methods to be passed as arguments, and
       returned as results, it is convenient to allow small anonymous functions
       to be defined at the same point in the program in which they are used,
       similar to the use of anonymous classes in Java.       
      </para>
      <para>
       The syntax of anonymous functions is:
      </para>
      <para>
       ([parameters]) <literal>=></literal> &LBRACE; body &RBRACE;
      </para>
      <para>
       As with the other functionals, there is also a single-expression format:
      </para>
      <para>
       ([parameters]) <literal>=></literal> expression
      </para>
      <para>
       The brackets around the parameters are optional if there is only one
       parameter.
      </para>
      <para>
       The return type of an anonymous function is automatically determined by 
       the compiler using a process called 
       <firstterm>type inference</firstterm>, so it is not necessary or possible
       to specify it.
      </para>
<example>
<title>Using Anonymous Functions</title>
<programlisting lang="nice"><![CDATA[
String concat(Collection<String> strings) 
{
    StringBuffer buff = new StringBuffer();
    strings.foreach(String s =>  {
        buff.append(s);
    });
    return buff.toString()
}

var String[] numberStrings = [1,2,3,4,5].map(int num => String.valueOf(num));

//Another way of defining "concat"
String concat2(Collection<String> strings)
{
  return strings.foldLeft((String accum, String s) => accum + s, "");
}


]]></programlisting>
</example>
    </section>

    <section id="conversion"><title>Conversion between primitive types</title>
      <para>
	The primitive types are, from the largest to the smallest:
	<literal>double, float, long, int, short, byte</literal>, 
	and <literal>char</literal> which is smaller than 
	<literal>int</literal> but incomparable with <literal>short</literal>.
	Conversion from a smaller to a larger type is automatic.
	Conversion from a larger to a smaller type must be done explicitely,
	since they can lose information about the magnitude of the value.
      </para>
      <para>
	The explicit conversion is done by calling a special function, 
	whose name is the target type. For instance, here is code to read
	characters from a <literal>Reader</literal>, whose 
	<literal>read</literal> method returns an <literal>int</literal> 
	(<literal>-1</literal> meaning that the end of stream has been 
	reached):

	<example><title>Converting a value of a primitive type</title>
	<programlisting lang="nice">
BufferedReader r = new BufferedReader(new InputStreamReader(System.in));

int v;
while ((v = r.read()) != -1) {
  char c = char(v);
  ... // Do something with the character.
}</programlisting>
      </example>

      </para>
    </section>
  </chapter>

  <chapter><title>Interfacing with Java</title>
    <section><title>Using Java from Nice</title>
      <para>
        The Java libraries are automatically imported as necessary. 
	Therefore it is straightforward	to use existing Java code
	in Nice programs.
      </para>

      <para>
	This section lists advanced features related to the use of Java code
	in Nice.
      </para>

      <section id="importJava"><title>Importing packages</title>
	<para>
	  When Java classes of some package are used frequently,
	  it is possible to make the package part of their name implicit.
	  For instance, after a declaration
	  <literal>import java.io.*;</literal> it is possible
	  to refer to class <literal>java.io.File</literal>
	  with the short name <literal>File</literal>. It is not possible to 
          import only a single name, such as 
          <literal>import java.io.File;</literal>, you must import the whole
          package.
	</para>

	<para>
	  Classes defined in the current package always have priority
	  over imported packages. If a short name is used that refers
	  to two classes from imported packages, the compiler
	  will report an ambiguity, and the fully qualified name must be used.
	</para>
      </section>

      <section id="optionTypesJava"><title>Option types</title>
	<para>
	  Nice's advanced type system makes the distinction between normal 
	  (e.g. <literal>String</literal>) and option
	  (e.g. <literal>?String</literal>) types, which allows to 
	  prevent <literal>NullPointerExceptions</literal>
	  (see <link linkend="optionTypes">option types</link>).
	  This poses a problem when using 
	  existing Java libraries. If my Nice program calls a Java function
	  that returns a <literal>String</literal> (the Java type), 
	  does it mean <literal>String</literal> or 
	  <literal>?String</literal> in Nice? 
	  Since Java allows the value to be <literal>null</literal>, 
	  the Nice compiler 
	  currently suposes it's <literal>?String</literal> (it can only be 
	  sure about primitive types like <literal>int</literal>).
	</para>

	<programlisting lang="java">
// Java code
public class MyJavaClass {
  public String getName() {
    return "foo";
  }
}	</programlisting>

	<para>
          In Nice, if <literal>myJavaClass</literal> is a variable of type 
	  <literal>MyJavaClass</literal>, then 
	  <literal>myJavaClass.getName()</literal> has type 
	  <literal>?String</literal>.
	</para>

	<para>
	  If the Java code might indeed return <literal>null</literal>, 
	  or you are not sure, this is all good. To use the value you will 
	  have to test it against <literal>null</literal>. However there are 
	  many cases where you know the value cannot be 
	  <literal>null</literal>, for instance if this fact is specified in 
	  the Javadoc comment of the method. In that cases there are currently 
	  two possibilities. The first is to use the <literal>notNull</literal>
	  function. It tells the compiler that you know the value is not 
	  <literal>null</literal>. At runtime, it will throw a 
	  <literal>NullPointerException</literal> if this was not the case. 
	  So in our example <literal>notNull(myJavaClass.getName())</literal>
	  has type <literal>String</literal>. This solution is simple, but can 
	  be annoying if you call the same method many times, or because it 
	  makes your code less readable.
	</para>

	<para>
	  The second solution is to tell once and for all the compiler the 
	  precise type of the method (this is also useful for methods with 
	  parametric types):
	</para>

	<programlisting lang="nice">
String getName(MyJavaClass) = native String MyJavaClass.getName();</programlisting>

	<para>
          The Nice part (on the left of the <literal>=</literal> character) 
	  is the header of a function definition. Note that return type is 
	  <literal>String</literal> (without the optional type marker 
	  <literal>?</literal>). On the other hand, the right part says that 
	  the function is already defined in class 
	  <literal>MyJavaClass</literal>, with name <literal>getName</literal>,
	  the one that takes no argument and returns a 
	  <literal>String</literal>. With this declaration, 
	  <literal>myJavaClass.getName()</literal> has type 
	  <literal>String</literal>.
	</para>
      </section>
    </section>

    <section><title>Using Nice from Java</title>
      <para>
        It is possible to use libraries developed in Nice in a 
	Java program.
	Before anything, make sure that the classes generated by nicec
	can be found on your classpath when you compile the Java program
	with javac.
      </para>

      <section><title>Calling a function</title>
	<para>
	  You can call a <link linkend="function">function</link> 
	  <literal>f</literal>
	  defined in a nice package <literal>pkg</literal> 
	  by naming it <literal>pkg.fun.f</literal> in the Java program.
	</para>
      </section>

      <section><title>Calling a method</title>
	<para>
	  You can call a <link linkend="method">method</link>
	   <literal>m</literal>
	  defined in a nice package <literal>pkg</literal> 
	  by naming it <literal>pkg.dispatch.m</literal> in the Java program.
	  It does not matter in what package(s) <literal>m</literal> 
	  is implemented: 
	  <literal>pkg</literal> must simply be the package where the method 
	  was declared.
	</para>
      </section>

      <section id="constructorFromJava"><title>Calling a constructor</title>
	<para>
	To instantiate in Java a class defined in Nice, do as usual:
	call its constructor, using the <literal>new</literal> keyword.
	Nice classes have one <link linkend="constructor">automatically 
	generated constructor</link>, 
	with one parameter for each field of the class, 
	including those inherited from Nice super-classes.
	</para>
      </section>

      <section><title>Complete example</title>
      <para>
      <example><title>Using Nice from Java</title>
	<para>
	Let's see an example that illustrates all these features.
	Suppose your Nice library looks like this:
	<programlisting lang="nice">
package my.nice.pkg;

class Person
{
  String name;

  // A method:
  String display();
  display() = "Person: " + name;
}

class Worker extends Person
{
  int salary;

  display() = "Worker: " + name + " salary: " + salary;

  // A function:
  boolean isRich() = salary > 500;
}

	</programlisting>

	Then your Java program can create new persons and workers:
	<programlisting lang="java">
package main.java.pkg;

import my.nice.pkg.*;

public class Main
{
  public static void main(String[] args)
  {
    Person p = new Person("John");
    Worker w = new Worker("Julia", 1000);

    println(my.nice.pkg.dispatch.display(p));
    println(my.nice.pkg.dispatch.display(w));
    if (my.nice.pkg.fun.isRich(w))
      println("A well paid worker!");
  }
}
        </programlisting>
	</para>
      </example>
      </para></section>

      <section><title>Optional parameters</title>
	<para>
	  Nice allows function and method parameters to be 
	  <link linkend="optionalParameters">optional</link>.
	  Since this feature is not available in Java, you have to 
	  provide the value of all parameters, regardless of their
	  optionality.
	  The same applies for class fields with initializers:
	  they are ignored in the Java program, and must be given a value
	  in the call to the constructor.
        </para>
      </section>

      <section><title>Other aspects</title>
	<para>
	Fields of Nice classes are accessed normally from Java programs.
	It is possible to declare a Java subclass of a Java class.
	The constructor will need to call the 
	<link linkend="constructorFromJava">parent constructor</link>.
	It is not possible to override a Nice multi-methods in a Java
	program.
	</para>
      </section>

    </section>
  </chapter>

  <chapter><title>Types</title>
    <para>
    </para>

    <section id="optionTypes"><title>Option types</title>
      <para>
        Nice (unlike Java) makes a distinction between a type that may be &NULL;, 
        and one that may not be. So, if you want to allow &NULL; 
        <classname>String</classname>s, you write <classname>?String</classname> 
        for the type. If &NULL;s should not be allowed, you just write 
        <classname>String</classname>. It is not possible to pass a 
        <classname>?String</classname> where a <classname>String</classname> is 
        expected, unless the compiler can prove it's not &NULL;. The easiest way
        to prove that the variable is not &NULL; is to use an 
        <literal>if</literal> statement:
      </para>

<example>
  <title>Using option types</title>
<programlisting lang="nice">
	void foo(String arg) {...}
	
	void bar(?String arg) {
		if (arg != null) {
			//Here Nice knows arg is not null, so it can 
			// be passed to a method which takes a String!
			foo(arg);	
		} 
		foo(arg); //Here arg may or may not be null, 
			  //so Nice gives a compile error.
	}
</programlisting>
</example>
      <para>
        Therefore, you never have to check that all your arguments 
        aren't &NULL; again, unless you actually want to allow &NULL;s.
      </para>
      <para>
        Two useful functions for dealing with nulls are 
        <literal>notNull</literal> and <literal>cast</literal>. The
        <literal>notNull</literal> function is described above in the
        <link linkend="optionTypesJava">section on option types and Java
        code</link>. The <literal>cast</literal> function is used in those
        (rare) situations where it is necessary to allow a null where one
        shouldn't normally go, for instance if you need to declare a
        variable before entering a loop, but don't have a value to initialize
        it with. These situations are rare, and are usually the result of
        thinking about the problem in a Java way rather than a Nice way,
        but sometimes <literal>cast</literal> is the only way.
      </para>

      <para>
        For more details, see 
	<ulink url="http://nice.sourceforge.net/cgi-bin/twiki/view/Doc/OptionType">
	the Wiki page about option types</ulink>.
      </para>

      <para>
       There is related type, which is prefixed with an exclamation point
       (<literal>!</literal>). This is used to specify a non-&NULL; type
       when it is not known if the original type allowed &NULL; or not. This
       generally happens with parameterized types, for instance the type
      </para>
      <para>
       <type><![CDATA[<T> T myFunction(Collection<T>)]]></type>
      </para>
      <para>
       can be
       instantiated at <emphasis>any</emphasis> type, including option types
       like <type>?String</type>. If it is necessary to exclude option types
       from the domain of T, the type is specified this way:
      </para>
      <para>
       <type><![CDATA[<!T> !T myFunction(Collection<!T>)]]></type>.
      </para>
      </section>
      <section id = "typeParameters"><title>Type Parameters</title>
        <para>
          Classes, functions, and methods can all be parameterized with type
          variables in Nice as is demonstrated in each of their respective
          chapters. In addition to the ability to introduce type variables,
          Nice provides the ability to constrain those types in certain ways.
          <link linkend="optionTypes">Option types</link> are one such constraint.
        </para>
        <para>
          Simple type parameters of the form
        </para>
        <para>
          <type>&LT;type-variable[, type-variable...]&GT;</type>
        </para>
        <para>
          are commonly encountered in Nice, but are a simplified form of a more
          general syntax. <type>&lt;T&gt;</type> is actually shorthand for
          <type>&lt;Any T&gt;</type>, which says that <type>T</type> may be any 
          type at all. It is possible to constrain <type>T</type> so that it 
          must be a subtype of some other type. This example shows that
          <literal>filter</literal> may be implemented for any type 
          <type>T</type>, but <type>C</type> must be a subclass of Collection.
        </para>
        <para>
          <literal>
<![CDATA[<Collection C, Any T> C<T> filter(C<T>, T->boolean);]]>
          </literal>
        </para>
        <para>
          It's also possible to enforce some relation among the type parameters,
          such that one must be a subtype of the other, as in this example from
          the standard library, which can be read as "Any T and U, so long as U
          is a subtype of T".
        </para>
        <para>
          <literal>
<![CDATA[<Any T, Any U | U <: T> U[] fill(T[] array, int->U value)]]>
          </literal>
        </para>
        <para>
         Note the notation <literal>&lt;T | T &lt;: SomeType &gt;</literal> means the
         same thing as <literal>&lt;SomeType T&gt;</literal>.
        </para>
        <para>
          There is also a notation for the same class as the declaring class
	  of a method: <type>alike</type>.
	  For instance, the following class <literal>Foo</literal> declares
	   a method <literal>copy</literal>, such that 
	   <literal>x.copy()</literal>
	  has the same type as <literal>x</literal>, <literal>x</literal> 
	  being of any subclass of <literal>Foo</literal>.
        </para>
        <para>
	<example><title>A copy method with an exact type</title>
	<programlisting lang="nice">
class Foo
{
  String value;

  alike copy();
}

copy(f#Foo) = new Foo(value: f.value);

class Bar extends Foo
{
  int id;
}

copy(b@Bar) = new Bar(value: b.value, id: generateNewId());
}</programlisting>
        </example>
	</para>
        <para>
          Note that <link linkend="exactMatching">exact matching</link>
	  is required to implement the
	  <literal>copy</literal> method.
        </para>
      </section>
 <!--
      <section id = "abstractInterfaces">
        <title>Abstract Interfaces</title>
        <para>
          TODO: Link to Daniel's paper, explain.
        </para>
      </section>      
 -->

  </chapter>
  

</book>

<!--
  Local Variables:
  sgml-validate-command: "xmllint -noout -valid"
  End:
 -->
