/**************************************************************************/
/*                                N I C E                                 */
/*             A high-level object-oriented research language             */
/*                        (c) Daniel Bonniot 2004                         */
/*                                                                        */
/*  This program is free software; you can redistribute it and/or modify  */
/*  it under the terms of the GNU General Public License as published by  */
/*  the Free Software Foundation; either version 2 of the License, or     */
/*  (at your option) any later version.                                   */
/*                                                                        */
/**************************************************************************/

package nice.tools.doc;

/**
 * The comment class is an abstraction of a comment block.  It contains an
 * instance variable <i>tags</i> contains an ArrayList of tuples that map tag
 * strings to values.  The value <b>null</b> maps to the general comment.
 * The constructor of this class should be used put a comment block in 
 * <i>commentStr</i> (the default value is the empty string.
 * @author Francis Barber
 */
class Comment {
    //a list of tuples that maps tags, such as @param, to values
    //this value is initialised by the custom constructor
    List<(?String,String)> tags = cast(null);
    String commentStr = "";
    
    /*Initialisation*/
    {
        tags = parse(commentStr);
    }
}

/**
 * Parses a comment block and returns an ArrayList containing tuples that map
 * tag string (such as @param) to values.  The value <b>null</b> is used as the
 * parameter for the general comment heading the block.
 * @param a comment block beginning with &#47;&#42;&#42; and ending with &#42;&#47;
 * @return a list of tuples mapping tags to values.
 */
List<(?String,String)> parse(String comments) {
    //an initial capacity of 8 is used becuase I don't expect many values
    //ArrayList<(?String,String)> list = new ArrayList(8);
    
    StringBuffer buf = new StringBuffer(comments);
    //the first and last chars should be '/'
    if(buf.charAt(0) == '/' && buf.charAt(buf.length() - 1) == '/') {
        buf.deleteCharAt(0);
        buf.deleteCharAt(buf.length()-1);
    }
    //else this is a problem - do something
    for(int i = 0; i < buf.length; /*no increment*/) {
        if(buf.charAt(i) == '*' && (i == 0 || buf.charAt(i-1) == '\n')) {
            buf.deleteCharAt(i);
        }
        else {
            i++;
        }
    }
    for(int i = 0; i < buf.length; i++) {
        if(buf.charAt(i) == '\n') {
            buf.replace(i, i+1, " ");
        }
    }
    StringTokenizer st = new StringTokenizer(buf.toString(), "@", true /*return delimiters*/);
    boolean isParam = false;
    ?Node root = null;
    for(int i = 0; st.hasMoreTokens(); i++) {
        //println("\"Token " i ": " st.nextToken().trim() "\"");
        String token = st.nextToken().trim();
        if(token.equals("@")) {
            //the next token will be a param string
            isParam = true;
        }
        else if(isParam) {
            /*this token will have the form "<param name> <comment string>"
             *extract the param name and insert it as the key.  add the rest as a comment
             */
            int index = token.indexOf(' ');
            //list.add(("@" token.substring(0, index), token.substring(index+1)));
            if(root == null)
                root = new Node(value: ("@" token.substring(0, index), token.substring(index+1)));
            else
                root.insert(new Node(value: ("@" token.substring(0, index), token.substring(index+1))));
            isParam = false;
        }
        else {
            //this is a general comment
            //list.add((null, token));
            if(root == null)
                root = new Node(value: (null, token));
            else
                root.insert(new Node(value: (null, token)));
        }
    }
    return toList(root);
}

class Node {
    (?String,String) value;
    ?Node left = null;
    ?Node right = null;
}

List<(?String,String)> toList(?Node root) {
    if(root != null) {
        //get the result of the left branch
        List<(?String,String)> l = toList(root.left);
        //add ourselves
        l.add(root.value);
        //add the right branch
        l.addAll(toList(root.right));
        return l;
    }
    else {
        return new LinkedList();
    }
}

void insert(Node root, Node node) {
    if(compare(node.value, root.value) < 0) {
        //node is less than current
        if(root.left != null)
            insert(notNull(root.left), node);
        else
            root.left = node;
    } else {
        //node is greater than or equal to current
        if(root.right != null)
            insert(notNull(root.right), node);
        else
            root.right = node;
    }
}

/*This method needs to actually sort in a sensible order.*/
int compare((?String,String) t1, (?String,String) t2) {
    (?String s1, String r1) = t1;
    (?String s2, String r2) = t2;
    if(s1 == null) {
        if(s2 == null)
            return 0;
        else
            return 1;
    }
    else if(s2 == null)
        return -1;
    else
        return s1.compareTo(s2);
}