
package bossa.syntax;

import java.util.List;
/*
  This file is only useful to bootstrap the compiler,
  since bossa.syntax is implemented both in Java and Nice,
  while we need mutual recursion between the two.

  This class must have the interface of the Nice part of the package.
*/

public class dispatch
{
  public static bossa.link.Alternative createSourceAlternative(MethodImplementation implementation)
  { return null; }

  static String getAlikeID()
  { return null; }

  public static Monotype createTypeIdent(LocatedString name)
  { return null;}

  public static Definition createMethodWithDefault(LocatedString name, Constraint constraint, Monotype returnType, FormalParameters parameters, Statement body, Contract contract, boolean isOverride)
  { return null; }

  static Monotype createMonotypeConstructor(mlsub.typing.TypeConstructor tc, TypeParameters parameters, bossa.util.Location loc)
  { return null; }

  public static Expression createIdentExp(LocatedString i)
  { return null; }

  public static Expression createSymbolExp(VarSymbol symbol, bossa.util.Location loc)
  { return null; }

  public static Expression createCallExp(Expression function, Expression param1)
  { return null; }

  public static Expression createCallExp(Expression function, Expression param1, Expression param2)
  { return null; }

  public static VarSymbol createMethodSymbol(MethodDeclaration declaration, LocatedString name, Constraint constraint, Monotype returnType)
  { return null; }
  
  public static VarSymbol createMethodSymbol(MethodDeclaration declaration, LocatedString name, mlsub.typing.Polytype type)
  { return null; }

  public static VarSymbol createConstructorCallSymbol(MethodDeclaration declaration, LocatedString name, mlsub.typing.Polytype type)
  { return null; }

  public static gnu.bytecode.Method getImplementationAbove(JavaMethod decl, gnu.bytecode.ClassType firstArg)
  { return null; }

  static Pattern resolveGlobalConstants(Pattern pattern)
  { return null; }

  public static Pattern readPattern(String rep, int[] pos)
  { return null; }

  public static Pattern createPattern(LocatedString name)
  { return null; }

  public static Pattern createPattern(LocatedString name, mlsub.typing.TypeConstructor tc, boolean sure)
  { return null; }

  public static boolean leq(Pattern a, Pattern b)
  { return false; }

  public static boolean disjoint(Pattern a, Pattern b)
  { return false; }
  
  static Statement analyseMethodBody(Statement s, VarScope varScope, TypeScope typeScope, MonoSymbol[] params, boolean mustReturnAValue)
  { return null; }
  
  static Expression analyse(Expression e, VarScope v, TypeScope t) 
  { return null; }

  static Expression analyse(Expression e, Info i) 
  { return null; }

  static void typecheck(Statement s) {}
  static void typecheck(Expression e) {}

  public static void resetTypeDefinitionMappings() {}

  public static TypeDefinition getTypeDefinition(mlsub.typing.TypeConstructor tc)
  { return null; }
  
  public static mlsub.typing.Monotype getTypeWithTC(mlsub.typing.TypeConstructor tc)
  { return null; }
  
  public static mlsub.typing.Monotype getTypeWithTC(mlsub.typing.TypeConstructor tc, mlsub.typing.Monotype[] sourceParams )
  { return null; }

  public static AST createAST(Module module, List defs)
  { return null; }

  static bossa.util.UserError unknownIdent(LocatedString ident)
  {
    return null;
  }

  public static void _printStackTraceWithSourceInfo(Throwable t) {}
}

class Info {}
