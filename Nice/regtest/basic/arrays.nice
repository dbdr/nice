package regtest.basic;

// native arrays
// Array<T> and T[] are synonyms


<Any T> void p(Array<T>);
p(a)
{
  print("size = " + a.length + ", elements = ");
  for(int i = 0; i<a.length; i++)
    print(""+ a[i] + " ");
  println("");
}

<Any T> Array<T> reverse(Array<T>);
reverse<T>(a)
{
  T[] res = new T[a.length];
  for (int i=0; i<a.length; i++)
    res[i] = a[a.length - i - 1];
  return res;
}

void test_arrays();
test_arrays()
{
  println("\n### Testing native arrays ###\n");

  int[] a = test_native_arrays();
  p(a);
  p(reverse(a));
  test_collection_arrays(a);
  test_polymorphism();
}


int[] test_native_arrays();
test_native_arrays()
{
  int[] aI = new int[10];
  aI[0] = 0;
  for(int i=1; i<aI.length; i++)
    aI[i] = aI[i-1]+1;

  long[] aL = new long[10];
  aL[0] = 0L;
  for(int i=1; i<aL.length; i++)
    aL[i] = aL[i-1]+1;

  float[] aF = new float[10];
  aF[0] = 2;
  for(int i=1; i<aF.length; i++)
    aF[i] = aF[i-1]*1.5;

  double[] aD = new double[10];
  aD[0] = 2;
  for(int i=1; i<aD.length; i++)
    aD[i] = aD[i-1]*1.5;

  char[] aC = new char[10];
  aC[0] = 'A';
  for(int i=1; i<aC.length; i++)
    aC[i] = aC[i-1];

  short[] aS = new short[10];
  aS[0] = 0;
  for(int i=1; i<aS.length; i++)
    aS[i] = aS[i-1];

  byte[] aB = new byte[10];
  aB[0] = 0;
  for(int i=1; i<aB.length; i++)
    aB[i] = aB[i-1];

  boolean[] aZ = new boolean[10];
  aZ[0] = true;
  for(int i=1; i<aZ.length; i++)
    aZ[i] = !aZ[i-1];

  return aI;
}

// using collection functions on arrays
void test_collection_arrays(int[] a);
test_collection_arrays(a) 
{
  println(a.size());
  int[] b = map(a, fun(int i) => i+4);
  p(b);
  p(filter(reverse(b), fun(int i)=> i>6));

  long[] ls = map(a, id);
  ls[0] = Long.MAX_VALUE;
  p(ls);

  byte[] bs = new byte[1];
  bs = map(bs, id);
  bs[0] = 127;
  short[] shs = map(bs, id);
  shs[0] = 129;
  char[] cs = new char[1];
  cs[0] = 'A';
  double[] ds = map(cs, id);
  p(ds);

  // idem with non primitive arrays
  ?String[] ss = new String[5];
  ss[2] = "e2"; ss[4] = "e4";
  p(ss);
  ?String[] ss2 = filter(ss, fun(?String s)=>s!=null);
  p(ss2);
  p(map(ss2, fun(?String s)=>{ String str = notNull(s); return str + str; }));

  // using an array that is the field of an object
  Fields f = new Fields();
  notNull(f.strings).iter(fun(?String s)=>println(s));

  Collection<?String> c = ss;
  println(c.size());

  // multidimentional arrays
  {
    int N = 4;
    int[][] aa = new int[N][N];
    for (int i=0; i<N; i++)
      {
	for (int j=0; j<N; j++)
	  {
	    aa[i][j] = i*2+j;
	    print("" + aa[i][j] + " ");
	  }
	println("");
      }
  }

  // Literal arrays
  String[] ts = [ "A", "B" ];
  ts.iter(fun(String s)=>println(s));

  float[] tf = [ 1.5, 2, 3.7 ];
  tf.iter(fun(float f)=>println(f+1));
}

// We test how functions on polymorphic arrays deal with native type components
<Any T> T getFirst(T[] a) = a[0];

void test_polymorphism()
{
  // polymorphic array field
  Vector<String> v = makeVector(1);
  String[] elements = v.elements;
  v.elements.size();

  // Test that different array creation code is generated
  // according to the context
  byte[] b   = [ 14, 17 ];
  short[] s  = [ 14, 17 ];
  int[] i    = [ 14, 17 ];
  long[] l   = [ 14, 17 ];
  float[] f  = [ 14, 17 ];
  double[] d = [ 14, 17 ];
  String[] S = [ "Quatorze", "Dix-sept" ];

  byte bb   = getFirst(b);
  short ss  = getFirst(s);
  int ii    = getFirst(i);
  long ll   = getFirst(l);
  float ff  = getFirst(f);
  double dd = getFirst(d);
  String SS = getFirst(S);

  int[][] ddim = new int[1][1];
  int iii = getFirst(getFirst(ddim));

  println("Polymorphic arrays: " + bb + ss + ii + ll + ff + dd + SS + iii);
}

// Using array -> Collection implicit conversion in the returned value
<Any T> Collection<T> wrap(T x) = [ x ];

