/**************************************************************************/
/*                           B O S S A                                    */
/*        A simple imperative object-oriented research language           */
/*                   (c)  Daniel Bonniot 1999                             */
/*                                                                        */
/*  This program is free software; you can redistribute it and/or modify  */
/*  it under the terms of the GNU General Public License as published by  */
/*  the Free Software Foundation; either version 2 of the License, or     */
/*  (at your option) any later version.                                   */
/*                                                                        */
/**************************************************************************/

// File    : stdlib.bossa
// Created : Thu Jul 08 16:20:19 1999 by bonniot
//$Modified: Mon Oct 25 14:27:21 1999 by bonniot $
// Description : Prolog file, included before all bossa file

variable <Any T> T null;

final class void {}

// Booleans
class Boolean {}
class True  extends Boolean {}
class False extends Boolean {}

variable True  true =new True();
variable False false=new False();

Boolean not(Boolean);
not(b@True)  = false;
not(b@False) = true;

Boolean and(Boolean,Boolean);
and(b1@True,b2@True) = true;
and(b1,b2)           = false;

Boolean or(Boolean,Boolean);
and(b1@False,b2@False) = false;
and(b1,b2)             = true;

// builtin control structures
// "if(cond) t else e endif" 
// is rewritten *by the parser* into asbtract syntax for 
// "_if(cond,fun()=>{return t;},fun()=>{return e;})"
T _if <Any T> (Boolean,fun()(T),fun()(T));

_if(cond@True,t,e) = t();

_if(cond@False,t,e) = e();

void _while(fun()(Boolean),fun()());
_while(test,body)
{
  if(not(test()))
    return;
  body();
  _while(test,body);
}

// Clone
//interface Cloneable;

//T clone{Cloneable T}(T);

//Comparable
//It is a type class !
interface Comparable;

Boolean equals</*Comparable*/ Any T>(T,T);

// Numeric
interface Num extends Comparable;
N add <Num N> (N,N);
T sub <Num T> (T,T);

interface Ordinal;
T succ <Ordinal T> (T);

class Float implements Num {}
class Integer extends Float 
  abstracts Num 
  abstracts Ordinal 
{}

add(x@Integer,y@Integer)
{ return new Integer(); }

add(x#Float,y#Float)
{ return new Integer(); }

succ(x@Integer) = x+1;

Boolean lt(Integer, Integer); // strict (<)
Boolean leq(Integer, Integer);// non-strict (<=)

// Strings and characters
class Char {}

class String implements Comparable {}

Char get(String,Integer);
Integer length(String);
String concat(String,String);

// Builtin class Array
class Array<T>{}

T 
get<Any T>(Array<T>, Integer);

void 
set<Any T>(Array<T>, Integer, T);

Integer
capacity<Any T>(Array<T>);

void
resize<Any R>(Array<R>, Integer);

// List
interface Container<T>;
interface List<T> extends Container;

list<B> map <Any A, Any B, List list>(fun(A)(B),list<A>);
T fold_left <Any T, Any U, List list>(fun(T,U)(T),T,list<U>);
U fold_right<Any T, Any U, List list>(fun(T,U)(U),list<T>);

// Main function, called with command line arguments in an array
Integer main(Array<String>);
