/**************************************************************************/
/*                                N I C E                                 */
/*             A high-level object-oriented research language             */
/*                        (c) Daniel Bonniot 2001                         */
/*                                                                        */
/*  This program is free software; you can redistribute it and/or modify  */
/*  it under the terms of the GNU General Public License as published by  */
/*  the Free Software Foundation; either version 2 of the License, or     */
/*  (at your option) any later version.                                   */
/*                                                                        */
/**************************************************************************/

package bossa.syntax;

/**
   Helper functions.

   @version $Date$
   @author Daniel Bonniot (bonniot@users.sourceforge.net)
 */

?LocatedString identString(?Expression);
identString(e) = null;
identString(IdentExp e) = e.ident;
identString(SymbolExp e) = e.getName();
identString(OverloadedSymbolExp e) = e.ident;

boolean isCallTo(CallExp e, String name) 
{
  ?LocatedString f = identString(e.function);
  if (f == null)
    return false;
  else
    return f.toString().equals(name);
}

?MonoSymbol localVariable(Expression);
localVariable(Expression e) = null;
localVariable(SymbolExp e)
{
  let sym = e.getSymbol();
  if (sym instanceof bossa.syntax.MonoSymbol) {
    //don't allow nullness inference on global variables.
    if (sym instanceof GlobalVarDeclaration.GlobalVarSymbol &&
		sym.isAssignable())
      return null;

    // no type inference on captured variables
    if (sym.captured)
      return null;

    return sym;
  }
  return null;
}
localVariable(AssignExp e) = localVariable(notNull(e.to));

mlsub.typing.Monotype makeSure(mlsub.typing.Monotype m) = 
  notNull(bossa.syntax.Monotype.sure(nice.tools.typing.Types.rawType(m)));

mlsub.typing.Monotype makeUnsure(mlsub.typing.Monotype m) = 
  notNull(bossa.syntax.Monotype.maybe(nice.tools.typing.Types.rawType(m)));

mlsub.typing.Monotype ensureMonomorphic(mlsub.typing.Polytype type,
					Block.LocalValue decl)
{
  type.simplify();

  if (type.getConstraint != null)
    {
      // If the type is polymorphic, we treat the type variables as soft:
      // we enter them in the context, so they are not generalized.

      // Make sure we are in a local typing context, so the new type variables
      // are discarded when the typechecking of the current method is over.
      MethodDeclaration.enterLocalContext();

      type.getConstraint.enter(true);
    }

  return type.getMonotype();
}

/*
   Make sure that the error is attached to a location.
   If not, located it a the given located object (which should be a close 
   container of the entity creating the error).
*/
bossa.util.UserError ensureLocated(bossa.util.UserError e, 
				   bossa.util.Located loc)
{
  if (e.location == null)
    e.location = loc.location();
  return e;
}

?(MonoSymbol, mlsub.typing.Monotype) getInstanceof(CallExp condition)
{
  if (! condition.isCallTo("instanceof") || condition.arguments.size() != 2)
    return null;

  ?MonoSymbol sym = localVariable(condition.arguments.getExp(0));

  if (sym == null)
    return null;

  Expression arg2 = condition.arguments.getExp(1);
  if (! (arg2 instanceof TypeConstantExp))
    return null;

  TypeConstantExp type = cast(arg2);
  if (type.getTC() == null)
    return null;

  TypeConstructor tc = notNull(type.getTC());

  if (tc == PrimitiveType.arrayTC)
    return (sym, notNull(type.representedType));

  mlsub.typing.Monotype[?] parameters;

  if (tc.arity() == 0)
    parameters = null;
  else
    {
      let originalType = nice.tools.typing.Types.rawType(sym.getMonotype());
      if (originalType instanceof mlsub.typing.MonotypeConstructor)
	parameters = originalType.getTP();
      else
	return null;
    }

  try {
    return (sym, Monotype.sure(new mlsub.typing.MonotypeConstructor(tc, parameters)));
  } catch(BadSizeEx e) {
    return null;
  }
}

void resolveCCThis(Statement stmt, Located thisLoc, NiceClass classe)
{
  Block block = cast(stmt);

  Statement last = block.last;
  if (last instanceof Block)
  {
    resolveCCThis(last, thisLoc, classe);
    return;
  }
  
  void missingThisError()
  {
    User.error(thisLoc, "The last statement must be a call to 'this' constructor");
  }

  if (! (last instanceof ExpressionStmt))
    missingThisError();

  ExpressionStmt expstmt = cast(last);

  if (! (expstmt.exp instanceof CallExp))
    missingThisError();

  CallExp call = cast(expstmt.exp);

  if (! (call.function instanceof IdentExp))
    missingThisError();

  IdentExp ident = cast(call.function);

  if (! ident.toString().equals("this"))
    missingThisError();

  Location loc = ident.location();
  call.function = createOverloadedSymbolExp(classe.getConstructorCallSymbols(),
					FormalParameters.thisName);
  notNull(call.function).setLocation(loc);
}

void resolveGlobalConstants(Pattern pattern)
{
  ?VarSymbol findRefSymbol(LocatedString refName)
  {
    for (sym : Node.getGlobalScope().lookup(refName))
      {
	if (sym instanceof GlobalVarDeclaration.GlobalVarSymbol ||
            sym instanceof EnumDefinition.EnumSymbol )
          return sym;
      }

    return null;
  }

  if (pattern.refName != null)
      {
	?VarSymbol symbol = findRefSymbol(notNull(pattern.refName));
	if (symbol instanceof GlobalVarDeclaration.GlobalVarSymbol)
	  {
	    if (symbol.getValue() instanceof ConstantExp && symbol.constant)
	      {
		ConstantExp val = cast(symbol.getValue());
		if (Typing.testRigidLeq(val.tc, PrimitiveType.longTC))
		  {
		    pattern.tc = val.tc;
		    pattern.atValue = val;
                    return;
		  }
	      }
	  }
	User.error(pattern.refName, notNull(pattern.refName).toString() + " is not a global constant with an integer value."); 
      }

  if (pattern.name == null)
    return;

  ?VarSymbol symbol = findRefSymbol(notNull(pattern.name));
  if (symbol == null)
    return;

  if (symbol instanceof EnumDefinition.EnumSymbol)
    {
      NewExp val = cast(symbol.getValue());

      pattern.tc = val.tc;
      pattern.atValue = new ConstantExp(null, pattern.tc, symbol,
				notNull(pattern.name).toString(), pattern.location);
      pattern.refName = pattern.name;
      pattern.name = null;
      return;
    }

  if (! (symbol instanceof GlobalVarDeclaration.GlobalVarSymbol))
    return;

  if (symbol.getValue() instanceof ConstantExp)
    {
      if (!symbol.constant)
        User.error(pattern.name, "" + pattern.name + " is not constant");

      ConstantExp val = cast(symbol.getValue());

      if (val.tc == PrimitiveType.floatTC)
	return;

	if (val instanceof StringConstantExp)
          pattern.typeConstructor = new TypeIdent(new LocatedString("java.lang.String",
								pattern.location));
	 pattern.tc = val.tc;
	 pattern.atValue = val;
         pattern.name = null;
    }
  else if (symbol.getValue() instanceof NewExp)
    {
       NewExp val = cast(symbol.getValue());
       pattern.tc = val.tc;
       pattern.atValue = new ConstantExp(null, pattern.tc, symbol,
				notNull(pattern.name).toString(), pattern.location);
       pattern.refName = pattern.name;
       pattern.name = null;
    }
  else
    User.error(pattern.name, "The value of " + pattern.name + " can't be used as pattern");
}


// For bootstrap
void _printStackTraceWithSourceInfo(Throwable t) =
  printStackTraceWithSourceInfo(t);

/****************************************************************
 * Temporary: this should be solved when AST classes are written 
 * in Nice, with precise types for the fields.
 ****************************************************************/

LocatedString name(VarSymbol) = native VarSymbol.name;
mlsub.typing.Polytype getType(Expression) = 
  native mlsub.typing.Polytype Expression.getType();
mlsub.typing.Monotype type(MonoSymbol) = native MonoSymbol.type;
GlobalTypeScope getGlobalTypeScope() = native GlobalTypeScope Node.getGlobalTypeScope();
List<Block.LocalDeclaration> locals(Block) = native Block.locals;
?Statement[] statements(Block) = native Block.statements;
?gnu.bytecode.ClassType staticClass(Arguments) = native gnu.bytecode.ClassType Arguments.staticClass();
List<VarSymbol> findJavaMethods(?gnu.bytecode.ClassType, String, int) = native List JavaClasses.findJavaMethods(gnu.bytecode.ClassType,java.lang.String,int);
List<VarSymbol> findJavaMethods(?gnu.bytecode.ClassType, String) = native List JavaClasses.findJavaMethods(gnu.bytecode.ClassType,java.lang.String);
Arguments arguments(CallExp) = native CallExp.arguments;
TypeParameters TypeParameters(List<Monotype>) = native new bossa.syntax.TypeParameters(List);
Block Block(List<Statement>) = native new bossa.syntax.Block(List);
String explainNoMatch(Arguments, List<VarSymbol>) = native String Arguments.explainNoMatch(List);
Map<VarSymbol,mlsub.typing.Polytype> types(Arguments) = native Arguments.types;
<T> String map(String, String, String, T[]) = native String bossa.util.Util.map(String, String, String, Object[]);
Stack<bossa.link.Alternative> sortedAlternatives(MethodDeclaration) = native Stack bossa.link.Alternative.sortedAlternatives(MethodDeclaration);
List<VarSymbol> getConstructorCallSymbols(NiceClass) = native List NiceClass.getConstructorCallSymbols();
LinkedList<VarSymbol> getConstructors(mlsub.typing.TypeConstructor) = native LinkedList TypeConstructors.getConstructors(mlsub.typing.TypeConstructor);
// Retypings needed since java types are not strict.

Block newBlock(?Statement[] statements) = native new Block(Statement[]);
mlsub.typing.Polytype boolPolytype() = native PrimitiveType.boolPolytype;
mlsub.typing.Polytype longPolytype() = native PrimitiveType.longPolytype;
mlsub.typing.Monotype boolType() = native PrimitiveType.boolType;
mlsub.typing.Monotype longType() = native PrimitiveType.longType;

// Local Variables:
// nice-xprogram: "../bin/nicec -d ../classes --sourcepath=../src"
// End:
