
package nice.lang;

import java.util.*;

/****************************************************************
 * Collection
 ****************************************************************/

<Any T> void foreach(java.util.Collection<T>, T->void);
// Backward compatibility. `iter` will probably be removed sometime.
<Any T> void iter(java.util.Collection<T> c, T->void f) = c.foreach(f);

<java.util.Collection C, T, U> C<U> similarEmptyCollection(C<T>);

<java.util.Collection C, Any T, Any U> C<U> map(C<T>, T->U);

// A more precise type for filter would be:
// <Collection C, T, U | T <: U> C<U> filter(C<T>, T -> boolean);
// This would allow List<A> lA = lB.filter(...) where B is a subclass of A.

<java.util.Collection C, Any T> C<T> filter(C<T>, T->boolean);

/** Return a collection containing all elements for which converter
    returns a non-null value.
    It is possible to retain only elemnts with a subtype of the original
    element type, in which case the returned collection has that 
    element type.
*/
<Collection C, T, U> C<!U> filter(C<T> source, T->?U converter)
{
  C<!U> res = source.similarEmptyCollection();
  source.foreach(T elem => {
    ?U converted = converter(elem);
    if (converted != null)
      res.add(converted);
  });
  return res;
}


/** @deprecated */
<T> void keep  (Collection<T> c, T->boolean test) = c.retain(test);

/** Modifies c, only keeping the elements for which test returns true. */
<T> void retain (Collection<T> c, T->boolean test)
{
  Iterator<T> i = c.iterator();
  while (i.hasNext())
    {
      T element = i.next();
      if (! (test(element)))
	i.remove();
    }
}

/** Modifies c, removing the elements for which test returns true. */
<T> void remove (Collection<T> c, T->boolean test)
{
  Iterator<T> i = c.iterator();
  while (i.hasNext())
    {
      T element = i.next();
      if (test(element))
	i.remove();
    }
}


<Any T, Any U> U foldLeft(java.util.List<T> l, (U, T)->U f, U init)
{
  U res = init;
  l.foreach(T elem => { res = f(res, elem); });
  return res;
}

<Any T, Any U> U foldRight(java.util.List<T> l, (T, U)->U f, U init) =
  foldRight(l, f, init, 0);

private <Any T, Any U> 
U foldRight(java.util.List<T> l, (T, U)->U f, U init, int from)
{
  if (from < l.size())
    return f(l[from], l.foldRight(f, init, from + 1));
  else
    return init;
}

<Any T> List<T> slice(List<T> list, int from = 0, int to = -1)
{
  if (to == -1) 
    to = list.size() - 1;

  List<T> res = new ArrayList(to - from + 1);
  for (int i = from; i <= to; i++)
    res.add(list[i]);
  return res;
}

/****************************************************************
 * Implementations
 ****************************************************************/

/** 
    Default implementation, using an Iterator.
*/
<T> foreach(c@java.util.Collection, f) 
{
  for (java.util.Iterator<T> i = c.iterator(); i.hasNext();)
    f(i.next());
}

/** 
    A more efficient implementation for lists: doesn't allocate an Iterator.
*/
foreach(l@java.util.List, f)
{
  for (int i = 0; i < l.size; i++)
    f(l.get(i));
}

<C,T,U> map(c, f)
{
  C<U> res = c.similarEmptyCollection();
  c.foreach(T elem => { res.add(f(elem)); });
  return res;
}

<C,T> filter(c, test)
{
  C<T> res = c.similarEmptyCollection();
  c.foreach(T elem => { if(test(elem)) res.add(elem); });
  return res;
}

similarEmptyCollection(c) 
{
  throw new Error("The method similarEmptyCollection is not yet implemented for " + c.getClass());
}

similarEmptyCollection(c#ArrayList) = new ArrayList(c.size());

similarEmptyCollection(c#LinkedList) = new LinkedList();

similarEmptyCollection(c#Vector) = new Vector(c.size());

similarEmptyCollection(c#Stack) = new Stack();

/****************************************************************
 * Sort
 ****************************************************************/

/**
   comparator must return a negative integer, zero, or a positive integer 
   as the first argument is less than, equal to, or greater than the second.
*/
<T> void sort(List<T> list, (T,T) -> int comparator) 
{
  Collections.sort(list, new NiceComparator(comparator: comparator));
}

class NiceComparator<T> implements java.util.Comparator
{
  final (T,T) -> int comparator;

  compare(x, y) = (this.comparator)(x,y);
}

/****************************************************************
 * Standard operations
 ****************************************************************/

/** @deprecated */
<Any T> boolean has (java.util.List<T> s, T->boolean test) = s.contains(test);

<Any T> boolean contains (java.util.List<T> s, T->boolean test)
{
  for (int i = 0; i < s.size(); i++)
    if (test(s[i]))
      return true;

  return false;
}

/** Find the first element that passes the given test.
    @throw java.util.NoSuchElementException if there is no such element.
*/
<Any T> T find (java.util.List<T> s, T->boolean test)
{
  for (int i = 0; i < s.size(); i++)
    if (test(s[i]))
      return s[i];

  throw new java.util.NoSuchElementException();
}

/** Find the last element that passes the given test.
    @throw java.util.NoSuchElementException if there is no such element.
*/
<Any T> T findLast (java.util.List<T> s, T->boolean test)
{
  for (int i = s.size(); --i >= 0;)
    if (test(s[i]))
      return s[i];

  throw new java.util.NoSuchElementException();
}

/** Find the first element that passes the given test.
    Returns <code>null</code> if there is no such element.
*/
<Any T> ?T search (java.util.List<!T> s, !T->boolean test)
{
  for (int i = 0; i < s.size(); i++)
    if (test(s[i]))
      return s[i];

  return null;
}

/** Find the last element that passes the given test.
    Returns <code>null</code> if there is no such element.
*/
<Any T> ?T searchLast (java.util.List<!T> s, !T->boolean test)
{
  for (int i = s.size(); --i >= 0;)
    if (test(s[i]))
      return s[i];

  return null;
}

/** @deprecated */
<Any T> int findIndex (List<T> s, T->boolean test) = s.findIndex(test);

<Any T> int indexOf (List<T> s, T->boolean test)
{
  for (int i = 0; i < s.size(); i++)
    if (test(s[i]))
      return i;

  throw new java.util.NoSuchElementException();
}

boolean or(java.util.List<boolean> s)
{
  for (int i = 0; i < s.size(); i++)
    if (s[i])
      return true;

  return false;
}

long max(java.util.List<long> s) requires !s.isEmpty()
{
  long res = Long.MIN_VALUE;

  for(int i = 0; i < s.size(); i++)
    if (s[i] > res)
      res = s[i];

  return res;
}

/** @return the concatenation of the two lists, as a new list. */
<T, T1, T2 | T1 <: T, T2 <: T> List<T> `+`(List<T1> l1, List<T2> l2)
{
  List<T> res = new ArrayList(l1.size + l2.size);
  res.addAll(l1);
  res.addAll(l2);
  return res;
}

/****************************************************************
 * Printing
 ****************************************************************/

/*
We need overriding of native methods for this
toString(s@List)
{
  if (s.size() == 0)
    return "[]";

  StringBuffer buf = new StringBuffer();
  buf.append("[");
  buf.append(s[0].toString());
  for (int i=1; i<s.size(); i++)
    {
      buf.append(", ");
      buf.append(s[i].toString());
    }
  buf.append("]");
  return buf.toString();
}
*/

/****************************************************************
 * toArray
 ****************************************************************/

<Any T> T[] toArray(java.util.Collection<T> c)
{
  T[] res = cast(new T[c.size()]);

  int i = 0;
  c.foreach(T elem => res[i++] = elem);
  return res;
}
